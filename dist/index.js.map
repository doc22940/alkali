{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.js","webpack:///webpack/bootstrap f26c36f42cdf4232fccc","webpack:///./index.js","webpack:///./Element.js","webpack:///./Variable.js","webpack:///./util/lang.js","webpack:///./Renderer.js","webpack:///./react.js","webpack:///./operators.js","webpack:///./Copy.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","Element","Variable","react","Renderer","operators","Copy","main","Object","create","VMap","VArray","VPromised","all","spawn","func","valueOf","assign","apply","undefined","lang","booleanStyle","options","element","value","key","style","defaultStyle","directStyle","layoutChildren","parent","children","container","prepend","fragment","length","doc","createDocumentFragment","i","l","childNode","child","currentParent","appendChild","isContentNode","contentNode","notifies","ref","isIterable","variableAsContent","Array","nodeType","Error","createTextNode","insertBefore","firstChild","content","textNode","TextRenderer","variable","bidirectionalHandler","InputPropertyRenderer","name","inputs","tagName","bindChanges","prototype","renderSelectValueUpdate","type","isNaN","noop","applyAttribute","AttributeRenderer","setAttribute","applySubProperties","renderer","SubPropertyRenderer","compose","PropertyRenderer","arguments","renderUpdate","subKey","subValue","assignProperties","properties","styleDefinition","propertyHandler","_propertyHandlers","styleDefinitions","StyleRenderer","slice","addEventListener","defineProperty","enumerable","configurable","writable","buildContent","each","defineHasOwn","ItemClass","getCollectionOf","Item","hasOwn","itemVariable","from","_item","ListRenderer","forEach","item","childElement","buildInputContent","conversion","nextTurn","inputEvents","event","result","put","Context","deny","parseFloat","inputType","inputProperty","date","datetime","time","applyToClass","applyOnCreate","_applyOnCreate","classHandlers","TypeError","getApplySet","Class","hasOwnProperty","getForClass","parentApplySet","getPrototypeOf","propertyHandlers","keys","getOwnPropertyNames","isGenerator","propertyName","toLowerCase","renderDescriptor","renderMethod","map","WeakMap","get","has","set","makeElementConstructor","selector","constructor","withProperties","forTarget","property","propertyForElement","superConstructor","selectorMatch","match","SELECTOR_REGEX","operator","className","remaining","createElement","presumptiveParentMap","setPrototypeOf","ElementApplyOnCreate","argument","created","ready","append","registerTag","registerElement","getConstructor","tags","setupElement","props","elementPropertyHandlers","assigned","handlers","generate","elements","elementName","ElementClass","generateInputs","HTMLInputElement","target","From","Target","createInstance","elementMap","ownedClasses","instanceMap","parentNode","ownedInstances","instance","subject","ThisElementVariable","_Variable","variableProperties","alkaliRenderers","elementOverlay","cleanup","renderers","stop","needsRestart","restart","elementAttached","attached","elementDetached","detached","firstVisit","node","state","__alkaliAttached__","action","body","contains","knownElementProperties","newValue","definition","ClassNameRenderer","ElementRenderer","currentClassName","changingClassName","removed","replace","document","tag","INPUT","TEXTAREA","display","visibility","color","opacity","zoom","minZoom","maxZoom","fontWeight","position","textDecoration","base","proto","__proto__","classes","flag","class","for","role","render","GeneratorVariable","bind","dataset","attributes","styleObjectHandler","HTMLElement","input","copy","valueAsNumber","valueAsDate","checked","e","select","textarea","a","area","button","dialog","embed","form","frame","frameset","iframe","option","optgroup","output","label","td","th","script","track","link","meta","meter","progress","del","ins","source","video","keygen","object","param","radios","querySelectorAll","radio","dispatchEvent","Event","within","aliases","Anchor","Paragraph","Textarea","DList","UList","OList","ListItem","Text","TextInput","TableRow","TableCell","TableHeaderCell","TableHeader","TableBody","alias","to","refresh","moveLiveElementsEnabled","Symbol","hasInstance","extend","ExtendedElement","descriptor","getOwnPropertyDescriptor","MutationObserver","lifeStates","nodes","observer","mutations","il","mutation","j","jl","nodeIteration","k","kl","baseNode","currentNode","nextNode","nextSibling","observe","childList","subtree","specify","distinctive","generics","push","distinctSubject","subjectMap","specifiedInstance","defaultInstance","getContextualized","_contextMap","context","matches","merge","childContext","getDistinctElement","when","callback","then","NotifyingContext","listener","whenAll","promiseInvolved","registerListener","listeners","propertyListenersMap","listenerId","autoObserveObjects","listeningToObject","deregisterListener","index","splice","RefreshEvent","visited","Set","PropertyChangeEvent","childEvent","AddEvent","args","DeleteEvent","forPropertyNotifyingValues","returnedVariable","hasChildNotifiers","subProperties","_properties","arrayToModify","_willModify","cachedValue","array","updateVersion","results","cachedVersion","version","insertedAt","added","startingIndex","arrayLength","addedCount","arrayPosition","updated","modifier","removedAt","removalCount","previousIndex","oldValue","defineArrayMethod","method","IterativeResults","IterativeMethod","addFlag","functionValue","objectUpdated","_propertyChange","Composite","keyMapping","valueArray","resultObject","createForInstance","generalizeClass","prototypeNames","getGeneralizedDescriptor","generalizeMethod","instanceForContext","noChange","RequestChange","RequestSet","nextId","freeze","contextFromCache","newContext","contextualize","parentContext","contextualized","contextMap","addInput","inputVariable","nextProperty","VariablePrototype","_currentValue","valueContext","gotValueAndListen","gotValue","addKey","getValue","previousNotifyingValue","ownObject","stopNotifies","isMap","Map","PropertyClass","propertyVariable","ContextualizedVariable","defaultContext","_changeValue","__debug","console","log","stack","onPropertyChange","eachKey","Call","forDependencies","hasNotifyingChild","init","dependency","handles","remove","computedVariable","getVersion","Math","max","getSubject","selectVariable","getUpdates","since","updates","nextUpdateMap","updateEvent","by","add","contextualInstance","dependent","fixed","collection","invalidate","subscribe","updateQueued","next","updateReceiver","unsubscribe","size","setValue","undefine","proxy","proxiedVariable","thisVariable","error","complete","onValue","toJSON","toString","callbackOrItemClass","callbackOrContext","transformFunction","reverse","schema","parentSchemaProperties","validate","valid","isValid","validation","Validating","structured","structure","existing","getId","observeObject","observerCount","events","el","done","deliverChanges","collectionOf","_sN","_debug","unshift","pop","shift","iterator","Caching","withComputedValue","computedValue","transformContext","contextualizedVariable","newVersion","argumentName","resolved","getArguments","transform","invoke","argsVersion","execute","originalValue","observeArguments","handlesVariables","handlesPromises","setReverse","generic","notify","indexOf","filter","keyGenerator","valueGenerator","hasKeyFunction","hasValueFunction","hasKey","group","generator","resuming","lastValue","generatorIterator","isThrowing","stepReturn","nextVariable","delegatedGenerator","description","_collectionOf","_collection","Collection","generalize","Function","ExtendedVariable","Base","_defaultInstance","feature","hasFeatures","diff","previous","current","queued","toJSONHidden","displayName","queuedListeners","requestAnimationFrame","promise","Promise","keyFlag","currentValue","targetAncestor","previousSet","previousGet","timerStarted","setInterval","watchedObjects","watchedCopies","unobserve","Hidden","processAnimationFrame","toRender","setTimeout","resolve","reject","resolution","finished","errorResolution","isResolved","queue","errback","handle","newError","values","mapProperty","intermediary","errorHandler","onResolve","onError","onEach","readyInputs","lastPromiseResult","previousPromiseResult","div","update","updateRendering","shouldRender","alwaysUpdate","updateOnStart","ContentRenderer","onElementRemoval","invalidatedElements","invalidated","contextMatches","invalidateElement","invalidatedParts","queueTask","processQueue","updateElement","always","thisElement","renderersOnShow","addElement","omitValueOf","started","renderLoading","eventualValue","innerHTML","builtList","replaceChild","childNodes","nodeValue","eachItem","nextChild","childElements","removeChild","onShowElement","shownElement","getElementsByClassName","includingTop","onlyChildren","getElementsByTagName","preserveObjects","_getAsObject","ObjectTransform","prop","directPropertyValue","cond","test","consequent","alternate","choose","fcall","mcall","ncall","concat","obj","getOperatingFunction","expression","operatingFunctions","precedence","forward","reverseA","reverseB","addFlags","operatorHandler","infix","b","deepCopy","derivativeMap","copiedFrom","isDirty","derivative","thisValue","getCopyOf","save","original","newCopiedFrom","onSave","revert"],"mappings":"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AA,wCACAC,UAAA,eACAC,QAAA,qFACAC,QAAA,gCACAC,UAAA,SACAC,QAAA,0DACAC,OAAA,WACAC,IAAA,qBACAC,IAAA,qBACAC,QAAA,6DACA7P,OAAA,gBACA8P,OAAA,gCACAC,MAAA,kFACAC,MAAA,uCACAC,OAAA,4CACAC,UAAA,0BACAC,KAAA,mBACAC,KAAA,mBACAC,QAAA,uCACAC,OAAA,yFACAC,QAAA,yDACAC,QAAA,sHACAC,OAAA,oCAeArC,GAAApL,EAAA,SAAAiJ,EAAApM,EAAAE,GACAF,EAAAG,MAAAD,GAAArC,KAAA0E,MAAA6J,GAyIAvL,GAAAuD,iBAAA,iBAAAuB,GACA,GAAAwE,GAAAxE,EAAAwE,MACA,cAAAA,EAAAtH,KAEA,OADAgO,GAAAhQ,EAAAiQ,iBAAA,qBACA/P,EAAA,EAAAC,EAAA6P,EAAAjQ,OAAqCG,EAAAC,EAAOD,IAAA,CAC5C,GAAAgQ,GAAAF,EAAA9P,EACAgQ,GAAAxO,OAAA4H,EAAA5H,MAAAwO,IAAA5G,GACA4G,EAAAC,cAAA,GAAAC,OAAA,uBAiCA,IAsJA9P,IAtJAsF,IACA1B,OAAA,SAAArG,EAAAuB,GACA8E,EAAArG,EAAAuB,KA+QAkE,YAoBAzF,GAAAuJ,EAAA7J,KAAA,mBAAAoQ,yBAAA,aAEA9P,IAAA0K,cACA1K,GAAAgB,OAAAkE,EAEAlF,GAAAwS,OAAA,SAAAlR,KAIA6J,GACA,QACA,SACA,QACA,QACA,KACA,QACA,QACA,WACA,WACA,QACA,QACA,QACA,KACA,QACA,MACA,WACA,KACA,KACA,UACA,QACA,OACA,SACA,SACA,SACA,QACA,WACA,MACA,UACA,QACA,IACA,SACA,SACA,WACA,SACA,KACA,MACA,MACA,QACA,OACA,OACA,MACA,OACA,SACA,QACA,KACA,SACA,QACA,QACA,SACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,WACA,QACA,OACA,OACA,QACA,UACA,QACA,SACA,SACA,aACA,SACA,OACA,OACA,WACA,MACA,UACA,UACA,MACA,MACA,SACA,UACA,WACA,KACA,SACA,SACA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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"alkali\"] = factory();\n\telse\n\t\troot[\"alkali\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"alkali\"] = factory();\n\telse\n\t\troot[\"alkali\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/// <reference path=\"./index.d.ts\" />\r\n\tif (true) {\r\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(2), __webpack_require__(5), __webpack_require__(4), __webpack_require__(6), __webpack_require__(7)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Element, Variable, react, Renderer, operators, Copy) {\r\n\t\tvar main = Object.create(Element)\r\n\t\tmain.Copy = Copy\r\n\t\tmain.Element = Element\r\n\t\tmain.Variable = Variable\r\n\t\tmain.VMap = Variable.VMap\r\n\t\tmain.VArray = Variable.VArray\r\n\t\tmain.VPromised = Variable.VPromised\r\n\t\tmain.all = Variable.all\r\n\t\tmain.react = react\r\n\t\tmain.spawn = function(func) {\r\n\t\t\treturn react(func).valueOf()\r\n\t\t}\r\n\t\tmain.Renderer = Renderer\r\n\t\tObject.assign(main, Renderer)\r\n\t\tObject.assign(main, operators)\r\n\t\treturn main\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\t} else if (typeof module === 'object' && module.exports) {\r\n\t\t// delegate to the built UMD file, if loaded in node\r\n\t\tmodule.exports = (require)('./dist/index')\r\n\t}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(4), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Variable, Renderer, lang) {\r\n\t\tvar knownElementProperties = [\r\n\t\t\t'textContent', // Node\r\n\t\t\t'id', 'className', 'innerHTML', // Element\r\n\t\t\t'title', 'lang', 'translate', 'dir', 'tabIndex', 'accessKey', 'draggable', 'spellcheck', 'contentEditable', 'innerText', 'webkitdropzone'] // HTMLElement\r\n\t\r\n\t\tvar SELECTOR_REGEX = /(\\.|#)([-\\w]+)(.+)?/\r\n\t\tvar isGenerator = lang.isGenerator\r\n\t\tvar Context = Variable.Context\r\n\t\tvar PropertyRenderer = Renderer.PropertyRenderer\r\n\t\tvar InputPropertyRenderer = Renderer.InputPropertyRenderer\r\n\t\tvar AttributeRenderer = Renderer.AttributeRenderer\r\n\t\tvar StyleRenderer = lang.compose(Renderer.StyleRenderer, function StyleRenderer() {\r\n\t\t\tRenderer.StyleRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: function(newValue, element) {\r\n\t\t\t\tvar definition = styleDefinitions[this.name]\r\n\t\t\t\tif (definition) {\r\n\t\t\t\t\tdefinition(element, newValue, this.name)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.style[this.name] = newValue\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar ClassNameRenderer = lang.compose(Renderer.ElementRenderer, function ClassNameRenderer(options) {\r\n\t\t\tthis.className = options.className\r\n\t\t\tRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: function(newValue, element) {\r\n\t\t\t\tvar currentClassName = element.className\r\n\t\t\t\tvar changingClassName = this.className\r\n\t\t\t\t// remove the className (needed for addition or removal)\r\n\t\t\t\t// see http://jsperf.com/remove-class-name-algorithm/2 for some tests on this\r\n\t\t\t\tvar removed = currentClassName && (' ' + currentClassName + ' ').replace(' ' + changingClassName + ' ', ' ')\r\n\t\t\t\tif (newValue) {\r\n\t\t\t\t\t// addition, add the className\r\n\t\t\t\t\tchangingClassName = currentClassName ? (removed + changingClassName).slice(1) : changingClassName;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// we already have removed the class, just need to trim\r\n\t\t\t\t\tchangingClassName = removed.slice(1, removed.length - 1)\r\n\t\t\t\t}\r\n\t\t\t\t// only assign if it changed, this can save a lot of time\r\n\t\t\t\tif (changingClassName != currentClassName) {\r\n\t\t\t\t\telement.className = changingClassName\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\t// TODO: check for renderContent with text updater\r\n\t\tvar TextRenderer = Renderer.TextRenderer\r\n\t\tvar ListRenderer = Renderer.ListRenderer\r\n\t\r\n\t\tvar doc = typeof document !== 'undefined' ? document : {\r\n\t\t\tcreateElement: function(tag) {\r\n\t\t\t\treturn {}\r\n\t\t\t},\r\n\t\t\taddEventListener: function() {\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar inputs = {\r\n\t\t\tINPUT: 1,\r\n\t\t\tTEXTAREA: 1\r\n\t\t\t// SELECT: 1, we exclude this, so the default \"content\" of the element can be the options\r\n\t\t}\r\n\t\r\n\t\tfunction booleanStyle(options) {\r\n\t\t\treturn function(element, value, key) {\r\n\t\t\t\tif (typeof value === 'boolean') {\r\n\t\t\t\t\t// has a boolean conversion\r\n\t\t\t\t\tvalue = options[value ? 0 : 1]\r\n\t\t\t\t}\r\n\t\t\t\telement.style[key] = value\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction defaultStyle(element, value, key) {\r\n\t\t\tif (typeof value === 'number') {\r\n\t\t\t\tvalue = value + 'px'\r\n\t\t\t}\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t\tfunction directStyle(element, value, key) {\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t\r\n\t\tvar styleDefinitions = {\r\n\t\t\tdisplay: booleanStyle(['', 'none']),\r\n\t\t\tvisibility: booleanStyle(['visible', 'hidden']),\r\n\t\t\tcolor: directStyle,\r\n\t\t\topacity: directStyle,\r\n\t\t\tzoom: directStyle,\r\n\t\t\tminZoom: directStyle,\r\n\t\t\tmaxZoom: directStyle,\r\n\t\t\tfontWeight: directStyle,\r\n\t\t\tposition: booleanStyle(['absolute', '']),\r\n\t\t\ttextDecoration: booleanStyle(['underline', '']),\r\n\t\t\tfontWeight: booleanStyle(['bold', 'normal'])\r\n\t\t}\r\n\t\t;[\"alignContent\",\"alignItems\",\"alignSelf\",\"animation\",\"animationDelay\",\"animationDirection\",\"animationDuration\",\"animationFillMode\",\"animationIterationCount\",\"animationName\",\"animationPlayState\",\"animationTimingFunction\",\"backfaceVisibility\",\"background\",\"backgroundAttachment\",\"backgroundBlendMode\",\"backgroundClip\",\"backgroundColor\",\"backgroundImage\",\"backgroundOrigin\",\"backgroundPosition\",\"backgroundPositionX\",\"backgroundPositionY\",\"backgroundRepeat\",\"backgroundRepeatX\",\"backgroundRepeatY\",\"backgroundSize\",\"baselineShift\",\"border\",\"borderBottom\",\"borderBottomColor\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\",\"borderBottomStyle\",\"borderBottomWidth\",\"borderCollapse\",\"borderColor\",\"borderImage\",\"borderImageOutset\",\"borderImageRepeat\",\"borderImageSlice\",\"borderImageSource\",\"borderImageWidth\",\"borderLeft\",\"borderLeftColor\",\"borderLeftStyle\",\"borderLeftWidth\",\"borderRadius\",\"borderRight\",\"borderRightColor\",\"borderRightStyle\",\"borderRightWidth\",\"borderSpacing\",\"borderStyle\",\"borderTop\",\"borderTopColor\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderTopStyle\",\"borderTopWidth\",\"borderWidth\",\"bottom\",\"boxShadow\",\"boxSizing\",\"bufferedRendering\",\"captionSide\",\"clear\",\"clip\",\"clipPath\",\"clipRule\",\"color\",\"colorInterpolation\",\"colorInterpolationFilters\",\"colorRendering\",\"counterIncrement\",\"counterReset\",\"cursor\",\"direction\",\"display\",\"emptyCells\",\"fill\",\"fillOpacity\",\"fillRule\",\"filter\",\"flex\",\"flexBasis\",\"flexDirection\",\"flexFlow\",\"flexGrow\",\"flexShrink\",\"flexWrap\",\"float\",\"floodColor\",\"floodOpacity\",\"font\",\"fontFamily\",\"fontFeatureSettings\",\"fontKerning\",\"fontSize\",\"fontStretch\",\"fontStyle\",\"fontVariant\",\"fontVariantLigatures\",\"fontWeight\",\"height\",\"imageRendering\",\"isolation\",\"justifyContent\",\"left\",\"letterSpacing\",\"lightingColor\",\"lineHeight\",\"listStyle\",\"listStyleImage\",\"listStylePosition\",\"listStyleType\",\"margin\",\"marginBottom\",\"marginLeft\",\"marginRight\",\"marginTop\",\"marker\",\"markerEnd\",\"markerMid\",\"markerStart\",\"mask\",\"maskType\",\"maxHeight\",\"maxWidth\",\"maxZoom\",\"minHeight\",\"minWidth\",\"minZoom\",\"mixBlendMode\",\"motion\",\"motionOffset\",\"motionPath\",\"motionRotation\",\"objectFit\",\"objectPosition\",\"opacity\",\"order\",\"orientation\",\"orphans\",\"outline\",\"outlineColor\",\"outlineOffset\",\"outlineStyle\",\"outlineWidth\",\"overflow\",\"overflowWrap\",\"overflowX\",\"overflowY\",\"padding\",\"paddingBottom\",\"paddingLeft\",\"paddingRight\",\"paddingTop\",\"page\",\"pageBreakAfter\",\"pageBreakBefore\",\"pageBreakInside\",\"paintOrder\",\"perspective\",\"perspectiveOrigin\",\"pointerEvents\",\"position\",\"quotes\",\"resize\",\"right\",\"shapeImageThreshold\",\"shapeMargin\",\"shapeOutside\",\"shapeRendering\",\"size\",\"speak\",\"src\",\"stopColor\",\"stopOpacity\",\"stroke\",\"strokeDasharray\",\"strokeDashoffset\",\"strokeLinecap\",\"strokeLinejoin\",\"strokeMiterlimit\",\"strokeOpacity\",\"strokeWidth\",\"tabSize\",\"tableLayout\",\"textAlign\",\"textAlignLast\",\"textAnchor\",\"textCombineUpright\",\"textDecoration\",\"textIndent\",\"textOrientation\",\"textOverflow\",\"textRendering\",\"textShadow\",\"textTransform\",\"top\",\"touchAction\",\"transform\",\"transformOrigin\",\"transformStyle\",\"transition\",\"transitionDelay\",\"transitionDuration\",\"transitionProperty\",\"transitionTimingFunction\",\"unicodeBidi\",\"unicodeRange\",\"userZoom\",\"vectorEffect\",\"verticalAlign\",\"visibility\",\"whiteSpace\",\"widows\",\"width\",\"willChange\",\"wordBreak\",\"wordSpacing\",\"wordWrap\",\"writingMode\",\"zIndex\",\"zoom\"].forEach(function(property) {\r\n\t\t\tstyleDefinitions[property] = styleDefinitions[property] || defaultStyle\r\n\t\t})\r\n\t\tvar styleSheet\r\n\t\tvar presumptiveParentMap = new WeakMap()\r\n\t\r\n\t\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\tfunction createCssRule(selector) {\r\n\t\t\tif (!styleSheet) {\r\n\t\t\t\tvar styleSheetElement = doc.createElement(\"style\")\r\n\t\t\t\tstyleSheetElement.setAttribute(\"type\", \"text/css\")\r\n\t//\t\t\tstyleSheet.appendChild(doc.createTextNode(css))\r\n\t\t\t\tdoc.head.insertBefore(styleSheetElement, doc.head.firstChild)\r\n\t\t\t\tstyleSheet = styleSheetElement.sheet\r\n\t\t\t}\r\n\t\t\tvar cssRules = styleSheet.cssRules || styleSheet.rules\r\n\t\t\treturn cssRules[styleSheet.addRule(selector, ' ', cssRules.length)]\r\n\t\t}\r\n\t\r\n\t\t// TODO: Need to do some more testing to see if that would improve performance:\r\n\t\t// var fragmentThresholdHeuristic = (typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Chrome') > 0) ? 1 : 3\r\n\t\r\n\t\tfunction layoutChildren(parent, children, container, prepend) {\r\n\t\t\tvar fragment = (children.length > 1 || prepend) ? doc.createDocumentFragment() : parent\r\n\t\t\tfor(var i = 0, l = children.length; i < l; i++) {\r\n\t\t\t\tvar child = children[i]\r\n\t\t\t\tvar childNode\r\n\t\t\t\tif (child != null) { // we just skip nulls and undefined, helps make it easier to write conditional element logic\r\n\t\t\t\t\tif (child.create) {\r\n\t\t\t\t\t\t// an element constructor\r\n\t\t\t\t\t\tcurrentParent = parent\r\n\t\t\t\t\t\tchildNode = child.create()\r\n\t\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t\t\tif (child.isContentNode) {\r\n\t\t\t\t\t\t\tcontainer.contentNode = childNode\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (child.notifies) {\r\n\t\t\t\t\t\t// a variable\r\n\t\t\t\t\t\tvar ref = child.isIterable ? fragment : parent\r\n\t\t\t\t\t\tfragment.appendChild(childNode = variableAsContent(ref, child))\r\n\t\t\t\t\t} else if (typeof child == 'object') {\r\n\t\t\t\t\t\tif (child instanceof Array) {\r\n\t\t\t\t\t\t\t// array of sub-children\r\n\t\t\t\t\t\t\tcontainer = container || parent\r\n\t\t\t\t\t\t\tchildNode = childNode || parent\r\n\t\t\t\t\t\t\tlayoutChildren(childNode.contentNode || childNode, child, container)\r\n\t\t\t\t\t\t} else if (child.nodeType) {\r\n\t\t\t\t\t\t\t// an element itself\r\n\t\t\t\t\t\t\tfragment.appendChild(childNode = child)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// TODO: apply properties to last child, but with binding to the parent (for events)\r\n\t\t\t\t\t\t\tthrow new Error('Unknown child type ' + child)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// a primitive value\r\n\t\t\t\t\t\tchildNode = doc.createTextNode(child)\r\n\t\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (fragment != parent) {\r\n\t\t\t\tif (prepend) {\r\n\t\t\t\t\tparent.insertBefore(fragment, parent.firstChild)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tparent.appendChild(fragment)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn childNode\r\n\t\t}\r\n\t\tfunction variableAsContent(parent, content) {\r\n\t\t\tif (content == null) {\r\n\t\t\t\treturn doc.createTextNode('')\r\n\t\t\t}\r\n\t\t\tvar textNode\r\n\t\t\tif (content.notifies) {\r\n\t\t\t\ttextNode = doc.createTextNode('')\r\n\t\t\t\tnew TextRenderer({\r\n\t\t\t\t\telement: parent,\r\n\t\t\t\t\ttextNode: textNode,\r\n\t\t\t\t\tvariable: content\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\ttextNode = doc.createTextNode(content)\r\n\t\t\t}\r\n\t\t\treturn textNode\r\n\t\t}\r\n\t\r\n\t\tfunction bidirectionalHandler(element, value, key) {\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tnew InputPropertyRenderer({\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t\tif (inputs[element.tagName] || element.tagName === 'SELECT') {\r\n\t\t\t\t\tbindChanges(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (element.tagName === 'SELECT' && key === 'value') {\r\n\t\t\t\t\t// use the deferred <select> value assignment\r\n\t\t\t\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate(value, element)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (element.type === 'number') {\r\n\t\t\t\t\t\tif (isNaN(value)) {\r\n\t\t\t\t\t\t\tvalue = ''\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telement[key] = value\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction noop() {}\r\n\t\tvar propertyHandlers = {\r\n\t\t\tchildren: noop,\r\n\t\t\ttagName: noop,\r\n\t\t\tclasses: function(element, classes) {\r\n\t\t\t\tif (!(classes.length > -1)) {\r\n\t\t\t\t\t// index the classes, if necessary\r\n\t\t\t\t\tvar i = 0\r\n\t\t\t\t\tfor (var key in classes) {\r\n\t\t\t\t\t\tif (!classes[i]) {\r\n\t\t\t\t\t\t\tclasses[i] = key\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ti++\r\n\t\t\t\t\t}\r\n\t\t\t\t\tclasses.length = i\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i = 0, l = classes.length; i < l; i++) {\r\n\t\t\t\t\t// find each class name\r\n\t\t\t\t\tvar className = classes[i]\r\n\t\t\t\t\tvar flag = classes[className]\r\n\t\t\t\t\tif (flag && flag.notifies) {\r\n\t\t\t\t\t\t// if it is a variable, we react to it\r\n\t\t\t\t\t\tnew ClassNameRenderer({\r\n\t\t\t\t\t\t\telement: element,\r\n\t\t\t\t\t\t\tclassName: className,\r\n\t\t\t\t\t\t\tvariable: flag\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else if (flag || flag === undefined) {\r\n\t\t\t\t\t\telement.className += ' ' + className\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tclass: applyAttribute,\r\n\t\t\tfor: applyAttribute, // TODO: move to label?\r\n\t\t\trole: applyAttribute,\r\n\t\t\trender: function(element, value, key, properties) {\r\n\t\t\t\t// TODO: This doesn't need to be a property updater (is in place for *render())\r\n\t\t\t\t// we should also verify it is a generator\r\n\t\t\t\t// and maybe, at some point, find an optimization to eliminate the bind()\r\n\t\t\t\tnew PropertyRenderer({\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: new Variable.GeneratorVariable(value.bind(element, properties)),\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tdataset: applySubProperties(function(newValue, element, key) {\r\n\t\t\t\telement.dataset[key || this.name] = newValue\r\n\t\t\t}),\r\n\t\t\tattributes: applySubProperties(function(newValue, element, key) {\r\n\t\t\t\telement.setAttribute(key || this.name, newValue)\r\n\t\t\t}),\r\n\t\t\tstyle: function(element, value, key) {\r\n\t\t\t\tif (typeof value === 'string') {\r\n\t\t\t\t\telement.setAttribute('style', value)\r\n\t\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\t\tnew AttributeRenderer({\r\n\t\t\t\t\t\tname: 'style',\r\n\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyleObjectHandler(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tknownElementProperties.forEach(function(property) {\r\n\t\t\tpropertyHandlers[property] = true\r\n\t\t})\r\n\t\tif (typeof HTMLElement !== 'undefined') {\r\n\t\t\tHTMLElement.prototype._propertyHandlers = propertyHandlers // inherit this, at least for now\r\n\t\t}\r\n\t\tvar elementPropertyHandlers = {\r\n\t\t\tinput: lang.copy(['accept', 'alt', 'autocomplete', 'autofocus', 'capture', 'defaultChecked', 'dirName', 'disabled', 'form', 'files', 'formAction', 'formEnctype', 'formMethod', 'formNoValidate', 'formTarget', 'indeterminate', 'inputMode', 'list', 'max', 'maxLength', 'min', 'minLength', 'multiple', 'name', 'pattern', 'placeholder', 'readOnly', 'required', 'size', 'src', 'step', 'type', 'defaultValue', 'willValidate', 'validity', 'validationMessage', 'useMap', 'autocapitalize', 'webkitdirectory', 'incremental', 'stepUp', 'stepDown'], {\r\n\t\t\t\tvalue: bidirectionalHandler,\r\n\t\t\t\tvalueAsNumber: bidirectionalHandler,\r\n\t\t\t\tvalueAsDate: bidirectionalHandler,\r\n\t\t\t\tchecked: bidirectionalHandler,\r\n\t\t\t\ttype: function(element, value) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\telement.type = value\r\n\t\t\t\t\t} catch(e) {\r\n\t\t\t\t\t\t// IE 11 will throw an error here\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}),\r\n\t\t\tselect: lang.copy(['name', 'size', 'type', 'selectedIndex', 'validationMessage'], {\r\n\t\t\t\tvalue: bidirectionalHandler\r\n\t\t\t}),\r\n\t\t\ttextarea: lang.copy(['cols', 'dirName', 'maxLength', 'minLength', 'name', 'placeholder', 'rows', 'wrap', 'type', 'defaultValue', 'textLength', 'validationMessage', 'autocapitalize'], {\r\n\t\t\t\tvalue: bidirectionalHandler\r\n\t\t\t}),\r\n\t\t\ta: ['target', 'download', 'ping', 'rel', 'hreflang', 'type', 'referrerPolicy', 'href', 'media'],\r\n\t\t\tarea: ['target', 'download', 'coords', 'rel', 'hreflang', 'type', 'referrerPolicy', 'href', 'media', 'alt', 'shape'],\r\n\t\t\tbutton: ['formAction', 'formEnctype', 'formMethod', 'formTarget', 'name', 'type', 'value', 'validationMessage'],\r\n\t\t\tdialog: ['open'],\r\n\t\t\tembed: ['src', 'type', 'name'],\r\n\t\t\tform: ['acceptCharset', 'action', 'autocomplete', 'enctype', 'encoding', 'method', 'name', 'target', 'novalidate'],\r\n\t\t\tframe: ['name', 'scrolling', 'src', 'frameBorder'],\r\n\t\t\tframeset: ['cols', 'rows'],\r\n\t    iframe: ['src', 'srcdoc', 'name', 'referrerPolicy', 'align', 'scrolling', 'frameBorder', 'longDesc'],\r\n\t    option: ['label', 'value', 'text', 'index'],\r\n\t    optgroup: ['label'],\r\n\t    output: ['name', 'type', 'defaultValue', 'value', 'validationMessage'],\r\n\t    label: ['htmlFor'],\r\n\t    td: ['colSpan', 'rowSpan'],\r\n\t    th: ['colSpan', 'rowSpan'],\r\n\t    script: ['src', 'type', 'charset', 'text', 'event', 'htmlFor', 'integrity'],\r\n\t    style: ['media', 'type'],\r\n\t    track: ['kind', 'src', 'srclang', 'label'],\r\n\t    link: ['href', 'rel', 'media', 'hreflang', 'type', 'charset', 'rev', 'target', 'integrity', 'as'],\r\n\t    meta: ['name', 'httpEquiv', 'content', 'scheme'],\r\n\t    meter: ['value', 'min', 'max', 'low', 'high', 'optimum'],\r\n\t    progress: ['value', 'max', 'position'],\r\n\t    del: ['cite', 'dateTime'],\r\n\t    ins: ['cite', 'dateTime'],\r\n\t    source: ['src', 'type', 'srcset', 'sizes', 'media'],\r\n\t    video: ['videoWidth', 'videoHeight', 'poster', 'webkitDecodedFrameCount', 'webkitDroppedFrameCount'],\r\n\t    keygen: ['challenge', 'keytype', 'name', 'type', 'validationMessage'],\r\n\t    object: ['data', 'type', 'name', 'useMap', 'validationMessage', 'archive', 'code', 'hspace', 'standby', 'vspace', 'codeBase', 'codeType'],\r\n\t    param: ['name', 'value', 'type', 'valueType']\r\n\t\t}\r\n\t\r\n\t\tfunction applyAttribute(element, value, key) {\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tnew AttributeRenderer({\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\telement.setAttribute(key, value)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar styleObjectHandler = applySubProperties(function(newValue, element, key) {\r\n\t\t\telement.style[key || this.name] = newValue\r\n\t\t})\r\n\t\r\n\t\tfunction applySubProperties(renderer) {\r\n\t\t\tvar SubPropertyRenderer = lang.compose(PropertyRenderer, function SubPropertyRenderer(options) {\r\n\t\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t\t}, {\r\n\t\t\t\trenderUpdate: renderer\r\n\t\t\t})\r\n\t\t\treturn function(element, value, key) {\r\n\t\t\t\tfor (var subKey in value) {\r\n\t\t\t\t\tvar subValue = value[subKey]\r\n\t\t\t\t\tif (subValue && subValue.notifies) {\r\n\t\t\t\t\t\tnew SubPropertyRenderer({\r\n\t\t\t\t\t\t\tname: subKey,\r\n\t\t\t\t\t\t\tvariable: subValue,\r\n\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\trenderer(subValue, element, subKey)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction assignProperties(element, properties) {\r\n\t\t\tfor (var key in properties) {\r\n\t\t\t\tvar value = properties[key]\r\n\t\t\t\tvar styleDefinition\r\n\t\t\t\tvar propertyHandler = element._propertyHandlers[key]\r\n\t\t\t\tif (propertyHandler) {\r\n\t\t\t\t\tif (propertyHandler === true) {\r\n\t\t\t\t\t\t// a standard, known element property\r\n\t\t\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t\t\tnew PropertyRenderer({\r\n\t\t\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\telement[key] = value\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpropertyHandler(element, value, key, properties)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if ((styleDefinition = styleDefinitions[key])) {\r\n\t\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t\tnew StyleRenderer({\r\n\t\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstyleDefinition(element, value, key)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (element[key] == null) {\r\n\t\t\t\t\t// we are working an unknown/unstandard property (or an event listener)\r\n\t\t\t\t\t// undefined or null means we can safely set\r\n\t\t\t\t\t// TODO: we may want to do the event listener check first so we can handle oncustomevent (that needs an addEventListener call to work)\r\n\t\t\t\t\telement[key] = value\r\n\t\t\t\t} else if (typeof value === 'function' && key.slice(0, 2) === 'on') {\r\n\t\t\t\t\t// event listener with one already defined on the prototype\r\n\t\t\t\t\telement.addEventListener(key.slice(2), value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// otherwise bypass/override the native getter/setter\r\n\t\t\t\t\tObject.defineProperty(element, key, {\r\n\t\t\t\t\t\tvalue: value,\r\n\t\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\t\tconfigurable: true,\r\n\t\t\t\t\t\twritable: true\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction buildContent(element, content, key, properties) {\r\n\t\t\tvar each = element.each || properties.each\r\n\t\t\tif (each && content) {\r\n\t\t\t\t// render as list\r\n\t\t\t\tif (each.create) {\r\n\t\t\t\t\teach.defineHasOwn = function () {\r\n\t\t\t\t\t\tvar ItemClass = content.getCollectionOf && content.getCollectionOf() || Item\r\n\t\t\t\t\t\thasOwn(each, ItemClass, function (element) {\r\n\t\t\t\t\t\t\tvar itemVariable = ItemClass.from(element._item)\r\n\t\t\t\t\t\t\treturn itemVariable\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (content.notifies) {\r\n\t\t\t\t\tnew ListRenderer({\r\n\t\t\t\t\t\teach: each,\r\n\t\t\t\t\t\tvariable: content,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar fragment = doc.createDocumentFragment()\r\n\t\t\t\t\tif (each.defineHasOwn) {\r\n\t\t\t\t\t\teach.defineHasOwn()\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontent.forEach(function(item) {\r\n\t\t\t\t\t\tif (each.create) {\r\n\t\t\t\t\t\t\tchildElement = each.create({parent: element, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tchildElement = each(item, element)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfragment.appendChild(childElement)\r\n\t\t\t\t\t})\r\n\t\t\t\t\telement.appendChild(fragment)\r\n\t\t\t\t}\r\n\t\t\t} else if (inputs[element.tagName]) {\r\n\t\t\t\t// render into input\r\n\t\t\t\tbuildInputContent(element, content)\r\n\t\t\t} else if (content instanceof Array) {\r\n\t\t\t\t// treat array as children (potentially of the content node)\r\n\t\t\t\telement = element.contentNode || element\r\n\t\t\t\tlayoutChildren(element, content, element)\r\n\t\t\t} else {\r\n\t\t\t\t// render as string\r\n\t\t\t\telement.appendChild(variableAsContent(element, content))\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction bindChanges(element, variable, key, conversion) {\r\n\t\t\tlang.nextTurn(function() { // wait for next turn in case inputChanges isn't set yet\r\n\t\t\t\tvar inputEvents = element.inputEvents || ['change', 'alkali-change']\r\n\t\t\t\tfor (var i = 0, l = inputEvents.length; i < l; i++) {\r\n\t\t\t\t\telement.addEventListener(inputEvents[i], function (event) {\r\n\t\t\t\t\t\tvar value = element[key]\r\n\t\t\t\t\t\tvar result = variable.put(conversion ? conversion(value, element) : value, new Context(element))\r\n\t\t\t\t\t\tif (result === Variable.deny) {\r\n\t\t\t\t\t\t\tthrow new Error('Variable change denied')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tdoc.addEventListener('click', function(event) {\r\n\t\t\tvar target = event.target\r\n\t\t\tif (target.type === 'radio') {\r\n\t\t\t\tvar radios = doc.querySelectorAll('input[type=radio]')\r\n\t\t\t\tfor (var i = 0, l = radios.length; i < l; i++) {\r\n\t\t\t\t\tvar radio = radios[i]\r\n\t\t\t\t\tif (radio.name === target.name && radio !== target) {\r\n\t\t\t\t\t\tradio.dispatchEvent(new Event('alkali-change', {}))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction conversion(value, element) {\r\n\t\t\tif (element.type == 'number') {\r\n\t\t\t\treturn parseFloat(value)\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t}\r\n\t\r\n\t\tfunction buildInputContent(element, content) {\r\n\t\t\tvar inputType = element.type\r\n\t\t\tvar inputProperty = inputType in {date: 1, datetime: 1, time: 1} ?\r\n\t\t\t\t\t'valueAsDate' : (inputType === 'checkbox' || inputType === 'radio') ?\r\n\t\t\t\t\t\t'checked' : 'value'\r\n\t\r\n\t\t\tif (content && content.notifies) {\r\n\t\t\t\t// a variable, respond to changes\r\n\t\t\t\tnew InputPropertyRenderer({\r\n\t\t\t\t\tvariable: content,\r\n\t\t\t\t\tname: inputProperty,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t\t// and bind the other way as well, updating the variable in response to input changes\r\n\t\t\t\tbindChanges(element, content, inputProperty, conversion)\r\n\t\t\t} else {\r\n\t\t\t\t// primitive\r\n\t\t\t\telement[inputProperty] = content\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar classHandlers = {\r\n\t\t\thasOwn: function(Element, value) {\r\n\t\t\t\thasOwn(Element, value)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction applyToClass(value, Element) {\r\n\t\t\tvar applyOnCreate = Element._applyOnCreate\r\n\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\tif (value instanceof Array || value.notifies) {\r\n\t\t\t\t\tapplyOnCreate.content = value\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfor (var key in value) {\r\n\t\t\t\t\t// TODO: eventually we want to be able to set these as rules statically per element\r\n\t\t\t\t\t/*if (styleDefinitions[key]) {\r\n\t\t\t\t\t\tvar styles = Element.styles || (Element.styles = [])\r\n\t\t\t\t\t\tstyles.push(key)\r\n\t\t\t\t\t\tstyles[key] = descriptor.value\r\n\t\t\t\t\t} else {*/\r\n\t\t\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\t\t\thasOwn(Element, value[key])\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\t\tapplyOnCreate[key] = value[key]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (typeof value === 'function' && !value.for) {\r\n\t\t\t\tthrow new TypeError('Function as argument not supported')\r\n\t\t\t} else {\r\n\t\t\t\tapplyOnCreate.content = value\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction getApplySet(Class) {\r\n\t\t\tif (Class.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\treturn Class._applyOnCreate\r\n\t\t\t}\r\n\t\t\t// this means we didn't extend and evaluate the prototype yet\r\n\t\t\tif (Class.getForClass) {\r\n\t\t\t\t// we are extending an alkali constructor\r\n\t\t\t\t// if this class is inheriting from an alkali constructor, work our way up the chain\r\n\t\t\t\tapplyOnCreate = Class._applyOnCreate = {}\r\n\t\t\t\tvar parentApplySet = getApplySet(getPrototypeOf(Class))\r\n\t\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t\t\t}\r\n\t\t\t\t// we need to check the prototype for event handlers\r\n\t\t\t\tvar prototype = Class.prototype\r\n\t\t\t\tvar propertyHandlers\r\n\t\t\t\tvar keys = Object.getOwnPropertyNames(prototype)\r\n\t\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\tvar key = keys[i]\r\n\t\t\t\t\tif (key.slice(0, 2) === 'on' || (key === 'render' && isGenerator(prototype[key]))) {\r\n\t\t\t\t\t\tapplyOnCreate[key] = prototype[key]\r\n\t\t\t\t\t} else if (key.slice(0, 6) === 'render') {\r\n\t\t\t\t\t\tvar propertyName = key[6].toLowerCase() + key.slice(7)\r\n\t\t\t\t\t\tif (!propertyHandlers) {\r\n\t\t\t\t\t\t\tpropertyHandlers = prototype._propertyHandlers = Object.create(prototype._propertyHandlers)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tpropertyHandlers[propertyName] = true // TODO: is it better to implement this with property handlers?\r\n\t\t\t\t\t\tObject.defineProperty(prototype, propertyName, renderDescriptor(key))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn applyOnCreate\r\n\t\t\t}\r\n\t\t\treturn null\r\n\t\t}\r\n\t\r\n\t\tfunction renderDescriptor(renderMethod) {\r\n\t\t\tvar map = new WeakMap()\r\n\t\t\treturn {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn map.has(this) ? map.get(this) : null\r\n\t\t\t\t},\r\n\t\t\t\tset: function(value) {\r\n\t\t\t\t\tmap.set(this, value)\r\n\t\t\t\t\tthis[renderMethod](value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction makeElementConstructor() {\r\n\t\t\tfunction Element(selector, properties) {\r\n\t\t\t\tif (this instanceof Element){\r\n\t\t\t\t\t// create DOM element\r\n\t\t\t\t\t// Need to detect if we have registered the element and `this` is actually already the correct instance\r\n\t\t\t\t\treturn create.apply(Element.prototype === getPrototypeOf(this) ? Element :// this means it is from this constructor\r\n\t\t\t\t\t\tthis.constructor, // this means it was constructed from a subclass\r\n\t\t\t\t\t\targuments)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// extend to create new class\r\n\t\t\t\t\treturn withProperties.apply(Element, arguments)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tElement.create = create\r\n\t\t\tElement.with = withProperties\r\n\t\t\tElement.for = forTarget\r\n\t\t\tElement.property = propertyForElement\r\n\t\t\tElement.getForClass = getForClass\r\n\t\t\treturn Element\r\n\t\t}\r\n\t\r\n\t\tfunction withProperties(selector, properties) {\r\n\t\t\tvar Element = makeElementConstructor()\r\n\t\t\tElement.superConstructor = this\r\n\t\t\tElement.tagName = this.tagName\r\n\t\t\tif (this.children) {\r\n\t\t\t\t// just copy this property\r\n\t\t\t\tElement.children = this.children\r\n\t\t\t}\r\n\t\t\tElement.prototype = this.prototype\r\n\t\r\n\t\t\tvar applyOnCreate = Element._applyOnCreate = {}\r\n\t\t\tvar parentApplySet = getApplySet(this)\r\n\t\t\t// copy parent properties\r\n\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t\t}\r\n\t\r\n\t\t\tvar i = 0 // for arguments\r\n\t\t\tif (typeof selector === 'string') {\r\n\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className = name\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t}\r\n\t\t\t\ti++ // skip the first argument\r\n\t\t\t}\r\n\t\r\n\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\tapplyToClass(arguments[i], Element)\r\n\t\t\t}\r\n\t\t\treturn Element\r\n\t\t}\r\n\t\tvar currentParent\r\n\t\tfunction create(selector, properties) {\r\n\t\t\t// TODO: make this a symbol\r\n\t\t\tvar applyOnCreate = getApplySet(this)\r\n\t\t\tif (currentParent) {\r\n\t\t\t\tvar parent = currentParent\r\n\t\t\t\tcurrentParent = null\r\n\t\t\t}\r\n\t/*\t\tif (this._initialized != this) {\r\n\t\t\t\tthis._initialized = this\r\n\t\t\t\tthis.initialize && this.initialize()\r\n\t\t\t\tvar styles = this.styles\r\n\t\t\t\tif (styles) {\r\n\t\t\t\t\tvar rule = createCssRule(getUniqueSelector(this))\r\n\t\t\t\t\tfor (var i = 0, l = styles.length; i < l; i++) {\r\n\t\t\t\t\t\tvar key = styles[i]\r\n\t\t\t\t\t\tvar value = styles[key]\r\n\t\t\t\t\t\t// TODO: if it is a contextualized variable, do this on the element\r\n\t\t\t\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\t\t\t\tif (styleDefinition) {\r\n\t\t\t\t\t\t\tstyleDefinition(rule, value, key)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!this.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\t\tapplyOnCreate = getApplySet(this)\r\n\t\t\t\t}\r\n\t\t\t}*/\r\n\t\t\tvar element = doc.createElement(this.tagName)\r\n\t\t\tif (selector && selector.parent) {\r\n\t\t\t\tparent = selector.parent\r\n\t\t\t}\r\n\t\t\tif (parent) {\r\n\t\t\t\tpresumptiveParentMap.set(element, parent)\r\n\t\t\t}\r\n\t\t\tif (!(element instanceof this)) {\r\n\t\t\t\t// ideally we want to avoid this call, as it is expensive, but for classes that\r\n\t\t\t\t// don't register a tag name, we have to make sure the prototype chain is correct\r\n\t\t\t\tsetPrototypeOf(element, this.prototype)\r\n\t\t\t}\r\n\t\t\tif (element.constructor != this) {\r\n\t\t\t\telement.constructor = this // need to do this for hasOwn contextualization to work\r\n\t\t\t}\r\n\t\t\tif (arguments.length > 0) {\r\n\t\t\t\t// copy applyOnCreate when we have arguments\r\n\t\t\t\tvar ElementApplyOnCreate = applyOnCreate\r\n\t\t\t\tapplyOnCreate = {}\r\n\t\t\t\tfor (var key in ElementApplyOnCreate) {\r\n\t\t\t\t\tapplyOnCreate[key] = ElementApplyOnCreate[key]\r\n\t\t\t\t}\r\n\t\t\t\tvar i = 0\r\n\t\t\t\tif (typeof selector == 'string') {\r\n\t\t\t\t\ti++\r\n\t\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tif (element.className) {\r\n\t\t\t\t\t\t\t\t\t\t\telement.className += ' ' + name\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\telement.className = name\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (applyOnCreate.id) {\r\n\t\t\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// just skip right to the element\r\n\t\t\t\t\t\t\t\t\telement.id = name\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (selector && selector._item) {\r\n\t\t\t\t\t// this is kind of hack, to get the Item available before the properties, eventually we may want to\r\n\t\t\t\t\t// order static properties before variable binding applications, but for now.\r\n\t\t\t\t\telement._item = selector._item\r\n\t\t\t\t}\r\n\t\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\t\tvar argument = arguments[i]\r\n\t\t\t\t\tif (argument && typeof argument === 'object') {\r\n\t\t\t\t\t\tif (argument instanceof Array || argument.notifies) {\r\n\t\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tfor (var key in argument) {\r\n\t\t\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\t\t\tapplyOnCreate[key] = argument[key]\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (typeof argument === 'function' && argument.for) {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument.for(element)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (element.created) {\r\n\t\t\t\tapplyOnCreate = element.created(applyOnCreate) || applyOnCreate\r\n\t\t\t} else if (applyOnCreate.created) {\r\n\t\t\t\tapplyOnCreate = applyOnCreate.created.call(element, applyOnCreate) || applyOnCreate\r\n\t\t\t}\r\n\t\t\t// TODO: inline this for better performance, possibly\r\n\t\t\tassignProperties(element, applyOnCreate)\r\n\t\t\tif (this.children) {\r\n\t\t\t\tlayoutChildren(element, this.children, element)\r\n\t\t\t}\r\n\t\t\t// always do this last, so it can be properly inserted inside the children\r\n\t\t\tif (applyOnCreate.content) {\r\n\t\t\t\tbuildContent(element, applyOnCreate.content, 'content', applyOnCreate)\r\n\t\t\t}\r\n\t\t\telement.ready && element.ready(applyOnCreate)\r\n\t\t\treturn element\r\n\t\t}\r\n\t\r\n\t\tvar slice = [].slice\r\n\t\tfunction append(parent){\r\n\t\t\treturn this.nodeType ?\r\n\t\t\t\tlayoutChildren(this, arguments, this) : // called as a method\r\n\t\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent) // called as a function\r\n\t\t}\r\n\t\r\n\t\tfunction prepend(parent){\r\n\t\t\treturn this.nodeType ?\r\n\t\t\t\tlayoutChildren(this, arguments, this, true) : // called as a method\r\n\t\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent, true) // called as a function\r\n\t\t}\r\n\t\r\n\t\tfunction registerTag(tagName) {\r\n\t\t\tthis.tagName = tagName\r\n\t\t\tif (doc.registerElement && this.prototype.constructor === this) {\r\n\t\t\t\tdoc.registerElement(tagName, this)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar Element = withProperties.call(typeof HTMLElement !== 'undefined' ? HTMLElement : function() {})\r\n\t\r\n\t\tElement.registerTag = registerTag\r\n\t\tElement.assign = assignProperties\r\n\t\r\n\t\tElement.within = function(element){\r\n\t\t\t// find closest child\r\n\t\t}\r\n\t\r\n\t\tgenerate([\r\n\t\t\t'Video',\r\n\t\t\t'Source',\r\n\t\t\t'Media',\r\n\t\t\t'Audio',\r\n\t\t\t'UL',\r\n\t\t\t'Track',\r\n\t\t\t'Title',\r\n\t\t\t'TextArea',\r\n\t\t\t'Template',\r\n\t\t\t'TBody',\r\n\t\t\t'THead',\r\n\t\t\t'TFoot',\r\n\t\t\t'TR',\r\n\t\t\t'Table',\r\n\t\t\t'Col',\r\n\t\t\t'ColGroup',\r\n\t\t\t'TH',\r\n\t\t\t'TD',\r\n\t\t\t'Caption',\r\n\t\t\t'Style',\r\n\t\t\t'Span',\r\n\t\t\t'Shadow',\r\n\t\t\t'Select',\r\n\t\t\t'Script',\r\n\t\t\t'Quote',\r\n\t\t\t'Progress',\r\n\t\t\t'Pre',\r\n\t\t\t'Picture',\r\n\t\t\t'Param',\r\n\t\t\t'P',\r\n\t\t\t'Output',\r\n\t\t\t'Option',\r\n\t\t\t'Optgroup',\r\n\t\t\t'Object',\r\n\t\t\t'OL',\r\n\t\t\t'Ins',\r\n\t\t\t'Del',\r\n\t\t\t'Meter',\r\n\t\t\t'Meta',\r\n\t\t\t'Menu',\r\n\t\t\t'Map',\r\n\t\t\t'Link',\r\n\t\t\t'Legend',\r\n\t\t\t'Label',\r\n\t\t\t'LI',\r\n\t\t\t'KeyGen',\r\n\t\t\t'Input',\r\n\t\t\t'Image',\r\n\t\t\t'IFrame',\r\n\t\t\t'H1',\r\n\t\t\t'H2',\r\n\t\t\t'H3',\r\n\t\t\t'H4',\r\n\t\t\t'H5',\r\n\t\t\t'H6',\r\n\t\t\t'Hr',\r\n\t\t\t'FrameSet',\r\n\t\t\t'Frame',\r\n\t\t\t'Form',\r\n\t\t\t'Font',\r\n\t\t\t'Embed',\r\n\t\t\t'Article',\r\n\t\t\t'Aside',\r\n\t\t\t'Footer',\r\n\t\t\t'Figure',\r\n\t\t\t'FigCaption',\r\n\t\t\t'Header',\r\n\t\t\t'Main',\r\n\t\t\t'Mark',\r\n\t\t\t'MenuItem',\r\n\t\t\t'Nav',\r\n\t\t\t'Section',\r\n\t\t\t'Summary',\r\n\t\t\t'WBr',\r\n\t\t\t'Div',\r\n\t\t\t'Dialog',\r\n\t\t\t'Details',\r\n\t\t\t'DataList',\r\n\t\t\t'DL',\r\n\t\t\t'Canvas',\r\n\t\t\t'Button',\r\n\t\t\t'Base',\r\n\t\t\t'Br',\r\n\t\t\t'Area',\r\n\t\t\t'A'\r\n\t\t])\r\n\t\tgenerateInputs([\r\n\t\t\t'Checkbox',\r\n\t\t\t'Password',\r\n\t\t\t'Submit',\r\n\t\t\t'Radio',\r\n\t\t\t'Color',\r\n\t\t\t'Date',\r\n\t\t\t'DateTime',\r\n\t\t\t'Email',\r\n\t\t\t'Month',\r\n\t\t\t'Number',\r\n\t\t\t'Range',\r\n\t\t\t'Search',\r\n\t\t\t'Tel',\r\n\t\t\t'Time',\r\n\t\t\t'Url',\r\n\t\t\t'Week'])\r\n\t\r\n\t\tvar tags = {}\r\n\t\tfunction getConstructor(tagName) {\r\n\t\t\ttagName = tagName.toLowerCase()\r\n\t\t\treturn tags[tagName] ||\r\n\t\t\t\t(tags[tagName] =\r\n\t\t\t\t\tsetupElement(withProperties.call(doc.createElement(tagName).constructor), tagName))\r\n\t\t}\r\n\t\r\n\t\tfunction setupElement(Element, tagName) {\r\n\t\t\tvar props = elementPropertyHandlers[tagName]\r\n\t\t\tif (props && !props.assigned) {\r\n\t\t\t\tvar handlers = Element.prototype._propertyHandlers = Object.create(propertyHandlers)\r\n\t\t\t\tfor (var i = 0, l = props.length; i < l; i++) {\r\n\t\t\t\t\thandlers[props[i]] = true\r\n\t\t\t\t}\r\n\t\t\t\tif (props.value) {\r\n\t\t\t\t\tfor (var i in props) {\r\n\t\t\t\t\t\tif (!(i > -1)) { // assign any string properties if necessary\r\n\t\t\t\t\t\t\thandlers[i] = props[i]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tprops.assigned = true\r\n\t\t\t}\r\n\t\t\tElement.tagName = tagName\r\n\t\t\treturn Element\r\n\t\t}\r\n\t\tfunction generate(elements) {\r\n\t\t\telements.forEach(function(elementName) {\r\n\t\t\t\tvar ElementClass\r\n\t\t\t\tObject.defineProperty(Element, elementName, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn ElementClass || (ElementClass = getConstructor(elementName))\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t}\r\n\t\tfunction generateInputs(elements) {\r\n\t\t\telements.forEach(function(inputType) {\r\n\t\t\t\tvar ElementClass\r\n\t\t\t\tObject.defineProperty(Element, inputType, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t// TODO: make all inputs extend from input generated from generate\r\n\t\t\t\t\t\treturn ElementClass || (ElementClass = setupElement(withProperties.call(HTMLInputElement, {\r\n\t\t\t\t\t\t\ttype: inputType.toLowerCase()\r\n\t\t\t\t\t\t}), 'input'))\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\t// alias all the inputs with an Input suffix\r\n\t\t\t\tObject.defineProperty(Element, inputType + 'Input', {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn this[inputType]\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tvar aliases = {\r\n\t\t\tAnchor: 'A',\r\n\t\t\tParagraph: 'P',\r\n\t\t\tTextarea: 'TextArea',\r\n\t\t\tDList: 'DL',\r\n\t\t\tUList: 'UL',\r\n\t\t\tOList: 'OL',\r\n\t\t\tListItem: 'LI',\r\n\t\t\tText: 'Input',\r\n\t\t\tTextInput: 'Input',\r\n\t\t\tTableRow: 'TR',\r\n\t\t\tTableCell: 'TD',\r\n\t\t\tTableHeaderCell: 'TH',\r\n\t\t\tTableHeader: 'THead',\r\n\t\t\tTableBody: 'TBody'\r\n\t\t}\r\n\t\tfor (var alias in aliases) {\r\n\t\t\t(function(alias, to) {\r\n\t\t\t\tObject.defineProperty(Element, alias, {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn this[to]\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t})(alias, aliases[alias])\r\n\t\t}\r\n\t\r\n\t\tElement.append = append\r\n\t\tElement.prepend = prepend\r\n\t\tElement.refresh = Renderer.refresh\r\n\t\tElement.options = {\r\n\t\t\tmoveLiveElementsEnabled: true,\r\n\t\t}\r\n\t\tElement.content = function(element){\r\n\t\t\t// container marker\r\n\t\t\treturn {\r\n\t\t\t\tisContentNode: true,\r\n\t\t\t\tcreate: element.create.bind(element)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tElement.ElementClass = function() {}\r\n\t\tif (typeof Symbol !== 'undefined') {\r\n\t\t\t// make instanceof work for Element\r\n\t\t\tObject.defineProperty(Element.ElementClass, Symbol.hasInstance, { value: function(target) {\r\n\t\t\t\treturn target && (target.create && target.with)\r\n\t\t\t}})\r\n\t\t}\r\n\t\r\n\t\t// TODO: unify this in lang\r\n\t\tElement.extend = function(Class, properties) {\r\n\t\t\tfunction ExtendedElement() {\r\n\t\t\t\treturn Class.apply(this, arguments)\r\n\t\t\t}\r\n\t\t\tsetPrototypeOf(ExtendedElement, Class)\r\n\t\t\tvar prototype = ExtendedElement.prototype = Object.create(Class.prototype)\r\n\t\t\tprototype.constructor = ExtendedElement\r\n\t\t\tObject.getOwnPropertyNames(properties).forEach(function(key) {\r\n\t\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\tclassHandlers[key](ExtendedElement, descriptor.value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\treturn ExtendedElement\r\n\t\t}\r\n\t\r\n\t\tfunction forTarget(target) {\r\n\t\t\treturn target.constructor.getForClass(target, this)\r\n\t\t}\r\n\t\r\n\t\tfunction hasOwn(From, Target, createInstance) {\r\n\t\t\tif (typeof Target === 'object') {\r\n\t\t\t\t// we were given an actual instance, use that\r\n\t\t\t\tvar elementMap = From.ownedClasses || (From.ownedClasses = new WeakMap())\r\n\t\t\t\tvar instanceMap = {get: function () {\r\n\t\t\t\t\treturn Target\r\n\t\t\t\t}}\r\n\t\t\t\telementMap.set(Target.constructor, instanceMap)\r\n\t\t\t\treturn hasOwn(From, Target.Class, Target.createInstance)\r\n\t\t\t}\r\n\t\t\tif (Target instanceof Array) {\r\n\t\t\t\treturn Target.forEach(function(Target) {\r\n\t\t\t\t\thasOwn(From, Target)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tvar instanceMap = new WeakMap()\r\n\t\t\tinstanceMap.createInstance = createInstance\r\n\t\t\tvar elementMap = From.ownedClasses || (From.ownedClasses = new WeakMap())\r\n\t\t\t// TODO: Go up through prototype chain of Target and set each one\r\n\t\t\telementMap.set(Target, instanceMap)\r\n\t\t\treturn From\r\n\t\t}\r\n\t\r\n\t\tfunction getForClass(element, Target) {\r\n\t\t\tvar createInstance\r\n\t\t\twhile (element && !(createInstance = element.constructor.ownedClasses && element.constructor.ownedClasses.get(Target))) {\r\n\t\t\t\telement = element.parentNode || presumptiveParentMap.get(element)\r\n\t\t\t}\r\n\t\t\tif (createInstance) {\r\n\t\t\t\tvar ownedInstances = element.ownedInstances || (element.ownedInstances = new WeakMap())\r\n\t\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\t\tif (instance === undefined) {\r\n\t\t\t\t\townedInstances.set(Target, instance = createInstance(element))\r\n\t\t\t\t\tinstance.subject = element\r\n\t\t\t\t}\r\n\t\t\t\treturn instance\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction propertyForElement(key) {\r\n\t\t\t// we just need to establish one Variable class for each element, so we cache it\r\n\t\t\tThisElementVariable = this._Variable\r\n\t\t\tif (!ThisElementVariable) {\r\n\t\t\t\t// need our own branded variable class for this element class\r\n\t\t\t\tThisElementVariable = this._Variable = Variable()\r\n\t\r\n\t\t\t\thasOwn(this, ThisElementVariable, function(element) {\r\n\t\t\t\t\t// TODO: we might want to do this in init instead\r\n\t\t\t\t\tvar variableProperties = {}\r\n\t\t\t\t\tfor (var i = 0; i < element.alkaliRenderers.length; i++){\r\n\t\t\t\t\t\tvar renderer = element.alkaliRenderers[i]\r\n\t\t\t\t\t\tif (renderer.name) {\r\n\t\t\t\t\t\t\tvariableProperties[renderer.name] = {value: renderer.variable}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar elementOverlay = Object.create(element, variableProperties)\r\n\t\t\t\t\tvar instance = new ThisElementVariable(elementOverlay)\r\n\t\t\t\t\t// we are not observing, because you can't delegate getters and setters in safari\r\n\t\t\t\t\t// instance.observeObject()\r\n\t\t\t\t\treturn instance\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\t// now actually get the property class\r\n\t\t\treturn ThisElementVariable.property(key)\r\n\t\t}\r\n\t\r\n\t\tvar Item = Element.Item = Variable.Item\r\n\t\r\n\t\tfunction enterRenderer(Renderer, options/*, target*/) {\r\n\t\t\t// this will be used for optimized class-level variables\r\n\t\t\t/*if (target.started) { // TODO: Might want to pass in started as a parameter\r\n\t\t\t\t// this means that the renderer has already been created, so we just need to add this instance\r\n\t\t\t\tRenderer.prototype.renderUpdate.call(options, element)\r\n\t\t\t} else {*/\r\n\t\t\tnew Renderer(options)\r\n\t\t\t//}\r\n\t\t}\r\n\t\r\n\t\tfunction cleanup(target) {\r\n\t\t\tvar renderers = target.alkaliRenderers\r\n\t\t\tif (renderers) {\r\n\t\t\t\tfor (var i = 0, l = renderers.length; i < l; i++) {\r\n\t\t\t\t\trenderers[i].stop()\r\n\t\t\t\t}\r\n\t\t\t\ttarget.needsRestart = true\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction restart(target) {\r\n\t\t\tvar renderers = target.alkaliRenderers\r\n\t\t\tif (renderers) {\r\n\t\t\t\tfor (var i = 0, l = renderers.length; i < l; i++) {\r\n\t//\t\t\t\tupdaters[i].start()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// setup the mutation observer so we can be notified of attachments and removals\r\n\t\tfunction elementAttached(element) {\r\n\t\t\tvar Class = element.constructor\r\n\t\t\tif (Class.create) {\r\n\t/*\t\t\tif (Class.attachedInstances) {\r\n\t\t\t\t\tClass.attachedInstances.push(element)\r\n\t\t\t\t\tif (Class.attachedInstances.length === 1 && Class.needsRestart) {\r\n\t\t\t\t\t\trestart(Class)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tClass.attachedInstances = [element]\r\n\t\t\t\t}*/\r\n\t\t\t\tif (element.attached) {\r\n\t\t\t\t\telement.attached()\r\n\t\t\t\t}\r\n\t\t\t\tif (element.needsRestart) {\r\n\t\t\t\t\trestart(element)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction elementDetached(element) {\r\n\t\t\t/*var attachedInstances = element.constructor.attachedInstances\r\n\t\t\tif (attachedInstances) {\r\n\t\t\t\tvar index = attachedInstances.indexOf(element)\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tattachedInstances.splice(index, 1)\r\n\t\t\t\t\tif (attachedInstances.length === 0) {\r\n\t\t\t\t\t\tcleanup(Class)\r\n\t\t\t\t\t}\r\n\t\t\t\t}*/\r\n\t\t\t\tif (element.detached) {\r\n\t\t\t\t\telement.detached()\r\n\t\t\t\t}\r\n\t\t\t\tcleanup(element)\r\n\t\t\t//}\r\n\t\t}\r\n\t\tif (typeof MutationObserver === 'function') {\r\n\t\t\tvar lifeStates = [{\r\n\t\t\t\tname: 'detached',\r\n\t\t\t\tnodes: 'removedNodes',\r\n\t\t\t\taction: elementDetached\r\n\t\t\t}, {\r\n\t\t\t\tname: 'attached',\r\n\t\t\t\tnodes: 'addedNodes',\r\n\t\t\t\taction: elementAttached\r\n\t\t\t}]\r\n\t\t\tfunction firstVisit(node, state) {\r\n\t\t\t\tif (state.name === 'attached') {\r\n\t\t\t\t\tif (node.__alkaliAttached__) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnode.__alkaliAttached__ = true\r\n\t\t\t\t\t\tstate.action(node)\r\n\t\t\t\t\t\treturn true\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (node.__alkaliAttached__) {\r\n\t\t\t\t\tif (doc.body.contains(node)) {\r\n\t\t\t\t\t\t// detached event, but it is actually still attached (will get attached in a later mutation record)\r\n\t\t\t\t\t\t// so don't get through the detached/attached lifecycle\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnode.__alkaliAttached__ = false\r\n\t\t\t\t\tstate.action(node)\r\n\t\t\t\t}\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\tvar observer = new MutationObserver(function(mutations) {\r\n\t\t\t\tfor (var i = 0, il = mutations.length; i < il; i++) {\r\n\t\t\t\t\tvar mutation = mutations[i]\r\n\t\t\t\t\t// invoke action on element if we haven't already\r\n\t\t\t\t\tactionIteration:\r\n\t\t\t\t\tfor (var j = 0, jl = lifeStates.length; j < jl; j++) { // two steps, removed nodes and added nodes\r\n\t\t\t\t\t\tvar state = lifeStates[j]\r\n\t\t\t\t\t\tvar nodes = mutation[state.nodes]\r\n\t\t\t\t\t\t// iterate over node list\r\n\t\t\t\t\t\tnodeIteration:\r\n\t\t\t\t\t\tfor (var k = 0, kl = nodes.length; k < kl; k++) {\r\n\t\t\t\t\t\t\tvar baseNode = nodes[k]\r\n\t\t\t\t\t\t\tif (firstVisit(baseNode, state)) {\r\n\t\t\t\t\t\t\t\t// start traversal with child, if it exists\r\n\t\t\t\t\t\t\t\tvar currentNode = baseNode.firstChild\r\n\t\t\t\t\t\t\t\tif (currentNode) {\r\n\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\tvar nextNode\r\n\t\t\t\t\t\t\t\t\t\tif (currentNode.nodeType === 1 && firstVisit(currentNode, state)) {\r\n\t\t\t\t\t\t\t\t\t\t\t// depth-first search\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.firstChild\r\n\t\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t// come back out to parents\r\n\t\t\t\t\t\t\t\t\t\t\t// TODO: try keeping a stack to make this faster\r\n\t\t\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode = currentNode.parentNode\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (currentNode === baseNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue nodeIteration\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t} while (!(nextNode = currentNode.nextSibling))\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tcurrentNode = nextNode\r\n\t\t\t\t\t\t\t\t\t} while (true)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// if (options.moveLiveElementsEnabled) {\r\n\t\t\t\t\t\t\t// TODO: any options that we can really do here?\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tobserver.observe(doc.body || doc, {\r\n\t\t\t\tchildList: true,\r\n\t\t\t\tsubtree: true\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tlang.copy(Variable.Context.prototype, {\r\n\t\t\tspecify: function(Variable) {\r\n\t\t\t\tvar element = this.subject\r\n\t\t\t\tvar distinctive = true\r\n\t\t\t\t;(this.generics || (this.generics = [])).push(Variable)\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif (this.distinctSubject === element) {\r\n\t\t\t\t\t\tdistinctive = false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar subjectMap = element.constructor.ownedClasses\r\n\t\t\t\t\tif (subjectMap) {\r\n\t\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\t\tif (instanceMap) {\r\n\t\t\t\t\t\t\tif (distinctive) {\r\n\t\t\t\t\t\t\t\tthis.distinctSubject = element\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tspecifiedInstance = instanceMap.get(element)\r\n\t\t\t\t\t\t\tif (!specifiedInstance) {\r\n\t\t\t\t\t\t\t\tinstanceMap.set(element, specifiedInstance = instanceMap.createInstance ?\r\n\t\t\t\t\t\t\t\t\tinstanceMap.createInstance(element) : new Variable())\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn specifiedInstance\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t\t// else if no specific context is found, return default instance\r\n\t\t\t\treturn Variable.defaultInstance\r\n\t\t\t},\r\n\t\r\n\t\t\tgetContextualized: function(variable) {\r\n\t\t\t\t// returns a variable that has already been contextualized\r\n\t\t\t\tvar element = this.subject\r\n\t\t\t\tif (!element) {\r\n\t\t\t\t\t// no element, just use the default variable\r\n\t\t\t\t\treturn variable\r\n\t\t\t\t}\r\n\t\t\t\tif (variable._contextMap) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tvar instance = variable._contextMap.get(element)\r\n\t\t\t\t\t\tif (instance && instance.context.matches(element)) {\r\n\t\t\t\t\t\t\treturn instance\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t\t}\r\n\t\t\t\tif (variable.context && variable.context.matches(this.subject)) {\r\n\t\t\t\t\t// check if the default variable is allowed\r\n\t\t\t\t\treturn variable\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tmerge: function(childContext) {\r\n\t\t\t\tif (!this.distinctSubject || this.distinctSubject.contains(childContext.distinctSubject)) {\r\n\t\t\t\t\tthis.distinctSubject = childContext.distinctSubject\r\n\t\t\t\t}\r\n\t\t\t\t[].push.apply(this.generics || (this.generics = []), childContext.generics)\r\n\t\t\t},\r\n\t\t\tgetDistinctElement: function(Variable, element) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar subjectMap = element.constructor.ownedClasses\r\n\t\t\t\t\tif (subjectMap) {\r\n\t\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\t\tif (instanceMap && instanceMap.has(element)) {\r\n\t\t\t\t\t\t\treturn element\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t},\r\n\t\t\tmatches: function(element) {\r\n\t\t\t\tvar generics = this.generics\r\n\t\t\t\tif (generics) {\r\n\t\t\t\t\tfor (var i = 0, l = generics.length; i < l; i++) {\r\n\t\t\t\t\t\tif (this.getDistinctElement(generics[i], element) !== this.distinctSubject) {\r\n\t\t\t\t\t\t\treturn false\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\r\n\t\r\n\t\treturn Element\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function (lang) {\r\n\t\tvar deny = {}\r\n\t\tvar noChange = {}\r\n\t\tvar WeakMap = lang.WeakMap\r\n\t\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\tvar isGenerator = lang.isGenerator\r\n\t\t// update types\r\n\t\tvar RequestChange = 3\r\n\t\tvar RequestSet = 4\r\n\t\r\n\t\tvar ToChild = Object.freeze({\r\n\t\t\ttype: 'refresh'\r\n\t\t})\r\n\t\tvar nextId = 1\r\n\t\tvar propertyListenersMap = new WeakMap(null, 'propertyListenersMap')\r\n\t\r\n\t\tvar CacheEntry = lang.compose(WeakMap, function() {\r\n\t\t},{\r\n\t\t\t_propertyChange: function(propertyName) {\r\n\t\t\t\tthis.variable._propertyChange(propertyName, contextFromCache(this))\r\n\t\t\t}\r\n\t\t})\r\n\t\tvar listenerId = 1\r\n\t\r\n\t\tfunction when(value, callback) {\r\n\t\t\tif (value && value.then) {\r\n\t\t\t\treturn value.then(callback)\r\n\t\t\t}\r\n\t\t\treturn callback(value)\r\n\t\t}\r\n\t\r\n\t\tfunction Context(subject){\r\n\t\t\tthis.subject = subject\r\n\t\t\tthis.inputs = []\r\n\t\t}\r\n\t\tContext.prototype = {\r\n\t\t\tconstructor: Context,\r\n\t\t\tnewContext: function(variable) {\r\n\t\t\t\treturn new Context(this.subject)\r\n\t\t\t},\r\n\t\t\tcontextualize: function(variable, parentContext) {\r\n\t\t\t\t// resolve the contextualization of a variable, and updates this context to be aware of what distinctive aspect of the context has\r\n\t\t\t\t// been used for resolution\r\n\t\t\t\tvar contextualized\r\n\t\t\t\tif (this.distinctSubject) {\r\n\t\t\t\t\tvar contextMap = variable._contextMap || (variable._contextMap = new WeakMap())\r\n\t\t\t\t\tcontextualized = contextMap.get(this.distinctSubject)\r\n\t\t\t\t\tif (!contextualized) {\r\n\t\t\t\t\t\tcontextMap.set(this.distinctSubject, contextualized = Object.create(variable))\r\n\t\t\t\t\t\tcontextualized.listeners = false\r\n\t\t\t\t\t\tcontextualized.context = this\r\n\t\t\t\t\t\tvar inputs = this.inputs\r\n\t\t\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\t\t\tcontextualized[inputs[i]] = inputs[++i]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.contextualized = contextualized\r\n\t\t\t\t\t// do the merge\r\n\t\t\t\t\tif (parentContext) {\r\n\t\t\t\t\t\tparentContext.merge(this)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontextualized = variable\r\n\t\t\t\t}\r\n\t\t\t\t//if (this.contextualized && this.contextualized !== contextualized) {\r\n\t\t\t\t\t// TOOD: if it has previously been contextualized to a different context (can happen in a promise/async situation), stop previous notifiers and start new ones\r\n\t\t\t\t//}\r\n\t\t\t\tparentContext.addInput(contextualized)\r\n\t\t\t\treturn contextualized\r\n\t\t\t},\r\n\t\t\tmerge: function(childContext) {\r\n\t\t\t\tif (!this.distinctSubject) {\r\n\t\t\t\t\tthis.distinctSubject = childContext.distinctSubject\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tspecify: function(Variable) {\r\n\t\t\t\t// specify a particular instance of a generic variable\r\n\t\t\t\tvar subject = this.subject\r\n\t\t\t\tvar subjectMap = subject.constructor.ownedClasses\r\n\t\t\t\tvar specifiedInstance\r\n\t\t\t\tif (subjectMap) {\r\n\t\t\t\t\tif (!this.distinctSubject) {\r\n\t\t        this.distinctSubject = subject\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\tif (instanceMap) {\r\n\t\t\t\t\t\tspecifiedInstance = instanceMap.get(subject)\r\n\t\t\t\t\t\tif (!specifiedInstance) {\r\n\t\t\t\t\t\t\tinstanceMap.set(subject, specifiedInstance = instanceMap.createInstance ? instanceMap.createInstance(subject) : new Variable())\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn specifiedInstance\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// else if no specific context is found, return default instance\r\n\t\t\t\treturn Variable.defaultInstance\r\n\t\t\t},\r\n\t\t\tgetContextualized: function(variable) {\r\n\t\r\n\t\t\t\t// returns a variable that has already been contextualized\r\n\t\t\t\tvar instance = variable._contextMap && this.subject && variable._contextMap.get(this.subject)\r\n\t\t\t\tif (instance && instance.context && instance.context.matches(this)) {\r\n\t\t\t\t\treturn instance\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\taddInput: function(inputVariable) {\r\n\t\t\t\tthis.inputs.push(this.nextProperty, inputVariable)\r\n\t\t\t},\r\n\t\t\tmatches: function(context) {\r\n\t\t\t\t// does another context match the resolution of this one?\r\n\t\t\t\treturn context.subject === this.subject\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction NotifyingContext(listener, subject){\r\n\t\t\tthis.subject = subject\r\n\t\t\tthis.listener = listener\r\n\t\t}\r\n\t\tNotifyingContext.prototype = Object.create(Context.prototype)\r\n\t\tNotifyingContext.prototype.constructor = NotifyingContext\r\n\t\tNotifyingContext.prototype.addInput = function(contextualized) {\r\n\t\t\tcontextualized.notifies(this.listener)\r\n\t\t}\r\n\t\r\n\t\tfunction whenAll(inputs, callback){\r\n\t\t\tvar promiseInvolved\r\n\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\tif (inputs[i] && inputs[i].then) {\r\n\t\t\t\t\tpromiseInvolved = true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (promiseInvolved) {\r\n\t\t\t\treturn lang.whenAll(inputs, callback)\r\n\t\t\t}\r\n\t\t\treturn callback(inputs)\r\n\t\t}\r\n\t\r\n\t\tfunction registerListener(value, listener) {\r\n\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\tvar id = listener.listenerId || (listener.listenerId = ('-' + listenerId++))\r\n\t\t\tif (listeners) {\r\n\t\t\t\tif (listeners[id] === undefined) {\r\n\t\t\t\t\tlisteners[id] = listeners.push(listener) - 1\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tpropertyListenersMap.set(value, listeners = [listener])\r\n\t\t\t\tlisteners[id] = 0\r\n\t\t\t\tif (Variable.autoObserveObjects) {\r\n\t\t\t\t\tobserve(value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlistener.listeningToObject = value\r\n\t\t}\r\n\t\tfunction deregisterListener(listener) {\r\n\t\t\tif (listener.listeningToObject) {\r\n\t\t\t\tvar value = listener.listeningToObject\r\n\t\t\t\tlistener.listeningToObject = null\r\n\t\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tvar index = listeners[listener.listenerId]\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tlisteners.splice(index, 1)\r\n\t\t\t\t\t\tdelete listeners[listener.listenerId]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction RefreshEvent() {\r\n\t\t\tthis.visited = new Set()\r\n\t\t}\r\n\t\tRefreshEvent.prototype.type = 'refresh'\r\n\t\r\n\t\tfunction PropertyChangeEvent(key, childEvent, parent) {\r\n\t\t\tthis.key = key\r\n\t\t\tthis.childEvent = childEvent\r\n\t\t\tthis.parent = parent\r\n\t\t\tthis.visited = childEvent.visited\r\n\t\t}\r\n\t\tPropertyChangeEvent.prototype.type = 'update'\r\n\t\r\n\t\tfunction AddEvent(args) {\r\n\t\t\tthis.visited = new Set()\r\n\t\t\tfor (var key in args) {\r\n\t\t\t\tthis[key] = args[key]\r\n\t\t\t}\r\n\t\t}\r\n\t\tAddEvent.prototype.type = 'add'\r\n\t\tfunction DeleteEvent(args) {\r\n\t\t\tthis.visited = new Set()\r\n\t\t\tfor (var key in args) {\r\n\t\t\t\tthis[key] = args[key]\r\n\t\t\t}\r\n\t\t}\r\n\t\tDeleteEvent.prototype.type = 'delete'\r\n\t\r\n\t\tfunction forPropertyNotifyingValues(properties, callback) {\r\n\t\t\tfor (var key in properties) {\r\n\t\t\t\tvar property = properties[key]\r\n\t\t\t\tif (property.returnedVariable) {\r\n\t\t\t\t\tcallback(property.returnedVariable)\r\n\t\t\t\t}\r\n\t\t\t\tif (property.hasChildNotifiers) {\r\n\t\t\t\t\tvar subProperties = property._properties\r\n\t\t\t\t\tif (subProperties) {\r\n\t\t\t\t\t\tforPropertyNotifyingValues(subProperties, callback)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction Variable(value) {\r\n\t\t\tif (this instanceof Variable) {\r\n\t\t\t\t// new call, may eventually use new.target\r\n\t\t\t\tif (value === undefined) {\r\n\t\t\t\t\tif (this.default !== undefined) {\r\n\t\t\t\t\t\tthis.value = this.default\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.value = value\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn Variable.extend(value)\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar VariablePrototype = Variable.prototype = {\r\n\t\t\t// for debugging use\r\n\t\t\tget _currentValue() {\r\n\t\t\t\treturn this.valueOf()\r\n\t\t\t},\r\n\t\t\tset _currentValue(value) {\r\n\t\t\t\tthis.put(value)\r\n\t\t\t},\r\n\t\t\tconstructor: Variable,\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\tvar valueContext\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tvalueContext = context.newContext()\r\n\t\t\t\t\t\tvalueContext.nextProperty = 'parent'\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar key = this.key\r\n\t\t\t\t\tvar property = this\r\n\t\t\t\t\tvar object = this.parent.valueOf(valueContext)\r\n\t\t\t\t\tvar gotValueAndListen = function(object) {\r\n\t\t\t\t\t\tvar value = property.gotValue(object == null ? undefined : typeof object.get === 'function' ? object.get(key) : object[key], context, valueContext)\r\n\t\t\t\t\t\tif (property.listeners) {\r\n\t\t\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\t\t\tif (listeners && listeners.observer && listeners.observer.addKey) {\r\n\t\t\t\t\t\t\t\tlisteners.observer.addKey(key)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn value\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (object && object.then) {\r\n\t\t\t\t\t\t// call it initially so the dependencies can be registered\r\n\t\t\t\t\t\tthis.gotValue(null, context, valueContext)\r\n\t\t\t\t\t\treturn when(object, gotValueAndListen)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn gotValueAndListen(object)\r\n\t\t\t\t}\r\n\t\t\t\treturn this.gotValue(this.getValue ?\r\n\t\t\t\t\tthis.getValue(context && (valueContext = context.newContext())) :\r\n\t\t\t\t\tthis.value, context, valueContext)\r\n\t\t\t},\r\n\t\t\tgotValue: function(value, parentContext, context) {\r\n\t\t\t\tvar previousNotifyingValue = this.returnedVariable\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tif (previousNotifyingValue) {\r\n\t\t\t\t\tif (value === previousNotifyingValue) {\r\n\t\t\t\t\t\t// nothing changed, immediately return valueOf (or ownObject if we have it)\r\n\t\t\t\t\t\tif (variable.ownObject) {\r\n\t\t\t\t\t\t\treturn variable.ownObject\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (parentContext) {\r\n\t\t\t\t\t\t\tif (!context) {\r\n\t\t\t\t\t\t\t\tcontext = parentContext.newContext()\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcontext.contextualize(this, parentContext)\r\n\t\t\t\t\t\t\tcontext.nextProperty = 'returnedVariable'\r\n\t\t\t\t\t\t\treturn value.valueOf(context)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn value.valueOf()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if there was a another value that we were dependent on before, stop listening to it\r\n\t\t\t\t\t// TODO: we may want to consider doing cleanup after the next rendering turn\r\n\t\t\t\t\tif (variable.listeners) {\r\n\t\t\t\t\t\tpreviousNotifyingValue.stopNotifies(variable)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvariable.returnedVariable = null\r\n\t\t\t\t}\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\tvariable.returnedVariable = value\r\n\t\t\t\t\tif (variable.listeners) {\r\n\t\t\t\t\t\tvalue.notifies(variable)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/*var parent = variable\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tif (parent.listeners) {\r\n\t\t\t\t\t\t\t// the value is another variable, start receiving notifications, if we, or any parent is live\r\n\t\t\t\t\t\t\tvariable.returnedVariable.notifies(variable)\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tparent.hasNotifyingChild = true\r\n\t\t\t\t\t} while((parent = parent.parent))*/\r\n\t\t\t\t\tcontext = context || parentContext && (context = parentContext.newContext())\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tcontext.nextProperty = 'returnedVariable'\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvalue = value.valueOf(context)\r\n\t\t\t\t\tif (variable.ownObject) {\r\n\t\t\t\t\t\tif (getPrototypeOf(variable.ownObject) !== value) {\r\n\t\t\t\t\t\t\tsetPrototypeOf(variable.ownObject, value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalue = variable.ownObject\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (value === undefined) {\r\n\t\t\t\t\tvalue = variable.default\r\n\t\t\t\t}\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.contextualize(this, parentContext)\r\n\t\t\t\t}\r\n\t\t\t\tif (parentContext) {\r\n\t\r\n\t\t\t\t\t/*if (!contextualized.listeners) {\r\n\t\t\t\t\t\t// mark it as initialized, since we have already recursively dependended on inputs\r\n\t\t\t\t\t\tcontextualized.listeners = []\r\n\t\t\t\t\t}*/\r\n\t\r\n\t\t\t\t\tif (!context) {\r\n\t\t\t\t\t\tparentContext.addInput(this)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (value && value.then) {\r\n\t\t\t\t\treturn when(value, function(value) {\r\n\t\t\t\t\t\treturn Variable.prototype.gotValue.call(variable, value, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\treturn value\r\n\t\t\t},\r\n\t\t\tisMap: function() {\r\n\t\t\t\treturn this.value instanceof Map\r\n\t\t\t},\r\n\t\t\tproperty: function(key, PropertyClass) {\r\n\t\t\t\tvar isMap = this.isMap()\r\n\t\t\t\tvar properties = this._properties || (this._properties = isMap ? new Map() : {})\r\n\t\t\t\tvar propertyVariable = isMap ? properties.get(key) : properties[key]\r\n\t\t\t\tif (!propertyVariable) {\r\n\t\t\t\t\t// create the property variable\r\n\t\t\t\t\tpropertyVariable = new (PropertyClass || Variable)()\r\n\t\t\t\t\tpropertyVariable.key = key\r\n\t\t\t\t\tpropertyVariable.parent = this\r\n\t\t\t\t\tif (isMap) {\r\n\t\t\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tproperties[key] = propertyVariable\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn propertyVariable\r\n\t\t\t},\r\n\t\t\tfor: function(subject) {\r\n\t\t\t\tif (subject && subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t\t// makes HTML events work\r\n\t\t\t\t\tsubject = subject.target\r\n\t\t\t\t}\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\treturn this.parent.for(subject).property(this.key)\r\n\t\t\t\t}\r\n\t\t\t\treturn new ContextualizedVariable(this, subject || defaultContext)\r\n\t\t\t},\r\n\t\t\t_changeValue: function(context, type, newValue) {\r\n\t\t\t\tvar key = this.key\r\n\t\t\t\tvar parent = this.parent\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tparent._willModify(context)\r\n\t\t\t\treturn when(parent.valueOf(context), function(object) {\r\n\t\t\t\t\tif (object == null) {\r\n\t\t\t\t\t\t// nothing there yet, create an object to hold the new property\r\n\t\t\t\t\t\tvar response = parent.put(object = typeof key == 'number' ? [] : {}, context)\r\n\t\t\t\t\t} else if (typeof object != 'object') {\r\n\t\t\t\t\t\t// if the parent is not an object, we can't set anything (that will be retained)\r\n\t\t\t\t\t\treturn deny\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar oldValue = typeof object.get === 'function' ? object.get(key) : object[key]\r\n\t\t\t\t\tif (oldValue === newValue) {\r\n\t\t\t\t\t\t// no actual change to make\r\n\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (variable.__debug) {\r\n\t\t\t\t\t\t// debug is on\r\n\t\t\t\t\t\tconsole.log('Variable changed from', oldValue, newValue, 'at')\r\n\t\t\t\t\t\tconsole.log((new Error().stack || '').replace(/Error/, ''))\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (typeof object.set === 'function') {\r\n\t\t\t\t\t\tobject.set(key, newValue)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (type == RequestChange && oldValue && oldValue.put) {\r\n\t\t\t\t\t\t\t// if a put and the property value is a variable, assign it to that.\r\n\t\t\t\t\t\t\toldValue.put(newValue)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tobject[key] = newValue\r\n\t\t\t\t\t\t\t// or set the setter/getter\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvariable.updated(null, variable, context)\r\n\t\r\n\t\t\t\t\t// now notify any object listeners\r\n\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\t// we need to do it before the other listeners, so we can update it before\r\n\t\t\t\t\t// we trigger a full clobbering of the object\r\n\t\t\t\t\tif (listeners) {\r\n\t\t\t\t\t\tlisteners = listeners.slice(0)\r\n\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\tif (listener !== parent) {\r\n\t\t\t\t\t\t\t\t// now go ahead and actually trigger the other listeners (but make sure we don't do the parent again)\r\n\t\t\t\t\t\t\t\tlistener._propertyChange(key, object, context, type)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\t_propertyChange: function(propertyName, object, context, type) {\r\n\t\t\t\tif (this.onPropertyChange) {\r\n\t\t\t\t\tthis.onPropertyChange(propertyName, object, context)\r\n\t\t\t\t}\r\n\t\t\t\tthis.updated(new PropertyChangeEvent(propertyName, new RefreshEvent(), this), null, context)\r\n\t\t\t},\r\n\t\t\teachKey: function(callback) {\r\n\t\t\t\tfor (var i in this._properties) {\r\n\t\t\t\t\tcallback(i)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tapply: function(instance, args) {\r\n\t\t\t\treturn new Call(this, args)\r\n\t\t\t},\r\n\t\t\tcall: function(instance) {\r\n\t\t\t\treturn this.apply(instance, Array.prototype.slice.call(arguments, 1))\r\n\t\t\t},\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tif (this.returnedVariable) {\r\n\t\t\t\t\tcallback(this.returnedVariable)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.hasNotifyingChild) {\r\n\t\t\t\t\tvar properties = this._properties\r\n\t\t\t\t\tif (properties) {\r\n\t\t\t\t\t\tforPropertyNotifyingValues(properties, callback)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\tcallback(this.parent)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tinit: function() {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\t\tdependency.notifies(variable)\r\n\t\t\t\t})\r\n\t\r\n\t\t\t\tif (this.listeningToObject === null) {\r\n\t\t\t\t\t// we were previously listening to an object, but it needs to be restored\r\n\t\t\t\t\t// calling valueOf will cause the listening object to be restored\r\n\t\t\t\t\tthis.valueOf()\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcleanup: function() {\r\n\t\t\t\tthis.listeners = false\r\n\t\t\t\tvar handles = this.handles\r\n\t\t\t\tif (handles) {\r\n\t\t\t\t\tfor (var i = 0; i < handles.length; i++) {\r\n\t\t\t\t\t\thandles[i].remove()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.handles = null\r\n\t\t\t\tvar returnedVariable = this.returnedVariable\r\n\t\t\t\tif (returnedVariable) {\r\n\t\t\t\t\t// TODO: move this into the caching class\r\n\t\t\t\t\tthis.computedVariable = null\r\n\t\t\t\t}\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\t\tdependency.stopNotifies(variable)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\tupdateVersion: function(version) {\r\n\t\t\t\tthis.version = nextId++\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\treturn Math.max(this.version || 0, this.returnedVariable && this.returnedVariable.getVersion ? this.returnedVariable.getVersion(context) : 0)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetSubject: function(selectVariable) {\r\n\t\t\t\treturn this.subject\r\n\t\t\t},\r\n\t\r\n\t\t\tgetUpdates: function(since) {\r\n\t\t\t\tvar updates = []\r\n\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\tif (nextUpdateMap && since) {\r\n\t\t\t\t\twhile ((since = nextUpdateMap.get(since))) {\r\n\t\t\t\t\t\tif (since.type === 'refresh') {\r\n\t\t\t\t\t\t\t// if it was refresh, we can clear any prior entries\r\n\t\t\t\t\t\t\tupdates = []\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tupdates.push(since)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn updates\r\n\t\t\t},\r\n\t\r\n\t\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\t\tif (!updateEvent) {\r\n\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t}\r\n\t\t\t\tif (updateEvent.visited.has(this)){\r\n\t\t\t\t\t// if this event has already visited this variable, skip it\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tupdateEvent.visited.add(this)\r\n\t\t\t\tvar contextualInstance = context ? context.getContextualized(this) : this\r\n\t\t\t\tif (contextualInstance) {\r\n\t\t\t\t\tcontextualInstance.updated(updateEvent, this, context)\r\n\t\t\t\t}\r\n\t\t\t\t/*\r\n\t\t\t\t// at some point we could do an update list so that we could incrementally update\r\n\t\t\t\t// lists in non-live situations\r\n\t\t\t\tif (this.lastUpdate) {\r\n\t\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\t\tif (!nextUpdateMap) {\r\n\t\t\t\t\t\tnextUpdateMap = this.nextUpdateMap = new WeakMap()\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextUpdateMap.set(this.lastUpdate, updateEvent)\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.lastUpdate = updateEvent */\r\n\t\t\t\tthis.updateVersion()\r\n\t\r\n\t\t\t\tvar listeners = this.listeners\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\t// make a copy, in case they change\r\n\t\t\t\t\tlisteners.forEach(function(dependent) {\r\n\t\t\t\t\t\tif ((updateEvent instanceof PropertyChangeEvent) &&\r\n\t\t\t\t\t\t\t\tdependent.parent) {\r\n\t\t\t\t\t\t\tif (dependent.key === updateEvent.key) {\r\n\t\t\t\t\t\t\t\tdependent.updated(updateEvent.childEvent, variable, context)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tdependent.updated(updateEvent, variable, context)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\tif (updateEvent instanceof PropertyChangeEvent) {\r\n\t\t\t\t\tif (this.returnedVariable && this.fixed) {\r\n\t\t\t\t\t\tthis.returnedVariable.updated(updateEvent, this, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.constructor.collection) {\r\n\t\t\t\t\t\tthis.constructor.collection.updated(updateEvent, this, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\t\tthis.parent.updated(new PropertyChangeEvent(this.key, updateEvent, this.parent), this, context)\r\n\t\t\t\t}\r\n\t\t\t\treturn updateEvent\r\n\t\t\t},\r\n\t\r\n\t\t\tinvalidate: function() {\r\n\t\t\t\t// for back-compatibility for now\r\n\t\t\t\tthis.updated()\r\n\t\t\t},\r\n\t\r\n\t\t\tnotifies: function(target) {\r\n\t\t\t\tvar listeners = this.listeners\r\n\t\t\t\tif (!listeners || !this.hasOwnProperty('listeners')) {\r\n\t\t\t\t\tthis.listeners = listeners = new Set()\r\n\t\t\t\t\tthis.init()\r\n\t\t\t\t}\r\n\t\t\t\tlisteners.add(target)\r\n\t\t\t},\r\n\t\t\tsubscribe: function(listener) {\r\n\t\t\t\t// ES7 Observable (and baconjs) compatible API\r\n\t\t\t\tvar updated\r\n\t\t\t\tvar updateQueued\r\n\t\t\t\tvar variable = this\r\n\t\t\t\t// it is important to make sure you register for notifications before getting the value\r\n\t\t\t\tif (typeof listener === 'function') {\r\n\t\t\t\t\t// BaconJS compatible API\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\tvar event = {\r\n\t\t\t\t\t\tvalue: function() {\r\n\t\t\t\t\t\t\treturn variable.valueOf()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdated = function() {\r\n\t\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\t\tlistener(event)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\telse if (listener.next) {\r\n\t\t\t\t\t// Assuming ES7 Observable API. It is actually a streaming API, this pretty much violates all principles of reactivity, but we will support it\r\n\t\t\t\t\tupdated = function() {\r\n\t\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\t\tlistener.next(variable.valueOf())\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error('Subscribing to an invalid listener, the listener must be a function, or have an update or next method')\r\n\t\t\t\t}\r\n\t\t\t\tvar updateReceiver = {\r\n\t\t\t\t\tupdated: function() {\r\n\t\t\t\t\t\tif (updateQueued) {\r\n\t\t\t\t\t\t\treturn\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tupdateQueued = true\r\n\t\t\t\t\t\tlang.nextTurn(updated)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tupdated()\r\n\t\t\t\tthis.notifies(updateReceiver)\r\n\t\t\t\treturn {\r\n\t\t\t\t\tunsubscribe: function() {\r\n\t\t\t\t\t\tvariable.stopNotifies(updateReceiver)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tstopNotifies: function(dependent) {\r\n\t\t\t\tvar listeners = this.listeners\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tlisteners.delete(dependent)\r\n\t\t\t\t\tif (listeners.size === 0) {\r\n\t\t\t\t\t\t// clear the listeners so it will be reinitialized if it has\r\n\t\t\t\t\t\t// listeners again\r\n\t\t\t\t\t\tthis.cleanup()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tput: function(value, context) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\treturn this._changeValue(context, RequestChange, value)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.ownObject) {\r\n\t\t\t\t\tthis.ownObject = false\r\n\t\t\t\t}\r\n\t\t\t\treturn when(this.getValue ? this.getValue(context) : this.value, function(oldValue) {\r\n\t\t\t\t\tif (variable.__debug) {\r\n\t\t\t\t\t\t// debug is on\r\n\t\t\t\t\t\tconsole.log('Variable changed from', oldValue, newValue, 'at')\r\n\t\t\t\t\t\tconsole.log((new Error().stack || '').replace(/Error/, ''))\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (oldValue === value) {\r\n\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (variable.fixed &&\r\n\t\t\t\t\t\t\t// if it is set to fixed, we see we can put in the current variable\r\n\t\t\t\t\t\t\toldValue && oldValue.put) {\r\n\t\t\t\t\t\treturn oldValue.put(value)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn when(variable.setValue(value, context), function(value) {\r\n\t\t\t\t\t\tvariable.updated(new RefreshEvent(), variable, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tget: function(key) {\r\n\t\t\t\tif (this._properties && this._properties[key]) {\r\n\t\t\t\t\treturn this.property(key).valueOf()\r\n\t\t\t\t}\r\n\t\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\t\tvar value = object && (typeof object.get === 'function' ? object.get(key) : object[key])\r\n\t\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t\t// nested variable situation, get underlying value\r\n\t\t\t\t\t\treturn value.valueOf()\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn value\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tset: function(key, value) {\r\n\t\t\t\t// TODO: create an optimized route when the property doesn't exist yet\r\n\t\t\t\tthis.property(key)._changeValue(null, RequestSet, value)\r\n\t\t\t},\r\n\t\t\tundefine: function(key, context) {\r\n\t\t\t\tthis.set(key, undefined, context)\r\n\t\t\t},\r\n\t\t\tproxy: function(proxiedVariable) {\r\n\t\t\t\tvar thisVariable = this\r\n\t\t\t\tthis.fixed = true\r\n\t\t\t\treturn when(this.setValue(proxiedVariable), function(value) {\r\n\t\t\t\t\tthisVariable.updated(new RefreshEvent(), thisVariable)\r\n\t\t\t\t\treturn thisVariable\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tnext: function(value) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tthis.put(value)\r\n\t\t\t},\r\n\t\t\terror: function(error) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tvar listeners = this.listeners\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\t// make a copy, in case they change\r\n\t\t\t\t\tlisteners.forEach(function(dependent) {\r\n\t\t\t\t\t\t// skip notifying property listeners if we are headed up the parent chain\r\n\t\t\t\t\t\tdependent.error(error)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcomplete: function(value) {\r\n\t\t\t\t// for ES7 observable compatibility\r\n\t\t\t\tthis.put(value)\r\n\t\t\t},\r\n\t\t\tsetValue: function(value) {\r\n\t\t\t\tthis.value = value\r\n\t\t\t},\r\n\t\t\tonValue: function(listener) {\r\n\t\t\t\treturn this.subscribe(function(event) {\r\n\t\t\t\t\tlang.when(event.value(), function(value) {\r\n\t\t\t\t\t\tlistener(value)\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\ttoJSON: function() {\r\n\t\t\t\treturn this.valueOf()\r\n\t\t\t},\r\n\t\t\ttoString: function() {\r\n\t\t\t\treturn this.valueOf()\r\n\t\t\t},\r\n\t\t\tforEach: function(callbackOrItemClass, callbackOrContext, context) {\r\n\t\t\t\t// iterate through current value of variable\r\n\t\t\t\tif (callbackOrItemClass.notifies) {\r\n\t\t\t\t\tvar collectionVariable = this\r\n\t\t\t\t\treturn this.forEach(function(item) {\r\n\t\t\t\t\t\tvar itemVariable = callbackOrItemClass.from(item)\r\n\t\t\t\t\t\tcallbackOrContext.call(this, itemVariable)\r\n\t\t\t\t\t}, context)\r\n\t\t\t\t}\r\n\t\t\t\treturn when(this.valueOf(callbackOrContext), function(value) {\r\n\t\t\t\t\tif (value && value.forEach) {\r\n\t\t\t\t\t\tvalue.forEach(callbackOrItemClass)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tfor (var i in value) {\r\n\t\t\t\t\t\t\tcallbackOrItemClass.call(value, value[i], i)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\tto: function (transformFunction, reverse) {\r\n\t\t\t\tif (typeof transformFunction !== 'function') {\r\n\t\t\t\t\tif (typeof transformFunction === 'object') {\r\n\t\t\t\t\t\tthis.to(transformFunction.get, transformFunction.set)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthrow new Error('No function provided to transform')\r\n\t\t\t\t}\r\n\t\t\t\tif (reverse) {\r\n\t\t\t\t\ttransformFunction.reverse = function(value, args, context) {\r\n\t\t\t\t\t\t// for direct to, we can just use the first argument\r\n\t\t\t\t\t\treverse.call(this, args[0], context)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn new Call(transformFunction, [this])\r\n\t\t\t},\r\n\t\t\tget schema() {\r\n\t\t\t\t// default schema is the constructor\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\tvar parentSchemaProperties = this.parent.schema.properties\r\n\t\t\t\t\treturn parentSchemaProperties && parentSchemaProperties[this.key]\r\n\t\t\t\t}\r\n\t\t\t\treturn this.returnedVariable ? this.returnedVariable.schema : this.constructor\r\n\t\t\t},\r\n\t\t\tset schema(schema) {\r\n\t\t\t\t// but allow it to be overriden\r\n\t\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\t\tvalue: schema\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tvalidate: function(target, schema) {\r\n\t\t\t\tif (this.returnedVariable) {\r\n\t\t\t\t\treturn this.returnedVariable.validate(target, schema)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.parent) {\r\n\t\t\t\t\treturn this.parent.validate(target.valueOf(), schema)\r\n\t\t\t\t}\r\n\t\t\t\tif (schema && schema.type && (schema.type !== typeof target)) {\r\n\t\t\t\t\treturn ['Target type of ' + typeof target + ' does not match schema type of ' + schema.type]\r\n\t\t\t\t}\r\n\t\t\t\tvar valid = []\r\n\t\t\t\tvalid.isValid = true\r\n\t\t\t\treturn valid\r\n\t\t\t},\r\n\t\r\n\t\t\tget validation() {\r\n\t\t\t\tvar validation = new Validating(this)\r\n\t\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\t\tvalue: validation\r\n\t\t\t\t})\r\n\t\t\t\treturn validation\r\n\t\t\t},\r\n\t\t\tset validation(validation) {\r\n\t\t\t\t// but allow it to be overriden\r\n\t\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\t\tvalue: validation\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tset structured(structure) {\r\n\t\t\t\t// find any variable properties and attaches them as a property\r\n\t\t\t\tvar keys = Object.keys(this)\r\n\t\t\t\tvar properties = keys.length > 1 && this._properties || (this._properties = {})\r\n\t\t\t\tfor(var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\t\tvar key = keys[i]\r\n\t\t\t\t\tvar value = this[key]\r\n\t\t\t\t\tif (value instanceof Variable) {\r\n\t\t\t\t\t\tvar existing = properties[key]\r\n\t\t\t\t\t\tif (existing) {\r\n\t\t\t\t\t\t\tif (existing !== value) {\r\n\t\t\t\t\t\t\t\t// an existing property exists, put in it\r\n\t\t\t\t\t\t\t\texisting.put(value)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (value.parent) {\r\n\t\t\t\t\t\t\t\tif (value.parent === this) {\r\n\t\t\t\t\t\t\t\t\tcontinue // just being assigned to another property\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// property already exists with different parent, make a proxy\r\n\t\t\t\t\t\t\t\t\tvar newValue = new Variable()\r\n\t\t\t\t\t\t\t\t\tnewValue.proxy(value)\r\n\t\t\t\t\t\t\t\t\tvalue = newValue\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvalue.key = key\r\n\t\t\t\t\t\t\tvalue.parent = this\r\n\t\t\t\t\t\t\tproperties[key] = value\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tgetId: function() {\r\n\t\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t\t},\r\n\t\t\tobserveObject: function() {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\tif (!listeners) {\r\n\t\t\t\t\t\tpropertyListenersMap.set(object, listeners = [])\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (listeners.observerCount) {\r\n\t\t\t\t\t\tlisteners.observerCount++\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tlisteners.observerCount = 1\r\n\t\t\t\t\t\tvar observer = listeners.observer = lang.observe(object, function(events) {\r\n\t\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\t\tfor (var j = 0, el = events.length; j < el; j++) {\r\n\t\t\t\t\t\t\t\t\tvar event = events[j]\r\n\t\t\t\t\t\t\t\t\tlistener._propertyChange(event.name, object)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\tif (observer.addKey) {\r\n\t\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\t\tlistener.eachKey(function(key) {\r\n\t\t\t\t\t\t\t\t\tobserver.addKey(key)\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tregisterListener(object, variable)\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tremove: function() {\r\n\t\t\t\t\t\t\tderegisterListener(object, variable)\r\n\t\t\t\t\t\t\tif (!(--listeners.observerCount)) {\r\n\t\t\t\t\t\t\t\tlisteners.observer.remove()\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tdone: function() {\r\n\t\t\t\t\t\t\t// deliver changes\r\n\t\t\t\t\t\t\tlang.deliverChanges(observer)\r\n\t\t\t\t\t\t\tthis.remove()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tgetCollectionOf: function() {\r\n\t\t\t\treturn this.constructor.collectionOf\r\n\t\t\t},\r\n\t\t\t_willModify: function(context) {\r\n\t\t\t\t// an intent to modify, so we need to make sure we have our own copy\r\n\t\t\t\t// of an object when necessary\r\n\t\t\t\tif (this.fixed) {\r\n\t\t\t\t\tif (this.value && this.value._willModify) {\r\n\t\t\t\t\t\treturn this.value._willModify(context)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!this.ownObject && this.value && this.value.notifies) {\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\treturn when(this.valueOf(context), function(value) {\r\n\t\t\t\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\t\t\t\tif (value instanceof Array) {\r\n\t\t\t\t\t\t\t\tvariable.ownObject = value.slice(0)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tvariable.ownObject = Object.create(value)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t} else if (this.parent) {\r\n\t\t\t\t\tthis.parent._willModify()\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t_sN: function(name) {\r\n\t\t\t\t// for compilers to set a name\r\n\t\t\t\tthis.name = name\r\n\t\t\t\treturn this\r\n\t\t\t},\r\n\t\t\tget _debug() {\r\n\t\t\t\tif (this.__debug === undefined) {\r\n\t\t\t\t\tthis.__debug = true\r\n\t\t\t\t}\r\n\t\t\t\treturn this.__debug\r\n\t\t\t},\r\n\t\t\tset _debug(_debug) {\r\n\t\t\t\tthis.__debug = _debug\r\n\t\t\t},\r\n\t\t\t// TODO: Move these to VArray\r\n\t\t\tsplice: function(startingIndex, removalCount) {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.splice.apply(array, args)\r\n\t\t\t\t\tremovedAt(this, results, startingIndex, removalCount, array.length)\r\n\t\t\t\t\tinsertedAt(this, [].slice.call(args, 2), startingIndex, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tpush: function() {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.push.apply(array, args)\r\n\t\t\t\t\tinsertedAt(this, args, array.length - args.length, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tunshift: function() {\r\n\t\t\t\tvar args = arguments\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.unshift.apply(array, args)\r\n\t\t\t\t\tinsertedAt(this, args, 0, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tpop: function() {\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.pop()\r\n\t\t\t\t\tremovedAt(this, [results], array.length, 1)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tshift: function() {\r\n\t\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\t\tvar results = array.shift()\r\n\t\t\t\t\tremovedAt(this, [results], 0, 1, array.length)\r\n\t\t\t\t\treturn results\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction arrayToModify(variable, callback) {\r\n\t\t\tvariable._willModify()\r\n\t\t\t// TODO: switch this to allow promises\r\n\t\t\twhen(variable.cachedValue || variable.valueOf(), function(array) {\r\n\t\t\t\tif (!array) {\r\n\t\t\t\t\tvariable.put(array = [])\r\n\t\t\t\t}\r\n\t\t\t\tvariable.updateVersion()\r\n\t\t\t\tvar results = callback.call(variable, array)\r\n\t\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tfunction insertedAt(variable, added, startingIndex, arrayLength) {\r\n\t\t\tvar addedCount = added.length\r\n\t\t\t// adjust the key positions of any index properties after splice\r\n\t\t\tif (addedCount > 0) {\r\n\t\t\t\tif (variable._properties) {\r\n\t\t\t\t\tvar arrayPosition\r\n\t\t\t\t\tfor (var i = arrayLength - addedCount; i > startingIndex;) {\r\n\t\t\t\t\t\tvar arrayPosition = variable._properties[--i]\r\n\t\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\t\tarrayPosition.key += addedCount\r\n\t\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// send out updates\r\n\t\t\t\tfor (var i = 0, l = added.length; i < l; i++) {\r\n\t\t\t\t\tvariable.updated(new AddEvent({\r\n\t\t\t\t\t\tvalue: added[i],\r\n\t\t\t\t\t\tindex: i + startingIndex,\r\n\t\t\t\t\t\tmodifier: variable\r\n\t\t\t\t\t}), variable)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction removedAt(variable, removed, startingIndex, removalCount, arrayLength) {\r\n\t\t\t// adjust the properties\r\n\t\t\tvar i = startingIndex + removalCount\r\n\t\t\tvar arrayPosition\r\n\t\t\tif (removalCount > 0) {\r\n\t\t\t\tif (variable._properties) {\r\n\t\t\t\t\tfor (var i = startingIndex + removalCount; i < arrayLength + removalCount; i++) {\r\n\t\t\t\t\t\tvar arrayPosition = variable._properties[i]\r\n\t\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\t\tarrayPosition.key -= removalCount\r\n\t\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// send out updates\r\n\t\t\t\tfor (var i = 0; i < removalCount; i++) {\r\n\t\t\t\t\tvariable.updated(new DeleteEvent({\r\n\t\t\t\t\t\tpreviousIndex: startingIndex,\r\n\t\t\t\t\t\toldValue: removed[i],\r\n\t\t\t\t\t\tmodifier: variable\r\n\t\t\t\t\t}), variable)\r\n\t\t\t\t}\r\n\t\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tif (typeof Symbol !== 'undefined') {\r\n\t\t\tVariable.prototype[Symbol.iterator] = function() {\r\n\t\t\t\treturn this.valueOf()[Symbol.iterator]()\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tVariable.VMap = lang.compose(Variable, function(value){\r\n\t\t\tthis.value = typeof value === 'undefined' ? this.default : value\r\n\t\t}, {\r\n\t\t\t// TODO: Move all the get and set functionality for maps out of Variable\r\n\t\t\tproperty: function(key) {\r\n\t\t\t\tvar properties = this._properties || (this._properties = new Map())\r\n\t\t\t\tvar propertyVariable = properties.get(key)\r\n\t\t\t\tif (!propertyVariable) {\r\n\t\t\t\t\t// create the property variable\r\n\t\t\t\t\tpropertyVariable = new Variable()\r\n\t\t\t\t\tpropertyVariable.key = key\r\n\t\t\t\t\tpropertyVariable.parent = this\r\n\t\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t\t}\r\n\t\t\t\treturn propertyVariable\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar cacheNotFound = {}\r\n\t\tvar Caching = Variable.Caching = lang.compose(Variable, function(getValue, setValue) {\r\n\t\t\tif (getValue) {\r\n\t\t\t\tthis.getValue = getValue\r\n\t\t\t}\r\n\t\t\tif (setValue) {\r\n\t\t\t\tthis.setValue = setValue\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\t// first check to see if we have the variable already computed\r\n\t\t\t\tvar contextualizedVariable = this\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontextualizedVariable = context.getContextualized(this)\r\n\t\t\t\t\tif (!contextualizedVariable && this.context && this.context.matches(context)) {\r\n\t\t\t\t\t\tcontextualizedVariable = this\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (contextualizedVariable && contextualizedVariable.cachedVersion === contextualizedVariable.getVersion()) {\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tcontext.addInput(contextualizedVariable)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn contextualizedVariable.cachedValue\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tfunction withComputedValue(computedValue) {\r\n\t\t\t\t\tif (computedValue && computedValue.notifies && variable.listeners) {\r\n\t\t\t\t\t\tvariable.computedVariable = computedValue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcomputedValue = variable.gotValue(computedValue, context, transformContext)\r\n\t\t\t\t\tvar contextualizedVariable = transformContext && transformContext.contextualized || variable\r\n\t\t\t\t\tcontextualizedVariable.cachedVersion = newVersion\r\n\t\t\t\t\tcontextualizedVariable.cachedValue = computedValue\r\n\t\t\t\t\tcontextualizedVariable.context = transformContext\r\n\t\t\t\t\treturn computedValue\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar transformContext\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\ttransformContext = context.newContext()\r\n\t\t\t\t}\r\n\t\t\t\tvar newVersion = this.getVersion()\r\n\t\t\t\tvar computedValue = this.getValue(transformContext)\r\n\t\t\t\tif (computedValue && computedValue.then) {\r\n\t\t\t\t\t// call it initially so the dependencies can be registered\r\n\t\t\t\t\tthis.gotValue(null, context, transformContext)\r\n\t\t\t\t\treturn computedValue.then(withComputedValue)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn withComputedValue(computedValue)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction GetCache() {\r\n\t\t}\r\n\t\r\n\t\r\n\t\tvar Item = Variable.Item = lang.compose(Variable, function Item(value, content) {\r\n\t\t\tthis.value = value\r\n\t\t\tthis.collection = content\r\n\t\t}, {})\r\n\t\r\n\t\tvar Composite = Variable.Composite = lang.compose(Caching, function Composite(args) {\r\n\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\tthis['argument' + i] = args[i]\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\t// depend on the args\r\n\t\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\t\tif (argument && argument.notifies) {\r\n\t\t\t\t\t\tcallback(argument)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\t\tif (by !== this.returnedVariable && updateEvent && updateEvent.type !== 'refresh') {\r\n\t\t\t\t\t// search for the output in the inputs\r\n\t\t\t\t\tvar argument, argumentName\r\n\t\t\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\t\t\tif (argument === by) {\r\n\t\t\t\t\t\t\t// if one of the args was updated, we need to do a full refresh (we can't compute differential events without knowledge of how the mapping function works)\r\n\t\t\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn Caching.prototype.updated.call(this, updateEvent, by, context)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetUpdates: function(since) {\r\n\t\t\t\t// this always issues updates, nothing incremental can flow through it\r\n\t\t\t\tif (!since || since.version < getVersion()) {\r\n\t\t\t\t\treturn [new RefreshEvent()]\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\tvar version = Variable.prototype.getVersion.call(this, context)\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\t\tif (argument && argument.getVersion) {\r\n\t\t\t\t\t\tversion = Math.max(version, argument.getVersion(context))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn version\r\n\t\t\t},\r\n\t\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tvar results = []\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresults[i] = argument && argument.valueOf(context)\r\n\t\t\t\t}\r\n\t\t\t\treturn whenAll(results, function(resolved) {\r\n\t\t\t\t\treturn resolved\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tgetArguments: function() {\r\n\t\t\t\tvar args = []\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\t\targs.push(argument)\r\n\t\t\t\t}\r\n\t\t\t\treturn args\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\t// a call variable is the result of a call\r\n\t\tvar Call = lang.compose(Composite, function Transform(transform, args) {\r\n\t\t\tthis.transform = transform\r\n\t\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\t\tthis['argument' + i] = args[i]\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\tfixed: true,\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\t// depend on the args\r\n\t\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tif (this.transform.notifies) {\r\n\t\t\t\t\tcallback(this.transform)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.nextProperty = 'transform'\r\n\t\t\t\t}\r\n\t\t\t\tvar functionValue = this.transform.valueOf(context)\r\n\t\t\t\tif (functionValue.then) {\r\n\t\t\t\t\tvar call = this\r\n\t\t\t\t\treturn functionValue.then(function(functionValue) {\r\n\t\t\t\t\t\treturn call.invoke(functionValue, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\treturn this.invoke(functionValue, context)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\t// TODO: shortcut if we are live and since equals this.lastUpdate\r\n\t\t\t\tvar argsVersion = Composite.prototype.getVersion.call(this, context)\r\n\t\t\t\tif (this.transform.getVersion) {\r\n\t\t\t\t\treturn Math.max(argsVersion, this.transform.getVersion(context))\r\n\t\t\t\t}\r\n\t\t\t\treturn argsVersion\r\n\t\t\t},\r\n\t\r\n\t\t\texecute: function(context) {\r\n\t\t\t\tvar call = this\r\n\t\t\t\treturn when(this.transform.valueOf(context), function(functionValue) {\r\n\t\t\t\t\treturn call.invoke(functionValue, context, true)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\r\n\t\t\tput: function(value, context) {\r\n\t\t\t\tvar call = this\r\n\t\t\t\treturn when(this.valueOf(context), function(originalValue) {\r\n\t\t\t\t\tif (originalValue === value) {\r\n\t\t\t\t\t\treturn noChange\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn when(call.transform.valueOf(context), function(functionValue) {\r\n\t\t\t\t\t\treturn call.invoke(function() {\r\n\t\t\t\t\t\t\tif (functionValue.reverse) {\r\n\t\t\t\t\t\t\t\tfunctionValue.reverse.call(call, value, call.getArguments(), context)\r\n\t\t\t\t\t\t\t\treturn Variable.prototype.put.call(call, value, context)\r\n\t\t\t\t\t\t\t} else if (originalValue && originalValue.put) {\r\n\t\t\t\t\t\t\t\treturn originalValue.put(value)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\treturn deny\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}, context)\r\n\t\t\t\t\t});\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tinvoke: function(functionValue, context, observeArguments) {\r\n\t\t\t\tvar instance = this.transform.parent\r\n\t\t\t\tif (functionValue.handlesVariables || functionValue.property) {\r\n\t\t\t\t\treturn functionValue.apply(instance, this.getArguments(), context)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tvar results = []\r\n\t\t\t\t\tvar argument, argumentName\r\n\t\t\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tresults[i] = argument && argument.valueOf(context)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinstance = instance && instance.valueOf(context)\r\n\t\t\t\t\tif (functionValue.handlesPromises) {\r\n\t\t\t\t\t\treturn functionValue.apply(instance, results, context)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// include the instance in whenAll\r\n\t\t\t\t\t\tresults.push(instance)\r\n\t\t\t\t\t\t// wait for the values to be received\r\n\t\t\t\t\t\treturn whenAll(results, function(inputs) {\r\n\t\t\t\t\t\t\tif (observeArguments) {\r\n\t\t\t\t\t\t\t\tvar handles = []\r\n\t\t\t\t\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\t\t\tif (input && typeof input === 'object') {\r\n\t\t\t\t\t\t\t\t\t\thandles.push(observe(input))\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\tvar result = functionValue.apply(instance, inputs, context)\r\n\t\t\t\t\t\t\t\t}finally{\r\n\t\t\t\t\t\t\t\t\twhen(result, function() {\r\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\t\thandles[i].done()\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\t\treturn functionValue.apply(instance, inputs, context)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tsetReverse: function(reverse) {\r\n\t\t\t\tthis.transform.valueOf().reverse = reverse\r\n\t\t\t\treturn this\r\n\t\t\t},\r\n\t\t\tgetCollectionOf: function() {\r\n\t\t\t\treturn this.returnedVariable && this.returnedVariable.getCollectionOf()\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.Call = Call\r\n\t\r\n\t\tvar ContextualizedVariable = lang.compose(Variable, function ContextualizedVariable(generic, subject) {\r\n\t\t\tthis.generic = generic\r\n\t\t\tthis.subject = subject\r\n\t\t}, {\r\n\t\t\tvalueOf: function() {\r\n\t\t\t\t// TODO: Lookup Context type for all of these using registry or something\r\n\t\t\t\tvar subject = this.subject\r\n\t\t\t\treturn this.generic.valueOf(subject.getContextualized ? subject : new Context(subject))\r\n\t\t\t},\r\n\t\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tthis.inputs && this.inputs.forEach(callback)\r\n\t\t\t},\r\n\t\r\n\t\t\tgetVersion: function() {\r\n\t\t\t\tvar version = Variable.prototype.getVersion.call(this)\r\n\t\t\t\tvar inputs = this.inputs || 0\r\n\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\tif (input.getVersion) {\r\n\t\t\t\t\t\tversion = Math.max(version, input.getVersion())\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn version\r\n\t\t\t},\r\n\t\r\n\t\t\tput: function(value) {\r\n\t\t\t\tvar subject = this.subject\r\n\t\t\t\treturn this.generic.put(value, subject.getContextualized ? subject : new Context(subject))\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar IterativeMethod = lang.compose(Composite, function(source, method, args) {\r\n\t\t\tthis.source = source\r\n\t\t\t// source.interestWithin = true\r\n\t\t\tthis.method = method\r\n\t\t\tthis.arguments = args\r\n\t\t}, {\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tvar method = this.method\r\n\t\t\t\tvar args = this.arguments\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.nextProperty = 'source'\r\n\t\t\t\t}\r\n\t\t\t\treturn when(this.source.valueOf(context), function(array) {\r\n\t\t\t\t\tif (array && array.forEach) {\r\n\t\t\t\t\t\tif (context && context.notify) {\r\n\t\t\t\t\t\t\tvar contextualizedVariable\r\n\t\t\t\t\t\t\tif (context.distinctSubject) {\r\n\t\t\t\t\t\t\t\tvar contextMap = variable._contextMap || (variable._contextMap = new WeakMap())\r\n\t\t\t\t\t\t\t\tif (contextMap.has(context.distinctSubject)) {\r\n\t\t\t\t\t\t\t\t\tcontextualizedVariable = contextMap.get(context.distinctSubject)\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tcontextMap.set(context.distinctSubject, contextualizedVariable = Object.create(variable))\r\n\t\t\t\t\t\t\t\t\tcontextualizedVariable.listeners = false\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcontextualizedVariable = variable\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvariable.notifies(contextualizedVariable)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (method === 'map'){\r\n\t\t\t\t\t\t\t// fast path, and special behavior for map\r\n\t\t\t\t\t\t\treturn args[0](array)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// if not an array convert to an array\r\n\t\t\t\t\t\tarray = [array]\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (typeof method === 'string') {\r\n\t\t\t\t\t\t// apply method\r\n\t\t\t\t\t\treturn array[method].apply(array, args)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn method(array, args)\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\t// TODO: Create specialized updated handlers for faster recomputation of other array derivatives\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\t// depend on the args\r\n\t\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tcallback(this.source)\r\n\t\t\t},\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\treturn Math.max(Composite.prototype.getVersion.call(this, context), this.source.getVersion(context))\r\n\t\t\t},\r\n\t\t\tgetCollectionOf: function(){\r\n\t\t\t\treturn this.source.getCollectionOf()\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction defineArrayMethod(method, constructor, properties) {\r\n\t\t\tvar IterativeResults = lang.compose(IterativeMethod, constructor, properties)\r\n\t\t\tIterativeResults.prototype.method || (IterativeResults.prototype.method = method)\r\n\t\t\tObject.defineProperty(IterativeResults.prototype, 'isIterable', {value: true});\r\n\t\t\tVariable.prototype[method] = function() {\r\n\t\t\t\tvar results = new IterativeResults()\r\n\t\t\t\tresults.source = this\r\n\t\t\t\tresults.arguments = arguments\r\n\t\t\t\treturn results\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tdefineArrayMethod('filter', function Filtered() {}, {\r\n\t\t\tupdated: function(event, by, context) {\r\n\t\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t\t}\r\n\t\t\t\tvar contextualizedVariable = context ? context.getContextualized(this) : this\r\n\t\t\t\tif (event.type === 'delete') {\r\n\t\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(event.oldValue)\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\t\tif ([event.value].filter(this.arguments[0]).length > 0) {\r\n\t\t\t\t\t\tcontextualizedVariable.push(event.value)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(object)\r\n\t\t\t\t\tvar matches = [object].filter(this.arguments[0]).length > 0\r\n\t\t\t\t\tif (index > -1) {\r\n\t\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\t\treturn new PropertyChangeEvent(index, event, contextualizedVariable.cachedValue,\r\n\t\t\t\t\t\t\t\t// might need to do something with this\r\n\t\t\t\t\t\t\t\tobject)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\telse {\r\n\t\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\t\tcontextualizedVariable.push(object)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// else nothing mactches\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tdefineArrayMethod('map', function Mapped() {}, {\r\n\t\t\tupdated: function(event, by, context) {\r\n\t\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t\t}\r\n\t\t\t\tvar contextualizedVariable = context ? context.getContextualized(this) : this\r\n\t\t\t\tif (event.type === 'delete') {\r\n\t\t\t\t\tcontextualizedVariable.splice(event.previousIndex, 1)\r\n\t\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\t\tcontextualizedVariable.push(this.arguments[0].call(this.arguments[1], event.value))\r\n\t\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\t\tvar array = contextualizedVariable.cachedValue\r\n\t\t\t\t\tif (array && array.map) {\r\n\t\t\t\t\t\tvar index = array.indexOf(object)\r\n\t\t\t\t\t\tvar matches = [object].filter(this.arguments[0]).length > 0\r\n\t\t\t\t\t\tcontextualizedVariable.splice(index, 1, this.arguments[0].call(this.arguments[1], event.value))\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tdefineArrayMethod('reduce', function Reduced() {})\r\n\t\tdefineArrayMethod('reduceRight', function Reduced() {})\r\n\t\tdefineArrayMethod('some', function Aggregated() {})\r\n\t\tdefineArrayMethod('every', function Aggregated() {})\r\n\t\tdefineArrayMethod('slice', function Aggregated() {})\r\n\t\tdefineArrayMethod('keyBy', function UniqueIndex(source, args) {}, {\r\n\t\t\tisMap: function () {\r\n\t\t\t\treturn true\r\n\t\t\t},\r\n\t\t\tmethod: function(array, args) {\r\n\t\t\t\tvar index = new Map()\r\n\t\t\t\tvar keyGenerator = args[0]\r\n\t\t\t\tvar valueGenerator = args[1]\r\n\t\t\t\tvar hasKeyFunction = typeof keyGenerator === 'function'\r\n\t\t\t\tvar hasValueFunction = typeof valueGenerator === 'function'\r\n\t\t\t\tvar hasKey = !!keyGenerator\r\n\t\t\t\tfor (var i = 0, l = array.length; i < l; i++) {\r\n\t\t\t\t\tvar element = array[i]\r\n\t\t\t\t\tindex.set(\r\n\t\t\t\t\t\thasKeyFunction ? keyGenerator(element) :\r\n\t\t\t\t\t\t\thasKey ? element[keyGenerator] : element,\r\n\t\t\t\t\t\thasValueFunction ? valueGenerator(element) : element)\r\n\t\t\t\t}\r\n\t\t\t\treturn index\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tdefineArrayMethod('groupBy', function UniqueIndex(source, args) {}, {\r\n\t\t\tisMap: function () {\r\n\t\t\t\treturn true\r\n\t\t\t},\r\n\t\t\tmethod: function(array, args) {\r\n\t\t\t\tvar index = new Map()\r\n\t\t\t\tvar keyGenerator = args[0]\r\n\t\t\t\tvar valueGenerator = args[1]\r\n\t\t\t\tvar hasKeyFunction = typeof keyGenerator === 'function'\r\n\t\t\t\tvar hasValueFunction = typeof valueGenerator === 'function'\r\n\t\t\t\tvar hasKey = !!keyGenerator\r\n\t\t\t\tfor (var i = 0, l = array.length; i < l; i++) {\r\n\t\t\t\t\tvar element = array[i]\r\n\t\t\t\t\tvar key = hasKeyFunction ? keyGenerator(element) :\r\n\t\t\t\t\t\t\thasKey ? element[keyGenerator] : element\r\n\t\t\t\t\tvar group = index.get(key)\r\n\t\t\t\t\tif (!group) {\r\n\t\t\t\t\t\tindex.set(key, group = [])\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgroup.push(hasValueFunction ? valueGenerator(element) : element)\r\n\t\t\t\t}\r\n\t\t\t\treturn index\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\r\n\t\tvar getValue\r\n\t\tvar GeneratorVariable = Variable.GeneratorVariable = lang.compose(Variable.Composite, function ReactiveGenerator(generator){\r\n\t\t\tthis.generator = generator\r\n\t\t}, {\r\n\t\t\tgetValue: getValue = function(context, resuming) {\r\n\t\t\t\tvar lastValue\r\n\t\t\t\tvar i\r\n\t\t\t\tvar generatorIterator\r\n\t\t\t\tvar isThrowing\r\n\t\t\t\tif (resuming) {\r\n\t\t\t\t\t// resuming from a promise\r\n\t\t\t\t\tgeneratorIterator = resuming.iterator\r\n\t\t\t\t\ti = resuming.i\r\n\t\t\t\t\tlastValue = resuming.value\r\n\t\t\t\t\tisThrowing = resuming.isThrowing\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// a fresh start\r\n\t\t\t\t\ti = 0\r\n\t\t\t\t\tgeneratorIterator = this.generator()\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar stepReturn = generatorIterator[isThrowing ? 'throw' : 'next'](lastValue)\r\n\t\t\t\t\tif (stepReturn.done) {\r\n\t\t\t\t\t\treturn stepReturn.value\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar nextVariable = stepReturn.value\r\n\t\t\t\t\t// compare with the arguments from the last\r\n\t\t\t\t\t// execution to see if they are the same\r\n\t\t\t\t\tvar argumentName = 'argument' + i\r\n\t\t\t\t\tif (this[argumentName] !== nextVariable) {\r\n\t\t\t\t\t\tif (this[argumentName]) {\r\n\t\t\t\t\t\t\tthis[argumentName].stopNotifies(this)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// subscribe if it is a variable\r\n\t\t\t\t\t\tif (nextVariable && nextVariable.notifies) {\r\n\t\t\t\t\t\t\tif (this.listeners) {\r\n\t\t\t\t\t\t\t\tnextVariable.notifies(this)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tthis[argumentName] = nextVariable\r\n\t\t\t\t\t\t} else if (typeof nextVariable === 'function' && isGenerator(nextVariable)) {\r\n\t\t\t\t\t\t\tvar delegatedGenerator\r\n\t\t\t\t\t\t\tgetValue.call(this, context, delegatedGenerator = {\r\n\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\titerator: nextVariable()\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\ti = delegatedGenerator.i\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis[argumentName] = null\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti++\r\n\t\t\t\t\tif (resuming) {\r\n\t\t\t\t\t\tresuming.i = i\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlastValue = nextVariable && nextVariable.valueOf(context)\r\n\t\t\t\t\tif (lastValue && lastValue.then) {\r\n\t\t\t\t\t\t// if it is a promise, we will wait on it\r\n\t\t\t\t\t\tvar variable = this\r\n\t\t\t\t\t\t// and return the promise so that the getValue caller can wait on this\r\n\t\t\t\t\t\treturn lastValue.then(function(value) {\r\n\t\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\t\tvalue: error,\r\n\t\t\t\t\t\t\t\tisThrowing: true\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t} while(true)\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tvar Validating = lang.compose(Caching, function(target) {\r\n\t\t\tthis.target = target\r\n\t\t}, {\r\n\t\t\tforDependencies: function(callback) {\r\n\t\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\t\tcallback(this.target)\r\n\t\t\t},\r\n\t\t\tgetVersion: function(context) {\r\n\t\t\t\treturn Math.max(Variable.prototype.getVersion.call(this, context), this.target.getVersion(context))\r\n\t\t\t},\r\n\t\t\tgetValue: function(context) {\r\n\t\t\t\tvar target = this.target\r\n\t\t\t\t// need to actually access the target value, so it can be evaluated in case it\r\n\t\t\t\t// there is a returned variable that we should delegate to.\r\n\t\t\t\ttarget.valueOf(context)\r\n\t\t\t\treturn target.validate(target, target.schema)\r\n\t\t\t}\r\n\t\t})\r\n\t\r\n\t\tfunction validate(target) {\r\n\t\t\tvar schemaForObject = schema(target)\r\n\t\t\treturn new Validating(target, schemaForObject)\r\n\t\t}\r\n\t\tVariable.VArray = Variable\r\n\t\tVariable.VPromised = Variable\r\n\t\tVariable.deny = deny\r\n\t\tVariable.noChange = noChange\r\n\t\tfunction addFlag(name) {\r\n\t\t\tVariable[name] = function(functionValue) {\r\n\t\t\t\tfunctionValue[name] = true\r\n\t\t\t}\r\n\t\t}\r\n\t\taddFlag(Variable, 'handlesContext')\r\n\t\taddFlag(Variable, 'handlesPromises')\r\n\t\r\n\t\tfunction objectUpdated(object) {\r\n\t\t\t// simply notifies any subscribers to an object, that it has changed\r\n\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\tif (listeners) {\r\n\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\tlisteners[i]._propertyChange(null, object)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction all(array) {\r\n\t\t\t// This is intended to mirror Promise.all. It actually takes\r\n\t\t\t// an iterable, but for now we are just looking for array-like\r\n\t\t\tif (array.length > -1) {\r\n\t\t\t\treturn new Composite(array)\r\n\t\t\t}\r\n\t\t\tif (arguments.length > 1) {\r\n\t\t\t\t// support multiple arguments as an array\r\n\t\t\t\treturn new Composite(arguments)\r\n\t\t\t}\r\n\t\t\tif (typeof array === 'object') {\r\n\t\t\t\t// allow an object as a hash to be mapped\r\n\t\t\t\tvar keyMapping = []\r\n\t\t\t\tvar valueArray = []\r\n\t\t\t\tfor (var key in array) {\r\n\t\t\t\t\tkeyMapping.push(key)\r\n\t\t\t\t\tvalueArray.push(array[key])\r\n\t\t\t\t}\r\n\t\t\t\treturn new Variable(function(results) {\r\n\t\t\t\t\tvar resultObject = {}\r\n\t\t\t\t\tfor (var i = 0; i < results.length; i++) {\r\n\t\t\t\t\t\tresultObject[keyMapping[i]] = results[i]\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn resultObject\r\n\t\t\t\t}).apply(null, valueArray)\r\n\t\t\t}\r\n\t\t\tthrow new TypeError('Variable.all requires an array')\r\n\t\t}\r\n\t\r\n\t\tfunction hasOwn(Target, createForInstance) {\r\n\t\r\n\t\t\tvar ownedClasses = this.ownedClasses || (this.ownedClasses = new WeakMap())\r\n\t\t\t// TODO: assign to super classes\r\n\t\t\tvar Class = this\r\n\t\t\townedClasses.set(Target, createForInstance || function() { return new Target() })\r\n\t\t\treturn this\r\n\t\t}\r\n\t\tfunction getForClass(subject, Target) {\r\n\t\t\tvar createInstance = subject.constructor.ownedClasses && subject.constructor.ownedClasses.get(Target)\r\n\t\t\tif (createInstance) {\r\n\t\t\t\tvar ownedInstances = subject.ownedInstances || (subject.ownedInstances = new WeakMap())\r\n\t\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\t\tif (!instance) {\r\n\t\t\t\t\townedInstances.set(Target, instance = createInstance(subject))\r\n\t\t\t\t\tinstance.subject = subject\r\n\t\t\t\t}\r\n\t\t\t\treturn instance\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction generalizeClass() {\r\n\t\t\tvar prototype = this.prototype\r\n\t\t\tvar prototypeNames = Object.getOwnPropertyNames(prototype)\r\n\t\t\tfor(var i = 0, l = prototypeNames.length; i < l; i++) {\r\n\t\t\t\tvar name = prototypeNames[i]\r\n\t\t\t\tObject.defineProperty(this, name, getGeneralizedDescriptor(Object.getOwnPropertyDescriptor(prototype, name), name, this))\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction getGeneralizedDescriptor(descriptor, name, Class) {\r\n\t\t\tif (typeof descriptor.value === 'function') {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tvalue: generalizeMethod(Class, name)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn descriptor\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction generalizeMethod(Class, name) {\r\n\t\t\t// I think we can just rely on `this`, but we could use the argument:\r\n\t\t\t// function(possibleEvent) {\r\n\t\t\t// \tvar target = possibleEvent && possibleEvent.target\r\n\t\t\tvar method = Class[name] = function() {\r\n\t\t\t\tvar instance = Class.for(this)\r\n\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t}\r\n\t\t\tmethod.for = function(context) {\r\n\t\t\t\tvar instance = Class.for(context)\r\n\t\t\t\treturn function() {\r\n\t\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn method\r\n\t\t}\r\n\t\r\n\t\tvar defaultContext = {\r\n\t\t\tname: 'Default context',\r\n\t\t\tdescription: 'This object is the default context for classes, corresponding to a singleton instance of that class',\r\n\t\t\tconstructor: {\r\n\t\t\t\tgetForClass: function(subject, Class) {\r\n\t\t\t\t\treturn Class.defaultInstance\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcontains: function() {\r\n\t\t\t\treturn true // contains everything\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction instanceForContext(Class, context) {\r\n\t\t\tif (!context) {\r\n\t\t\t\treturn Class.defaultInstance\r\n\t\t\t}\r\n\t\t\treturn context.specify(Class)\r\n\t//\t\tvar instance = context.subject.constructor.getForClass && context.subject.constructor.getForClass(context.subject, Class) || Class.defaultInstance\r\n\t//\t\tcontext.distinctSubject = mergeSubject(context.distinctSubject, instance.subject)\r\n\t//\t\treturn instance\r\n\t\t}\r\n\t\t// a variable inheritance change goes through its own prototype, so classes/constructor\r\n\t\t// can be used as variables as well\r\n\t\tfor (var key in VariablePrototype) {\r\n\t\t\tObject.defineProperty(Variable, key, Object.getOwnPropertyDescriptor(VariablePrototype, key))\r\n\t\t}\r\n\t\tVariable.valueOf = function(context) {\r\n\t\t\t// contextualized getValue\r\n\t\t\treturn instanceForContext(this, context).valueOf(context)\r\n\t\t}\r\n\t\tVariable.put = function(value, context) {\r\n\t\t\t// contextualized setValue\r\n\t\t\treturn instanceForContext(this, context).put(value, context)\r\n\t\t}\r\n\t\tVariable.for = function(subject) {\r\n\t\t\tif (subject != null) {\r\n\t\t\t\tif (subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t\t// makes HTML events work\r\n\t\t\t\t\tsubject = subject.target\r\n\t\t\t\t}\r\n\t\t\t\tvar instance\r\n\t\t\t\tinstance = new Context(subject).specify(this)\r\n\t\t\t\tif (instance && !instance.subject) {\r\n\t\t\t\t\tinstance.subject = subject\r\n\t\t\t\t}\r\n\t\t\t\t// TODO: Do we have a global context that we set on defaultInstance?\r\n\t\t\t\treturn instance || this.defaultInstance\r\n\t\t\t} else {\r\n\t\t\t\treturn this.defaultInstance\r\n\t\t\t}\r\n\t\t}\r\n\t\tVariable.from = function(value) {\r\n\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\t// a plain object, we use our own map to retrieve the instance (or create one)\r\n\t\t\t\tvar instanceMap = this.instanceMap || (this.instanceMap = new WeakMap())\r\n\t\t\t\tvar instance = instanceMap.get(value)\r\n\t\t\t\tif (!instance) {\r\n\t\t\t\t\tinstanceMap.set(value, instance = new this(value))\r\n\t\t\t\t}\r\n\t\t\t\treturn instance\r\n\t\t\t} else {\r\n\t\t\t\t// a primitive, just unconditionally create a new variable for it\r\n\t\t\t\treturn new this(value)\r\n\t\t\t}\r\n\t\t}\r\n\t\tVariable.notifies = function(target) {\r\n\t\t\tthis.defaultInstance.notifies(target)\r\n\t\t}\r\n\t\tVariable.stopNotifies = function(target) {\r\n\t\t\tthis.defaultInstance.stopNotifies(target)\r\n\t\t}\r\n\t\tVariable.getCollectionOf = function () {\r\n\t\t\treturn this.collectionOf\r\n\t\t}\r\n\t\tVariable.updated = function(updateEvent, by, context) {\r\n\t\t\treturn instanceForContext(this, context).updated(updateEvent, by, context)\r\n\t\t}\r\n\t\tObject.defineProperty(Variable, 'collectionOf', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn this._collectionOf\r\n\t\t\t},\r\n\t\t\tset: function(ItemClass) {\r\n\t\t\t\tif (this._collectionOf != ItemClass) {\r\n\t\t\t\t\tthis._collectionOf = ItemClass\r\n\t\t\t\t\tItemClass.collection = this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tObject.defineProperty(Variable, 'collection', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn this._collection\r\n\t\t\t},\r\n\t\t\tset: function(Collection) {\r\n\t\t\t\tif (this._collection != Collection) {\r\n\t\t\t\t\tthis._collection = Collection\r\n\t\t\t\t\tCollection.collectionOf = this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.Context = Context\r\n\t\tVariable.NotifyingContext = NotifyingContext\r\n\t\tVariable.generalize = generalizeClass\r\n\t\tVariable.call = Function.prototype.call // restore these\r\n\t\tVariable.apply = Function.prototype.apply\r\n\t\tVariable.extend = function(properties) {\r\n\t\t\t// TODO: handle arguments\r\n\t\t\tvar Base = this\r\n\t\t\tfunction ExtendedVariable() {\r\n\t\t\t\tif (this instanceof ExtendedVariable) {\r\n\t\t\t\t\tBase.apply(this, arguments)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn ExtendedVariable.extend(properties)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar prototype = ExtendedVariable.prototype = Object.create(this.prototype)\r\n\t\t\tExtendedVariable.prototype.constructor = ExtendedVariable\r\n\t\t\tsetPrototypeOf(ExtendedVariable, this)\r\n\t\t\tfor (var key in properties) {\r\n\t\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t\tObject.defineProperty(ExtendedVariable, key, getGeneralizedDescriptor(descriptor, key, ExtendedVariable))\r\n\t\t\t}\r\n\t\t\tif (properties && properties.hasOwn) {\r\n\t\t\t\thasOwn.call(ExtendedVariable, properties.hasOwn)\r\n\t\t\t}\r\n\t\t\treturn ExtendedVariable\r\n\t\t}\r\n\t\tObject.defineProperty(Variable, 'defaultInstance', {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn this.hasOwnProperty('_defaultInstance') ?\r\n\t\t\t\t\tthis._defaultInstance : (\r\n\t\t\t\t\t\tthis._defaultInstance = new this(),\r\n\t\t\t\t\t\tthis._defaultInstance.subject = defaultContext,\r\n\t\t\t\t\t\tthis._defaultInstance)\r\n\t\t\t}\r\n\t\t})\r\n\t\tVariable.hasOwn = function(Target, createInstance) {\r\n\t\t\tvar instanceMap = new WeakMap()\r\n\t\t\tinstanceMap.createInstance = createInstance\r\n\t\t\tvar subjectMap = this.ownedClasses || (this.ownedClasses = new WeakMap())\r\n\t\t\tsubjectMap.set(Target, instanceMap)\r\n\t\t}\r\n\t\r\n\t\tVariable.all = all\r\n\t\tVariable.objectUpdated = objectUpdated\r\n\t\r\n\t\treturn Variable\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\r\n\t\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\t\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\t\tvar hasFeatures = {\r\n\t\t\trequestAnimationFrame: typeof requestAnimationFrame != 'undefined',\r\n\t\t\tdefineProperty: Object.defineProperty && (function() {\r\n\t\t\t\ttry{\r\n\t\t\t\t\tObject.defineProperty({}, 't', {})\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}catch(e) {\r\n\t\t\t\t}\r\n\t\t\t})(),\r\n\t\t\tpromise: typeof Promise !== 'undefined',\r\n\t\t\tMutationObserver: typeof MutationObserver !== 'undefined',\r\n\t\t\t'WeakMap': typeof WeakMap === 'function'\r\n\t\t}\r\n\t\tfunction has(feature) {\r\n\t\t\treturn hasFeatures[feature]\r\n\t\t}\r\n\t\t// This is an polyfill for Object.observe with just enough functionality\r\n\t\t// for what Variables need\r\n\t\t// An observe function, with polyfile\r\n\t\tvar observe =\r\n\t\t\thas('defineProperty') ? \r\n\t\t\tfunction observe(target, listener) {\r\n\t\t\t\t/*for(var i in target) {\r\n\t\t\t\t\taddKey(i)\r\n\t\t\t\t}*/\r\n\t\t\t\tlistener.addKey = addKey\r\n\t\t\t\tlistener.remove = function() {\r\n\t\t\t\t\tlistener = null\r\n\t\t\t\t}\r\n\t\t\t\treturn listener\r\n\t\t\t\tfunction addKey(key) {\r\n\t\t\t\t\tvar keyFlag = 'key' + key\r\n\t\t\t\t\tif(this[keyFlag]) {\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthis[keyFlag] = true\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar currentValue = target[key]\r\n\t\t\t\t\tvar targetAncestor = target\r\n\t\t\t\t\tvar descriptor\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(targetAncestor, key)\r\n\t\t\t\t\t} while(!descriptor && (targetAncestor = getPrototypeOf(targetAncestor)))\r\n\t\r\n\t\t\t\t\tif(descriptor && descriptor.set) {\r\n\t\t\t\t\t\tvar previousSet = descriptor.set\r\n\t\t\t\t\t\tvar previousGet = descriptor.get\r\n\t\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\t\treturn (currentValue = previousGet.call(this))\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\t\tpreviousSet.call(this, value)\r\n\t\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tenumerable: descriptor.enumerable\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\t\treturn currentValue\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tenumerable: !descriptor || descriptor.enumerable\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} :\r\n\t\t\t// and finally a polling-based solution, for the really old browsers\r\n\t\t\tfunction(target, listener) {\r\n\t\t\t\tif(!timerStarted) {\r\n\t\t\t\t\ttimerStarted = true\r\n\t\t\t\t\tsetInterval(function() {\r\n\t\t\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\t\t\tdiff(watchedCopies[i], watchedObjects[i], listeners[i])\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, 20)\r\n\t\t\t\t}\r\n\t\t\t\tvar copy = {}\r\n\t\t\t\tfor(var i in target) {\r\n\t\t\t\t\tif(target.hasOwnProperty(i)) {\r\n\t\t\t\t\t\tcopy[i] = target[i]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\twatchedObjects.push(target)\r\n\t\t\t\twatchedCopies.push(copy)\r\n\t\t\t\tlisteners.push(listener)\r\n\t\t\t}\r\n\t\tvar queuedListeners\r\n\t\tfunction queue(listener, object, name) {\r\n\t\t\tif(queuedListeners) {\r\n\t\t\t\tif(queuedListeners.indexOf(listener) === -1) {\r\n\t\t\t\t\tqueuedListeners.push(listener)\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tqueuedListeners = [listener]\r\n\t\t\t\tlang.nextTurn(function() {\r\n\t\t\t\t\tqueuedListeners.forEach(function(listener) {\r\n\t\t\t\t\t\tvar events = []\r\n\t\t\t\t\t\tlistener.properties.forEach(function(property) {\r\n\t\t\t\t\t\t\tevents.push({target: listener.object, name: property})\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\tlistener(events)\r\n\t\t\t\t\t\tlistener.object = null\r\n\t\t\t\t\t\tlistener.properties = null\r\n\t\t\t\t\t})\r\n\t\t\t\t\tqueuedListeners = null\r\n\t\t\t\t}, 0)\r\n\t\t\t}\r\n\t\t\tlistener.object = object\r\n\t\t\tvar properties = listener.properties || (listener.properties = [])\r\n\t\t\tif(properties.indexOf(name) === -1) {\r\n\t\t\t\tproperties.push(name)\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar unobserve = has('observe') ? Object.unobserve :\r\n\t\t\tfunction(target, listener) {\r\n\t\t\t\tif(listener.remove) {\r\n\t\t\t\t\tlistener.remove()\r\n\t\t\t\t}\r\n\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\tif(watchedObjects[i] === target && listeners[i] === listener) {\r\n\t\t\t\t\t\twatchedObjects.splice(i, 1)\r\n\t\t\t\t\t\twatchedCopies.splice(i, 1)\r\n\t\t\t\t\t\tlisteners.splice(i, 1)\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\tvar watchedObjects = []\r\n\t\tvar watchedCopies = []\r\n\t\tvar listeners = []\r\n\t\tvar timerStarted = false\r\n\t\tfunction diff(previous, current, callback) {\r\n\t\t\t// TODO: keep an array of properties for each watch for faster iteration\r\n\t\t\tvar queued\r\n\t\t\tfor(var i in previous) {\r\n\t\t\t\tif(previous.hasOwnProperty(i) && previous[i] !== current[i]) {\r\n\t\t\t\t\t// a property has changed\r\n\t\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor(var i in current) {\r\n\t\t\t\tif(current.hasOwnProperty(i) && !previous.hasOwnProperty(i)) {\r\n\t\t\t\t\t// a property has been added\r\n\t\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(queued) {\r\n\t\t\t\tcallback(queued)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar id = 1\r\n\t\t// a function that returns a function, to stop JSON serialization of an\r\n\t\t// object\r\n\t\tfunction toJSONHidden() {\r\n\t\t\treturn toJSONHidden\r\n\t\t}\r\n\t\t// An object that will be hidden from JSON serialization\r\n\t\tvar Hidden = function () {\r\n\t\t}\r\n\t\tHidden.prototype.toJSON = toJSONHidden\r\n\t\r\n\t\tvar lang = {\r\n\t\t\trequestAnimationFrame: has('requestAnimationFrame') ? requestAnimationFrame :\r\n\t\t\t\t(function() {\r\n\t\t\t\t\tvar toRender = []\r\n\t\t\t\t\tvar queued = false\r\n\t\t\t\t\tfunction processAnimationFrame() {\r\n\t\t\t\t\t\tfor (var i = 0; i < toRender.length; i++) {\r\n\t\t\t\t\t\t\ttoRender[i]()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoRender = []\r\n\t\t\t\t\t\tqueued = false\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfunction requestAnimationFrame(renderer) {\r\n\t\t\t\t\t \tif (!queued) {\r\n\t\t\t\t\t\t\tsetTimeout(processAnimationFrame)\r\n\t\t\t\t\t\t\tqueued = true\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoRender.push(renderer)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn requestAnimationFrame\r\n\t\t\t\t})(),\r\n\t\t\tPromise: has('promise') ? Promise : (function() {\r\n\t\t\t\tfunction Promise(execute) {\r\n\t\t\t\t\tvar isResolved, resolution, errorResolution\r\n\t\t\t\t\tvar queue = 0\r\n\t\t\t\t\tfunction resolve(value) {\r\n\t\t\t\t\t\t// resolve function\r\n\t\t\t\t\t\tif(value && value.then) {\r\n\t\t\t\t\t\t\t// received a promise, wait for it\r\n\t\t\t\t\t\t\tvalue.then(resolve, reject)\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tresolution = value\r\n\t\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfunction reject(error) {\r\n\t\t\t\t\t\t// reject function\r\n\t\t\t\t\t\terrorResolution = error\r\n\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t}\r\n\t\t\t\t\texecute(resolve, reject)\r\n\t\t\t\t\tfunction finished() {\r\n\t\t\t\t\t\tisResolved = true\r\n\t\t\t\t\t\tfor(var i = 0, l = queue.length; i < l; i++) {\r\n\t\t\t\t\t\t\tqueue[i]()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// clean out the memory\r\n\t\t\t\t\t\tqueue = 0\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tthen: function(callback, errback) {\r\n\t\t\t\t\t\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\t\t\t\t\t\tfunction handle() {\r\n\t\t\t\t\t\t\t\t\t// promise fulfilled, call the appropriate callback\r\n\t\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\t\tif(errorResolution && !errback) {\r\n\t\t\t\t\t\t\t\t\t\t\t// errors without a handler flow through\r\n\t\t\t\t\t\t\t\t\t\t\treject(errorResolution)\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t// resolve to the callback's result\r\n\t\t\t\t\t\t\t\t\t\t\tresolve(errorResolution ?\r\n\t\t\t\t\t\t\t\t\t\t\t\terrback(errorResolution) :\r\n\t\t\t\t\t\t\t\t\t\t\t\tcallback ?\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(resolution) : resolution)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}catch(newError) {\r\n\t\t\t\t\t\t\t\t\t\t// caught an error, reject the returned promise\r\n\t\t\t\t\t\t\t\t\t\treject(newError)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif(isResolved) {\r\n\t\t\t\t\t\t\t\t\t// already resolved, immediately handle\r\n\t\t\t\t\t\t\t\t\thandle()\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t(queue || (queue = [])).push(handle)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn Promise\r\n\t\t\t}()),\r\n\t\r\n\t\t\tWeakMap: has('WeakMap') ? WeakMap :\r\n\t\t \tfunction (values, name) {\r\n\t\t \t\tvar mapProperty = '__' + (name || '') + id++\r\n\t\t \t\treturn has('defineProperty') ?\r\n\t\t \t\t{\r\n\t\t \t\t\tget: function (key) {\r\n\t\t \t\t\t\treturn key[mapProperty]\r\n\t\t \t\t\t},\r\n\t\t \t\t\tset: function (key, value) {\r\n\t\t \t\t\t\tObject.defineProperty(key, mapProperty, {\r\n\t\t \t\t\t\t\tvalue: value,\r\n\t\t \t\t\t\t\tenumerable: false\r\n\t\t \t\t\t\t})\r\n\t\t \t\t\t}\r\n\t\t \t\t} :\r\n\t\t \t\t{\r\n\t\t \t\t\tget: function (key) {\r\n\t\t \t\t\t\tvar intermediary = key[mapProperty]\r\n\t\t \t\t\t\treturn intermediary && intermediary.value\r\n\t\t \t\t\t},\r\n\t\t \t\t\tset: function (key, value) {\r\n\t\t \t\t\t\t// we use an intermediary that is hidden from JSON serialization, at least\r\n\t\t \t\t\t\tvar intermediary = key[mapProperty] || (key[mapProperty] = new Hidden())\r\n\t\t \t\t\t\tintermediary.value = value\r\n\t\t \t\t\t}\r\n\t\t \t\t}\r\n\t\t \t},\r\n\t\r\n\t\t\tobserve: observe,\r\n\t\t\tunobserve: unobserve,\r\n\t\t\twhen: function(value, callback, errorHandler) {\r\n\t\t\t\treturn value && value.then ?\r\n\t\t\t\t\t(value.then(callback, errorHandler) || value) : callback(value)\r\n\t\t\t},\r\n\t\t\twhenAll: function(inputs, callback) {\r\n\t\t\t\tvar promiseInvolved\r\n\t\t\t\tfor(var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\tif(inputs[i] && inputs[i].then) {\r\n\t\t\t\t\t\tpromiseInvolved = true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(promiseInvolved) {\r\n\t\t\t\t\t// we have asynch inputs, do lazy loading\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tthen: function(onResolve, onError) {\r\n\t\t\t\t\t\t\tvar remaining = 1\r\n\t\t\t\t\t\t\tvar result\r\n\t\t\t\t\t\t\tvar readyInputs = []\r\n\t\t\t\t\t\t\tvar lastPromiseResult\r\n\t\t\t\t\t\t\tfor(var i = 0; i < inputs.length; i++) {\r\n\t\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\t\tremaining++\r\n\t\t\t\t\t\t\t\tif(input && input.then) {\r\n\t\t\t\t\t\t\t\t\t(function(i, previousPromiseResult) {\r\n\t\t\t\t\t\t\t\t\t\tlastPromiseResult = input.then(function(value) {\r\n\t\t\t\t\t\t\t\t\t\t\treadyInputs[i] = value\r\n\t\t\t\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn previousPromiseResult\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}, onError)\r\n\t\t\t\t\t\t\t\t\t})(i, lastPromiseResult)\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\treadyInputs[i] = input\r\n\t\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\tfunction onEach() {\r\n\t\t\t\t\t\t\t\tremaining--\r\n\t\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\t\tresult = onResolve(callback(readyInputs))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn lastPromiseResult\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tinputs: inputs\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// just sync inputs\r\n\t\t\t\treturn callback(inputs)\r\n\t\r\n\t\t\t},\r\n\t\t\tcompose: function(Base, constructor, properties) {\r\n\t\t\t\tvar prototype = constructor.prototype = Object.create(Base.prototype)\r\n\t\t\t\tsetPrototypeOf(constructor, Base)\r\n\t\t\t\tfor(var i in properties) {\r\n\t\t\t\t\tprototype[i] = properties[i]\r\n\t\t\t\t}\r\n\t\t\t\tprototype.constructor = constructor\r\n\t\t\t\treturn constructor\r\n\t\t\t},\r\n\t\t\tnextTurn: has('MutationObserver') ?\r\n\t\t\t\tfunction (callback) {\r\n\t\t\t\t\t// promises don't resolve consistently on the next micro turn (Edge doesn't do it right),\r\n\t\t\t\t\t// so use mutation observer\r\n\t\t\t\t\t// TODO: make a faster mode that doesn't recreate each time\r\n\t\t\t\t\tvar div = document.createElement('div')\r\n\t\t\t\t\tvar observer = new MutationObserver(callback)\r\n\t\t\t\t\tobserver.observe(div, {\r\n\t\t\t\t\t\tattributes: true\r\n\t\t\t\t\t})\r\n\t\t\t\t\tdiv.setAttribute('a', id++)\r\n\t\t\t\t} :\r\n\t\t\t\tfunction (callback) {\r\n\t\t\t\t\t// TODO: we can do better for other, older browsers\r\n\t\t\t\t\tsetTimeout(callback, 0)\r\n\t\t\t\t},\r\n\t\t\tcopy: Object.assign || function(target, source) {\r\n\t\t\t\tfor(var i in source) {\r\n\t\t\t\t\ttarget[i] = source[i]\r\n\t\t\t\t}\r\n\t\t\t\treturn target\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction isGenerator(func) {\r\n\t\t\tif (typeof func === 'function') {\r\n\t\t\t\tvar constructor = func.constructor\r\n\t\t\t\t// this is used to handle both native generators and transpiled generators\r\n\t\t\t\treturn (constructor.displayName || constructor.name) === 'GeneratorFunction'\r\n\t\t\t}\r\n\t\t}\r\n\t\tlang.isGenerator = isGenerator\r\n\t\treturn lang\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (lang, Variable) {\r\n\t\tvar doc = typeof document !== 'undefined' && document\r\n\t\tvar invalidatedElements\r\n\t\tvar queued\r\n\t\tvar toRender = []\r\n\t\tvar nextId = 1\r\n\t\tvar requestAnimationFrame = lang.requestAnimationFrame\r\n\t\tvar Context = Variable.Context\r\n\t\r\n\t\tfunction Renderer(options) {\r\n\t\t\tvar variable = options.variable\r\n\t\r\n\t\t\tthis.variable = variable\r\n\t\t\tif (options.selector) {\r\n\t\t\t\tthis.selector = options.selector\r\n\t\t\t}\r\n\t\t\tif (options.elements) {\r\n\t\t\t\tthis.elements = options.elements\r\n\t\t\t\tthis.element = this.elements[0]\r\n\t\t\t\tfor(var i = 0, l = this.elements.length; i < l; i++) {\r\n\t\t\t\t\t(this.elements[i].alkaliRenderers || (this.elements[i].alkaliRenderers = [])).push(this)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (options.element) {\r\n\t\t\t\tvar element = this.element = options.element;\r\n\t\t\t\t(element.alkaliRenderers || (element.alkaliRenderers = [])).push(this)\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('No element provided to Renderer')\r\n\t\t\t}\r\n\t\t\tif (options.update) {\r\n\t\t\t\tthis.updateRendering = options.update\r\n\t\t\t}\r\n\t\t\tif (options.shouldRender) {\r\n\t\t\t\tthis.shouldRender = options.shouldRender\r\n\t\t\t}\r\n\t\t\tif (options.renderUpdate) {\r\n\t\t\t\tthis.renderUpdate = options.renderUpdate\r\n\t\t\t}\r\n\t\t\tif (options.alwaysUpdate) {\r\n\t\t\t\tthis.alwaysUpdate = options.alwaysUpdate\r\n\t\t\t}\r\n\t\t\tif (!variable.updated) {\r\n\t\t\t\t// baconjs-esqe API\r\n\t\t\t\tvar renderer = this\r\n\t\t\t\tvariable.subscribe(function (event) {\r\n\t\t\t\t\t// replace the variable with an object\r\n\t\t\t\t\t// that returns the value from the event\r\n\t\t\t\t\trenderer.variable = {\r\n\t\t\t\t\t\tvalueOf: function () {\r\n\t\t\t\t\t\t\treturn event.value()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\trenderer.updated()\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (options.updateOnStart === false){\r\n\t\t\t\t// even if we don't render on start, we still need to compute the value so we can depend on the computed variables\r\n\t\t\t\tthis.variable.valueOf(this)\r\n\t\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t\t// TODO: we may need to handle recontextualization if it returns a promise\r\n\t\t\t\tcontextualized.notifies(this)\r\n\t\t\t} else {\r\n\t\t\t\tthis.updateRendering(true)\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.prototype = {\r\n\t\t\tconstructor: Renderer,\r\n\t\t\tupdateRendering: function () {\r\n\t\t\t\tthrow new Error ('updateRendering must be implemented by sub class of Renderer')\r\n\t\t\t},\r\n\t\t\tupdated: function (updateEvent, by, context) {\r\n\t\t\t\tif (!this.invalidated) {\r\n\t\t\t\t\tif (!context || this.contextMatches(context)) {\r\n\t\t\t\t\t\t// do this only once, until we render again\r\n\t\t\t\t\t\tthis.invalidated = true\r\n\t\t\t\t\t\tvar renderer = this\r\n\t\t\t\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\t\t\t\tinvalidatedElements = null\r\n\t\t\t\t\t\t\trenderer.updateRendering(renderer.alwaysUpdate)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tnewContext: function() {\r\n\t\t\t\treturn new Variable.Context(this.element)\r\n\t\t\t},\r\n\t\t\taddInput: function(variable) {\r\n\t\t\t\tthis.contextualized = variable\r\n\t\t\t},\r\n\t\t\tgetContextualized: function() {\r\n\t\t\t\treturn this.contextualized\r\n\t\t\t},\r\n\t\t\tspecify: function(Variable) {\r\n\t\t\t\t// a new context to get thsi\r\n\t\t\t\treturn this.newContext().specify(Variable)\r\n\t\t\t},\r\n\t\t\tmerge: function(){\r\n\t\t\t\t// noop\r\n\t\t\t},\r\n\t\t\tcontextMatches: function(context) {\r\n\t\t\t\treturn true\r\n\t\t\t},\r\n\t\t\tinvalidateElement: function(element) {\r\n\t\t\t\tif(!invalidatedElements){\r\n\t\t\t\t\tinvalidatedElements = new WeakMap(null, 'invalidated')\r\n\t\t\t\t}\r\n\t\t\t\tvar invalidatedParts = invalidatedElements.get(element)\r\n\t\t\t\tinvalidatedElements.set(element, invalidatedParts = {})\r\n\t\t\t\tif (!invalidatedParts[id]) {\r\n\t\t\t\t\tinvalidatedParts[id] = true\r\n\t\t\t\t}\r\n\t\t\t\tif (!queued) {\r\n\t\t\t\t\tlang.queueTask(processQueue)\r\n\t\t\t\t\tqueued = true\r\n\t\t\t\t}\r\n\t\t\t\tvar renderer = this\r\n\t\t\t\ttoRender.push(function(){\r\n\t\t\t\t\trenderer.invalidated = false\r\n\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tgetId: function(){\r\n\t\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t\t},\r\n\t\t\tstop: function() {\r\n\t\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t\tcontextualized.stopNotifies(this)\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction ElementRenderer(options) {\r\n\t\t\tRenderer.call(this, options)\r\n\t\t}\r\n\t\tElementRenderer.prototype = Object.create(Renderer.prototype)\r\n\t\tElementRenderer.prototype.shouldRender = function (element) {\r\n\t\t\treturn document.body.contains(element)\r\n\t\t}\r\n\t\tElementRenderer.prototype.getSubject = function () {\r\n\t\t\treturn this.element\r\n\t\t}\r\n\t\tElementRenderer.prototype.updateRendering = function (always, element) {\r\n\t\t\tif (!element && this.elements) {\r\n\t\t\t\tvar elements = this.elements\r\n\t\t\t\tif(!elements.length){\r\n\t\t\t\t\tif(this.selector){\r\n\t\t\t\t\t\telements = document.querySelectorAll(this.selector)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthrow new Error('No element or selector was provided to the Renderer')\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tfor(var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\t\tthis.updateRendering(always, elements[i])\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar thisElement = element || this.element\r\n\t\r\n\t\t\t\tif(always || this.shouldRender(thisElement)){\r\n\t\t\t\t\t// it is connected\r\n\t\t\t\t\tthis.updateElement(thisElement)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar id = this.getId()\r\n\t\t\t\t\tvar renderers = thisElement.renderersOnShow\r\n\t\t\t\t\tif(!renderers){\r\n\t\t\t\t\t\trenderers = thisElement.renderersOnShow = []\r\n\t\t\t\t\t\tthisElement.className += ' needs-rerendering'\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!renderers[id]) {\r\n\t\t\t\t\t\trenderers[id] = this\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.addElement = function (element) {\r\n\t\t\tif (this.selector) {\r\n\t\t\t\telement.renderersOnShow = [this]\r\n\t\t\t} else {\r\n\t\t\t\tthis.elements.push(element)\r\n\t\t\t}\r\n\t\t\t// and immediately do an update\r\n\t\t\tthis.updateElement(element)\r\n\t\t}\r\n\t\tElementRenderer.prototype.updateElement = function(element) {\r\n\t\t\tthis.invalidated = false\r\n\t\t\ttry {\r\n\t\t\t\tif (!this.omitValueOf) {\r\n\t\t\t\t\tvar value = this.variable.valueOf(this)\r\n\t\t\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t\t\t// TODO: we may need to handle recontextualization if it returns a promise\r\n\t\t\t\t\tcontextualized.notifies(this)\r\n\t\t\t\t}\r\n\t\t\t} catch (error) {\r\n\t\t\t\telement.appendChild(document.createTextNode(error))\r\n\t\t\t}\r\n\t\t\tif(value !== undefined || this.started || this.omitValueOf){\r\n\t\t\t\tthis.started = true\r\n\t\t\t\tif(value && value.then){\r\n\t\t\t\t\tif(this.renderLoading){\r\n\t\t\t\t\t\tthis.renderLoading(value, element)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar renderer = this\r\n\t\t\t\t\tvalue.then(function (value) {\r\n\t\t\t\t\t\trenderer.renderUpdate(value, element)\r\n\t\t\t\t\t})\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.renderUpdate(value, element)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tthrow new Error('renderUpdate(newValue) must be implemented')\r\n\t\t}\r\n\t\tRenderer.Renderer = Renderer\r\n\t\tRenderer.ElementRenderer = ElementRenderer\r\n\t\r\n\t\tfunction AttributeRenderer(options) {\r\n\t\t\tif(options.name){\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tAttributeRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tAttributeRenderer.prototype.type = 'AttributeRenderer'\r\n\t\tAttributeRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement.setAttribute(this.name, newValue)\r\n\t\t}\r\n\t\tRenderer.AttributeRenderer = AttributeRenderer\r\n\t\r\n\t\tfunction PropertyRenderer(options) {\r\n\t\t\tif (options.name) {\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tPropertyRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tPropertyRenderer.prototype.type = 'PropertyRenderer'\r\n\t\tPropertyRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement[this.name] = newValue\r\n\t\t}\r\n\t\tRenderer.PropertyRenderer = PropertyRenderer\r\n\t\r\n\t\tfunction InputPropertyRenderer(options) {\r\n\t\t\tif (options.element && options.element.tagName === 'SELECT' && options.name === 'value') {\r\n\t\t\t\t// use the deferred value assignment for <select>\r\n\t\t\t\tthis.renderUpdate = this.renderSelectValueUpdate\r\n\t\t\t}\r\n\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tInputPropertyRenderer.prototype = Object.create(PropertyRenderer.prototype)\r\n\t\tInputPropertyRenderer.prototype.type = 'InputPropertyRenderer'\r\n\t\tInputPropertyRenderer.prototype.renderUpdate = function(newValue, element) {\r\n\t\t\tif (newValue == null || (element.type === 'number' && isNaN(newValue))) {\r\n\t\t\t\tnewValue = ''\r\n\t\t\t}\r\n\t\t\telement[this.name] = newValue\r\n\t\t}\r\n\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate = function (newValue, element) {\r\n\t\t\telement.value = newValue\r\n\t\t\tif (element.value != newValue && !element.value) {\r\n\t\t\t\t// if we didn't successfully set the value of a <select>, we may need to wait until the children are constructed\r\n\t\t\t\telement.eventualValue = newValue\r\n\t\t\t\tlang.nextTurn(function() {\r\n\t\t\t\t\tif (element.eventualValue) {\r\n\t\t\t\t\t\telement.value = element.eventualValue\r\n\t\t\t\t\t\telement.eventualValue = undefined\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\telement.eventualValue = undefined\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.InputPropertyRenderer = InputPropertyRenderer\r\n\t\r\n\t\tfunction StyleRenderer(options) {\r\n\t\t\tif(options.name){\r\n\t\t\t\tthis.name = options.name\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tStyleRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tStyleRenderer.prototype.type = 'StyleRenderer'\r\n\t\tStyleRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement.style[this.name] = newValue\r\n\t\t}\r\n\t\tRenderer.StyleRenderer = StyleRenderer\r\n\t\r\n\t\tfunction ContentRenderer(options) {\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tContentRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tContentRenderer.prototype.type = 'ContentRenderer'\r\n\t\tContentRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\telement.innerHTML = ''\r\n\t\t\tif (newValue === undefined){\r\n\t\t\t\tnewValue = ''\r\n\t\t\t}\r\n\t\t\telement.appendChild(document.createTextNode(newValue))\r\n\t\t}\r\n\t\tRenderer.ContentRenderer = ContentRenderer\r\n\t\r\n\t\tfunction TextRenderer(options) {\r\n\t\t\tthis.position = options.position\r\n\t\t\tthis.textNode = options.textNode\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tTextRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tTextRenderer.prototype.type = 'TextRenderer'\r\n\t\tTextRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\t\tif (this.builtList) {\r\n\t\t\t\tif (updateEvent.type === 'refresh') {\r\n\t\t\t\t\tthis.builtList = false\r\n\t\t\t\t\tthis.omitValueOf = false\r\n\t\t\t\t} else {\r\n\t\t\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t\t}\r\n\t\tTextRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tif (newValue == null){\r\n\t\t\t\tnewValue = ''\r\n\t\t\t}\r\n\t\t\tif (newValue.nodeType) {\r\n\t\t\t\tif (this.textNode && this.textNode.parentNode == element) {\r\n\t\t\t\t\t// text node is attached, we can replace it with the node\r\n\t\t\t\t\telement.replaceChild(newValue, this.textNode)\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.appendChild(newValue)\r\n\t\t\t\t}\r\n\t\t\t\tthis.textNode = newValue\r\n\t\t\t} else if (newValue instanceof Array) {\r\n\t\t\t\tthis.renderUpdate = ListRenderer.prototype.renderUpdate\r\n\t\t\t\tthis.omitValueOf = true\r\n\t\t\t\tthis.renderUpdate(newValue, element)\r\n\t\t\t} else {\r\n\t\t\t\t(this.textNode || element.childNodes[this.position]).nodeValue = newValue\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.TextRenderer = TextRenderer\r\n\t\r\n\t\tfunction ListRenderer(options) {\r\n\t\t\tif (options.each) {\r\n\t\t\t\tthis.each = options.each\r\n\t\t\t}\r\n\t\t\tElementRenderer.apply(this, arguments)\r\n\t\t}\r\n\t\tListRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\t\tListRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\t\tif (this.builtList) {\r\n\t\t\t\tif (updateEvent.type === 'refresh') {\r\n\t\t\t\t\tthis.builtList = false\r\n\t\t\t\t\tthis.omitValueOf = false\r\n\t\t\t\t} else {\r\n\t\t\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t\t}\r\n\t\tListRenderer.prototype.type = 'ListRenderer'\r\n\t\tListRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\t\tvar container\r\n\t\t\tvar each = this.each || function(item) { // TODO: make a single identity function\r\n\t\t\t\treturn item\r\n\t\t\t}\r\n\t\t\tvar thisElement = this.element\r\n\t\t\tvar renderer = this\r\n\t\t\tif (!this.builtList) {\r\n\t\t\t\tthis.builtList = true\r\n\t\t\t\tthis.omitValueOf = true\r\n\t\t\t\telement.innerHTML = ''\r\n\t\t\t\tcontainer = document.createDocumentFragment()\r\n\t\t\t\tvar childElements = this.childElements = []\r\n\t\t\t\tif (each.defineHasOwn) {\r\n\t\t\t\t\teach.defineHasOwn()\r\n\t\t\t\t}\r\n\t\t\t\tnewValue.forEach(function(item) {\r\n\t\t\t\t\teachItem(item)\r\n\t\t\t\t})\r\n\t\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t\tcontextualized.notifies(this)\r\n\t\r\n\t\t\t\tthisElement.appendChild(container)\r\n\t\t\t} else {\r\n\t\t\t\tvar childElements = this.childElements\r\n\t\t\t\tvar updates = this.updates\r\n\t\t\t\tcontainer = thisElement\r\n\t\t\t\tupdates.forEach(function(update) {\r\n\t\t\t\t\tif (update.type === 'refresh') {\r\n\t\t\t\t\t\trenderer.builtList = false\r\n\t\t\t\t\t\tfor (var i = 0, l = childElements.length; i < l; i++) {\r\n\t\t\t\t\t\t\tthisElement.removeChild(childElements[i])\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trenderer.renderUpdate()\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (update.previousIndex > -1) {\r\n\t\t\t\t\t\t\tthisElement.removeChild(childElements[update.previousIndex])\r\n\t\t\t\t\t\t\tchildElements.splice(update.previousIndex, 1)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (update.index > -1) {\r\n\t\t\t\t\t\t\tvar nextChild = childElements[update.index] || null\r\n\t\t\t\t\t\t\teachItem(update.value, update.index, nextChild)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tthis.updates = [] // clear the updates\r\n\t\t\t}\r\n\t\t\tfunction eachItem(item, index, nextChild) {\r\n\t\t\t\tvar childElement\r\n\t\t\t\tif (each.create) {\r\n\t\t\t\t\tchildElement = each.create({parent: thisElement, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t} else {\r\n\t\t\t\t\tchildElement = each(item, thisElement)\r\n\t\t\t\t\tif (childElement.create) {\r\n\t\t\t\t\t\tchildElement = childElement.create({parent: thisElement, _item: item})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (nextChild) {\r\n\t\t\t\t\tcontainer.insertBefore(childElement, nextChild)\r\n\t\t\t\t\tchildElements.splice(index, 0, childElement)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcontainer.appendChild(childElement)\r\n\t\t\t\t\tchildElements.push(childElement)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.ListRenderer = ListRenderer\r\n\t\r\n\t\tRenderer.onShowElement = function(shownElement){\r\n\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\tinvalidatedElements = null\r\n\t\t\t\tvar elements = [].slice.call(shownElement.getElementsByClassName('needs-rerendering'))\r\n\t\t\t\tif (shownElement.className.indexOf('needs-rerendering') > 0){\r\n\t\t\t\t\tvar includingTop = [shownElement]\r\n\t\t\t\t\tincludingTop.push.apply(includingTop, elements)\r\n\t\t\t\t\telements = includingTop\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\t\tvar element = elements[i]\r\n\t\t\t\t\tvar renderers = element.renderersOnShow\r\n\t\t\t\t\tif(renderers){\r\n\t\t\t\t\t\telement.renderersOnShow = null\r\n\t\t\t\t\t\t// remove needs-rerendering class\r\n\t\t\t\t\t\telement.className = element.className.replace(/\\s?needs\\-rerendering\\s?/g, '')\r\n\t\t\t\t\t\tfor (var id in renderers) {\r\n\t\t\t\t\t\t\tvar renderer = renderers[id]\r\n\t\t\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\r\n\t\tfunction onElementRemoval(element){\r\n\t\t\t// cleanup element renderers\r\n\t\t\tif(element.alkaliRenderers){\r\n\t\t\t\tvar renderers = element.alkaliRenderers\r\n\t\t\t\tfor(var i = 0; i < renderers.length; i++){\r\n\t\t\t\t\tvar renderer = renderers[i]\r\n\t\t\t\t\trenderer.variable.stopNotifies(renderer)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tRenderer.onElementRemoval = function(element, onlyChildren){\r\n\t\t\tif(!onlyChildren){\r\n\t\t\t\tonElementRemoval(element)\r\n\t\t\t}\r\n\t\t\tvar children = element.getElementsByTagName('*')\r\n\t\t\tfor(var i = 0, l = children.length; i < l; i++){\r\n\t\t\t\tvar child = children[i]\r\n\t\t\t\tif(child.alkaliRenderers){\r\n\t\t\t\t\tonElementRemoval(child)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn Renderer\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3), __webpack_require__(2), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = function (lang, Variable, operators) {\r\n\t\r\n\t  var isGenerator = lang.isGenerator\r\n\t  var ObjectTransform = lang.compose(Variable.Call, function ObjectTransform(transform, inputs) {\r\n\t    this.inputs = inputs\r\n\t    Variable.Call.apply(this, arguments)\r\n\t  }, {\r\n\t    _getAsObject: function() {\r\n\t      return this.transform.apply(this, preserveObjects(this.inputs))\r\n\t    }\r\n\t  })\r\n\t  function preserveObjects(inputs) {\r\n\t    for (var i = 0, l = inputs.length; i < l; i++) {\r\n\t      var input = inputs[i]\r\n\t      if (input && input._getAsObject) {\r\n\t        inputs[i] = input._getAsObject()\r\n\t      }\r\n\t    }\r\n\t    return inputs\r\n\t  }\r\n\t\tfunction react(generator, options) {\r\n\t    if (typeof generator !== 'function') {\r\n\t      throw new Error('react() must be called with a generator. You need to use the babel-plugin-transform-alkali plugin if you want to use reactive expressions')\r\n\t    }\r\n\t\t\tif (options && options.reverse) {\r\n\t\t\t\tgenerator.reverse = options.reverse\r\n\t\t\t}\r\n\t\t\treturn new Variable.GeneratorVariable(generator)\r\n\t\t}\r\n\t  Object.assign(react, operators)\r\n\t  react.from = function(value, options) {\r\n\t    if (value && value.property) {\r\n\t      return value\r\n\t    }\r\n\t    if (typeof value === 'function' && isGenerator(value)) {\r\n\t      return react(value, options)\r\n\t    }\r\n\t    return Variable.from(value)\r\n\t  }\r\n\t  react.prop = function(object, property) {\r\n\t    if (object) {\r\n\t      // TODO: Use a static set of public methods/properties that can be accessed\r\n\t      if (object.property) {\r\n\t        // it is a variable already, but check to see if we are using a method/property directly on the variable\r\n\t        var directPropertyValue = object[property]\r\n\t        return directPropertyValue !== undefined ? directPropertyValue : object.property(property)\r\n\t      }\r\n\t      return object[property]\r\n\t    }\r\n\t    // not even truthy, return undefined\r\n\t  }\r\n\t  react.cond = function(test, consequent, alternate) {\r\n\t    return operators.if(test, operators.choose(consequent, alternate))\r\n\t  }\r\n\t  react.fcall = function(target, args) {\r\n\t    if (target.property && typeof target === 'function') {\r\n\t      return target.apply(null, preserveObjects(args))\r\n\t    }\r\n\t    return new Variable.Call(target, args)\r\n\t  }\r\n\t  react.mcall = function(target, key, args) {\r\n\t    var method = target[key]\r\n\t    if (typeof method === 'function' && method.property || key === 'bind') {\r\n\t      // for now we check to see if looks like it could handle a variable, or is a bind call\r\n\t      return method.apply(target, preserveObjects(args))\r\n\t    }\r\n\t    return new Variable.Call(target[key].bind(target), args)\r\n\t  }\r\n\t  react.ncall = function(target, args) {\r\n\t    if (target.property && typeof target === 'function') {\r\n\t      return new (target.bind.apply(target, [null].concat(preserveObjects(args))))()\r\n\t    }\r\n\t    return new Variable.Call(function() {\r\n\t      return new (target.bind.apply(target, [null].concat(arguments)))()\r\n\t    }, args)\r\n\t  }\r\n\t\r\n\t  react.obj = function(transform, inputs) {\r\n\t    return new ObjectTransform(transform, inputs)\r\n\t  }\r\n\t\r\n\t\treturn react\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Variable) {\r\n\t\tvar deny = Variable.deny;\r\n\t\tvar operatingFunctions = {};\r\n\t\tvar operators = {};\r\n\t\tfunction getOperatingFunction(expression){\r\n\t\t\t// jshint evil: true\r\n\t\t\treturn operatingFunctions[expression] ||\r\n\t\t\t\t(operatingFunctions[expression] =\r\n\t\t\t\t\tnew Function('a', 'b', 'deny', 'return ' + expression));\r\n\t\t}\r\n\t\tfunction operator(operator, name, precedence, forward, reverseA, reverseB){\r\n\t\t\t// defines the standard operators\r\n\t\t\tvar reverse = function(output, inputs){\r\n\t\t\t\tvar a = inputs[0],\r\n\t\t\t\t\tb = inputs[1];\r\n\t\t\t\tif(a && a.put){\r\n\t\t\t\t\tvar result = reverseA(output, b && b.valueOf());\r\n\t\t\t\t\tif(result !== deny){\r\n\t\t\t\t\t\ta.put(result);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else if(b && b.put){\r\n\t\t\t\t\tb.put(reverseB(output, a && a.valueOf()));\r\n\t\t\t\t}else{\r\n\t\t\t\t\treturn deny;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t// define a function that can lazily ensure the operating function\r\n\t\t\t// is available\r\n\t\t\tvar operatorHandler = {\r\n\t\t\t\tapply: function(instance, args){\r\n\t\t\t\t\tforward = getOperatingFunction(forward);\r\n\t\t\t\t\treverseA = reverseA && getOperatingFunction(reverseA);\r\n\t\t\t\t\treverseB = reverseB && getOperatingFunction(reverseB);\r\n\t\t\t\t\tforward.reverse = reverse;\r\n\t\t\t\t\toperators[operator] = operatorHandler = new Variable(forward);\r\n\t\r\n\t\t\t\t\taddFlags(operatorHandler);\r\n\t\t\t\t\targs = Array.prototype.slice.call(args);\r\n\t\t\t\t\targs.push(deny)\r\n\t\t\t\t\treturn operatorHandler.apply(instance, args);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tfunction addFlags(operatorHandler){\r\n\t\t\t\toperatorHandler.precedence = precedence;\r\n\t\t\t\toperatorHandler.infix = reverseB !== false;\r\n\t\t\t}\r\n\t\t\taddFlags(operatorHandler);\r\n\t\t\toperators[operator] = operatorHandler;\r\n\t\t\toperators[name] = function() {\r\n\t\t\t\treturn operatorHandler.apply(null, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\t// using order precedence from:\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n\t\toperator('+', 'add', 6, 'a+b', 'a-b', 'a-b');\r\n\t\toperator('-', 'subtract', 6, 'a-b', 'a+b', 'b-a');\r\n\t\toperator('*', 'multiply', 5, 'a*b', 'a/b', 'a/b');\r\n\t\toperator('/', 'divide', 5, 'a/b', 'a*b', 'b/a');\r\n\t//\toperator('^', 7, 'a^b', 'a^(-b)', 'Math.log(a)/Math.log(b)');\r\n\t\toperator('?', 'if', 16, 'b[a?0:1]', 'a===b[0]||(a===b[1]?false:deny)', '[a,b]');\r\n\t\toperator(':', 'choose', 15, '[a,b]', 'a[0]?a[1]:deny', 'a[1]');\r\n\t\toperator('!', 'not', 4, '!a', '!a', false);\r\n\t\toperator('%', 'remainder', 5, 'a%b');\r\n\t\toperator('>', 'greater', 8, 'a>b');\r\n\t\toperator('>=', 'greaterOrEqual', 8, 'a>=b');\r\n\t\toperator('<', 'less', 8, 'a<b');\r\n\t\toperator('<=', 'lessOrEqual', 8, 'a<=b');\r\n\t\toperator('===', 'looseEqual', 9, 'a===b');\r\n\t\toperator('==', 'equal', 9, 'a==b');\r\n\t\toperator('&', 'and', 8, 'a&&b');\r\n\t\toperator('|', 'or', 8, 'a||b');\r\n\t\toperator('round', 'round', 8, 'Math.round(a*Math.pow(10,b||1))/Math.pow(10,b||1)', 'a', 'a');\r\n\t\treturn operators;\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3), __webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (lang, Variable) {\r\n\t\r\n\t\tfunction deepCopy(source, target, derivativeMap) {\r\n\t\t\tif (source && typeof source == 'object') {\r\n\t\t\t\tif (source instanceof Array) {\r\n\t\t\t\t\ttarget = [] // always create a new array for array targets\r\n\t\t\t\t\tfor(var i = 0, l = source.length; i < l; i++) {\r\n\t\t\t\t\t\ttarget[i] = deepCopy(source[i], null, derivativeMap)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (!target || typeof target !== 'object') {\r\n\t\t\t\t\t\ttarget = derivativeMap && derivativeMap.get(source)\r\n\t\t\t\t\t\tif (!target) {\r\n\t\t\t\t\t\t\ttarget = {}\r\n\t\t\t\t\t\t\tderivativeMap && derivativeMap.set(source, target)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (var i in source) {\r\n\t\t\t\t\t\ttarget[i] = deepCopy(source[i], target[i], derivativeMap)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn target\r\n\t\t\t}\r\n\t\t\treturn source\r\n\t\t}\r\n\t\r\n\t\tvar Copy = lang.compose(Variable, function(copiedFrom) {\r\n\t\t\t// this is the variable that we derive from\r\n\t\t\tthis.copiedFrom = copiedFrom\r\n\t\t\tthis.derivativeMap = new lang.WeakMap(null, 'derivative')\r\n\t\t\tthis.isDirty = new Variable(false)\r\n\t\t}, {\r\n\t\t\tvalueOf: function(context) {\r\n\t\t\t\tif(this.state) {\r\n\t\t\t\t\tthis.state = null\r\n\t\t\t\t}\r\n\t\t\t\tvar value = this.copiedFrom.valueOf(context)\r\n\t\t\t\tif(value && typeof value == 'object') {\r\n\t\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t\t\tthis.setValue(derivative, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn derivative\r\n\t\t\t\t}\r\n\t\t\t\tvar thisValue = this.getValue ? this.getValue(context) : this.value\r\n\t\t\t\tif(thisValue === undefined) {\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\treturn thisValue\r\n\t\t\t},\r\n\t\t\tgetCopyOf: function(value) {\r\n\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t}\r\n\t\t\t\treturn derivative\r\n\t\t\t},\r\n\t\t\tsave: function() {\r\n\t\t\t\t// copy back to the original object\r\n\t\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\t\tvar newCopiedFrom = deepCopy(this.valueOf(), original)\r\n\t\t\t\tif (original !== newCopiedFrom) {\r\n\t\t\t\t\t// if we have replaced it with a new object/value, put it\r\n\t\t\t\t\tthis.copiedFrom.put && this.copiedFrom.put(newCopiedFrom)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// else we have modified an existing object, but we still need to notify\r\n\t\t\t\t\tif (this.copiedFrom.notifies && this.copiedFrom.updated) { // copiedFrom doesn't have to be a variable, it can be a plain object\r\n\t\t\t\t\t\tthis.copiedFrom.updated()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.isDirty.put(false)\r\n\t\t\t\tthis.onSave && this.onSave()\r\n\t\t\t},\r\n\t\t\trevert: function() {\r\n\t\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\t\tthis.put(deepCopy(original, this.derivativeMap.get(original), this.derivativeMap))\r\n\t\t\t\tthis.isDirty.put(false)\r\n\t\t\t},\r\n\t\t\tupdated: function() {\r\n\t\t\t\tthis.isDirty.put(true)\r\n\t\t\t\treturn Variable.prototype.updated.apply(this, arguments)\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn Copy\r\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** index.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap f26c36f42cdf4232fccc\n **/","/// <reference path=\"./index.d.ts\" />\r\nif (typeof define === 'function' && define.amd) {\r\ndefine(['./Element', './Variable', './react', './Renderer', './operators', './Copy'], function(Element, Variable, react, Renderer, operators, Copy) {\r\n\tvar main = Object.create(Element)\r\n\tmain.Copy = Copy\r\n\tmain.Element = Element\r\n\tmain.Variable = Variable\r\n\tmain.VMap = Variable.VMap\r\n\tmain.VArray = Variable.VArray\r\n\tmain.VPromised = Variable.VPromised\r\n\tmain.all = Variable.all\r\n\tmain.react = react\r\n\tmain.spawn = function(func) {\r\n\t\treturn react(func).valueOf()\r\n\t}\r\n\tmain.Renderer = Renderer\r\n\tObject.assign(main, Renderer)\r\n\tObject.assign(main, operators)\r\n\treturn main\r\n})\r\n} else if (typeof module === 'object' && module.exports) {\r\n\t// delegate to the built UMD file, if loaded in node\r\n\tmodule.exports = (require)('./dist/index')\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","define(['./Variable', './Renderer', './util/lang'], function (Variable, Renderer, lang) {\r\n\tvar knownElementProperties = [\r\n\t\t'textContent', // Node\r\n\t\t'id', 'className', 'innerHTML', // Element\r\n\t\t'title', 'lang', 'translate', 'dir', 'tabIndex', 'accessKey', 'draggable', 'spellcheck', 'contentEditable', 'innerText', 'webkitdropzone'] // HTMLElement\r\n\r\n\tvar SELECTOR_REGEX = /(\\.|#)([-\\w]+)(.+)?/\r\n\tvar isGenerator = lang.isGenerator\r\n\tvar Context = Variable.Context\r\n\tvar PropertyRenderer = Renderer.PropertyRenderer\r\n\tvar InputPropertyRenderer = Renderer.InputPropertyRenderer\r\n\tvar AttributeRenderer = Renderer.AttributeRenderer\r\n\tvar StyleRenderer = lang.compose(Renderer.StyleRenderer, function StyleRenderer() {\r\n\t\tRenderer.StyleRenderer.apply(this, arguments)\r\n\t}, {\r\n\t\trenderUpdate: function(newValue, element) {\r\n\t\t\tvar definition = styleDefinitions[this.name]\r\n\t\t\tif (definition) {\r\n\t\t\t\tdefinition(element, newValue, this.name)\r\n\t\t\t} else {\r\n\t\t\t\telement.style[this.name] = newValue\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tvar ClassNameRenderer = lang.compose(Renderer.ElementRenderer, function ClassNameRenderer(options) {\r\n\t\tthis.className = options.className\r\n\t\tRenderer.apply(this, arguments)\r\n\t}, {\r\n\t\trenderUpdate: function(newValue, element) {\r\n\t\t\tvar currentClassName = element.className\r\n\t\t\tvar changingClassName = this.className\r\n\t\t\t// remove the className (needed for addition or removal)\r\n\t\t\t// see http://jsperf.com/remove-class-name-algorithm/2 for some tests on this\r\n\t\t\tvar removed = currentClassName && (' ' + currentClassName + ' ').replace(' ' + changingClassName + ' ', ' ')\r\n\t\t\tif (newValue) {\r\n\t\t\t\t// addition, add the className\r\n\t\t\t\tchangingClassName = currentClassName ? (removed + changingClassName).slice(1) : changingClassName;\r\n\t\t\t} else {\r\n\t\t\t\t// we already have removed the class, just need to trim\r\n\t\t\t\tchangingClassName = removed.slice(1, removed.length - 1)\r\n\t\t\t}\r\n\t\t\t// only assign if it changed, this can save a lot of time\r\n\t\t\tif (changingClassName != currentClassName) {\r\n\t\t\t\telement.className = changingClassName\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\t// TODO: check for renderContent with text updater\r\n\tvar TextRenderer = Renderer.TextRenderer\r\n\tvar ListRenderer = Renderer.ListRenderer\r\n\r\n\tvar doc = typeof document !== 'undefined' ? document : {\r\n\t\tcreateElement: function(tag) {\r\n\t\t\treturn {}\r\n\t\t},\r\n\t\taddEventListener: function() {\r\n\t\t}\r\n\t}\r\n\r\n\tvar inputs = {\r\n\t\tINPUT: 1,\r\n\t\tTEXTAREA: 1\r\n\t\t// SELECT: 1, we exclude this, so the default \"content\" of the element can be the options\r\n\t}\r\n\r\n\tfunction booleanStyle(options) {\r\n\t\treturn function(element, value, key) {\r\n\t\t\tif (typeof value === 'boolean') {\r\n\t\t\t\t// has a boolean conversion\r\n\t\t\t\tvalue = options[value ? 0 : 1]\r\n\t\t\t}\r\n\t\t\telement.style[key] = value\r\n\t\t}\r\n\t}\r\n\r\n\tfunction defaultStyle(element, value, key) {\r\n\t\tif (typeof value === 'number') {\r\n\t\t\tvalue = value + 'px'\r\n\t\t}\r\n\t\telement.style[key] = value\r\n\t}\r\n\tfunction directStyle(element, value, key) {\r\n\t\telement.style[key] = value\r\n\t}\r\n\r\n\tvar styleDefinitions = {\r\n\t\tdisplay: booleanStyle(['', 'none']),\r\n\t\tvisibility: booleanStyle(['visible', 'hidden']),\r\n\t\tcolor: directStyle,\r\n\t\topacity: directStyle,\r\n\t\tzoom: directStyle,\r\n\t\tminZoom: directStyle,\r\n\t\tmaxZoom: directStyle,\r\n\t\tfontWeight: directStyle,\r\n\t\tposition: booleanStyle(['absolute', '']),\r\n\t\ttextDecoration: booleanStyle(['underline', '']),\r\n\t\tfontWeight: booleanStyle(['bold', 'normal'])\r\n\t}\r\n\t;[\"alignContent\",\"alignItems\",\"alignSelf\",\"animation\",\"animationDelay\",\"animationDirection\",\"animationDuration\",\"animationFillMode\",\"animationIterationCount\",\"animationName\",\"animationPlayState\",\"animationTimingFunction\",\"backfaceVisibility\",\"background\",\"backgroundAttachment\",\"backgroundBlendMode\",\"backgroundClip\",\"backgroundColor\",\"backgroundImage\",\"backgroundOrigin\",\"backgroundPosition\",\"backgroundPositionX\",\"backgroundPositionY\",\"backgroundRepeat\",\"backgroundRepeatX\",\"backgroundRepeatY\",\"backgroundSize\",\"baselineShift\",\"border\",\"borderBottom\",\"borderBottomColor\",\"borderBottomLeftRadius\",\"borderBottomRightRadius\",\"borderBottomStyle\",\"borderBottomWidth\",\"borderCollapse\",\"borderColor\",\"borderImage\",\"borderImageOutset\",\"borderImageRepeat\",\"borderImageSlice\",\"borderImageSource\",\"borderImageWidth\",\"borderLeft\",\"borderLeftColor\",\"borderLeftStyle\",\"borderLeftWidth\",\"borderRadius\",\"borderRight\",\"borderRightColor\",\"borderRightStyle\",\"borderRightWidth\",\"borderSpacing\",\"borderStyle\",\"borderTop\",\"borderTopColor\",\"borderTopLeftRadius\",\"borderTopRightRadius\",\"borderTopStyle\",\"borderTopWidth\",\"borderWidth\",\"bottom\",\"boxShadow\",\"boxSizing\",\"bufferedRendering\",\"captionSide\",\"clear\",\"clip\",\"clipPath\",\"clipRule\",\"color\",\"colorInterpolation\",\"colorInterpolationFilters\",\"colorRendering\",\"counterIncrement\",\"counterReset\",\"cursor\",\"direction\",\"display\",\"emptyCells\",\"fill\",\"fillOpacity\",\"fillRule\",\"filter\",\"flex\",\"flexBasis\",\"flexDirection\",\"flexFlow\",\"flexGrow\",\"flexShrink\",\"flexWrap\",\"float\",\"floodColor\",\"floodOpacity\",\"font\",\"fontFamily\",\"fontFeatureSettings\",\"fontKerning\",\"fontSize\",\"fontStretch\",\"fontStyle\",\"fontVariant\",\"fontVariantLigatures\",\"fontWeight\",\"height\",\"imageRendering\",\"isolation\",\"justifyContent\",\"left\",\"letterSpacing\",\"lightingColor\",\"lineHeight\",\"listStyle\",\"listStyleImage\",\"listStylePosition\",\"listStyleType\",\"margin\",\"marginBottom\",\"marginLeft\",\"marginRight\",\"marginTop\",\"marker\",\"markerEnd\",\"markerMid\",\"markerStart\",\"mask\",\"maskType\",\"maxHeight\",\"maxWidth\",\"maxZoom\",\"minHeight\",\"minWidth\",\"minZoom\",\"mixBlendMode\",\"motion\",\"motionOffset\",\"motionPath\",\"motionRotation\",\"objectFit\",\"objectPosition\",\"opacity\",\"order\",\"orientation\",\"orphans\",\"outline\",\"outlineColor\",\"outlineOffset\",\"outlineStyle\",\"outlineWidth\",\"overflow\",\"overflowWrap\",\"overflowX\",\"overflowY\",\"padding\",\"paddingBottom\",\"paddingLeft\",\"paddingRight\",\"paddingTop\",\"page\",\"pageBreakAfter\",\"pageBreakBefore\",\"pageBreakInside\",\"paintOrder\",\"perspective\",\"perspectiveOrigin\",\"pointerEvents\",\"position\",\"quotes\",\"resize\",\"right\",\"shapeImageThreshold\",\"shapeMargin\",\"shapeOutside\",\"shapeRendering\",\"size\",\"speak\",\"src\",\"stopColor\",\"stopOpacity\",\"stroke\",\"strokeDasharray\",\"strokeDashoffset\",\"strokeLinecap\",\"strokeLinejoin\",\"strokeMiterlimit\",\"strokeOpacity\",\"strokeWidth\",\"tabSize\",\"tableLayout\",\"textAlign\",\"textAlignLast\",\"textAnchor\",\"textCombineUpright\",\"textDecoration\",\"textIndent\",\"textOrientation\",\"textOverflow\",\"textRendering\",\"textShadow\",\"textTransform\",\"top\",\"touchAction\",\"transform\",\"transformOrigin\",\"transformStyle\",\"transition\",\"transitionDelay\",\"transitionDuration\",\"transitionProperty\",\"transitionTimingFunction\",\"unicodeBidi\",\"unicodeRange\",\"userZoom\",\"vectorEffect\",\"verticalAlign\",\"visibility\",\"whiteSpace\",\"widows\",\"width\",\"willChange\",\"wordBreak\",\"wordSpacing\",\"wordWrap\",\"writingMode\",\"zIndex\",\"zoom\"].forEach(function(property) {\r\n\t\tstyleDefinitions[property] = styleDefinitions[property] || defaultStyle\r\n\t})\r\n\tvar styleSheet\r\n\tvar presumptiveParentMap = new WeakMap()\r\n\r\n\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\tfunction createCssRule(selector) {\r\n\t\tif (!styleSheet) {\r\n\t\t\tvar styleSheetElement = doc.createElement(\"style\")\r\n\t\t\tstyleSheetElement.setAttribute(\"type\", \"text/css\")\r\n//\t\t\tstyleSheet.appendChild(doc.createTextNode(css))\r\n\t\t\tdoc.head.insertBefore(styleSheetElement, doc.head.firstChild)\r\n\t\t\tstyleSheet = styleSheetElement.sheet\r\n\t\t}\r\n\t\tvar cssRules = styleSheet.cssRules || styleSheet.rules\r\n\t\treturn cssRules[styleSheet.addRule(selector, ' ', cssRules.length)]\r\n\t}\r\n\r\n\t// TODO: Need to do some more testing to see if that would improve performance:\r\n\t// var fragmentThresholdHeuristic = (typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Chrome') > 0) ? 1 : 3\r\n\r\n\tfunction layoutChildren(parent, children, container, prepend) {\r\n\t\tvar fragment = (children.length > 1 || prepend) ? doc.createDocumentFragment() : parent\r\n\t\tfor(var i = 0, l = children.length; i < l; i++) {\r\n\t\t\tvar child = children[i]\r\n\t\t\tvar childNode\r\n\t\t\tif (child != null) { // we just skip nulls and undefined, helps make it easier to write conditional element logic\r\n\t\t\t\tif (child.create) {\r\n\t\t\t\t\t// an element constructor\r\n\t\t\t\t\tcurrentParent = parent\r\n\t\t\t\t\tchildNode = child.create()\r\n\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t\tif (child.isContentNode) {\r\n\t\t\t\t\t\tcontainer.contentNode = childNode\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (child.notifies) {\r\n\t\t\t\t\t// a variable\r\n\t\t\t\t\tvar ref = child.isIterable ? fragment : parent\r\n\t\t\t\t\tfragment.appendChild(childNode = variableAsContent(ref, child))\r\n\t\t\t\t} else if (typeof child == 'object') {\r\n\t\t\t\t\tif (child instanceof Array) {\r\n\t\t\t\t\t\t// array of sub-children\r\n\t\t\t\t\t\tcontainer = container || parent\r\n\t\t\t\t\t\tchildNode = childNode || parent\r\n\t\t\t\t\t\tlayoutChildren(childNode.contentNode || childNode, child, container)\r\n\t\t\t\t\t} else if (child.nodeType) {\r\n\t\t\t\t\t\t// an element itself\r\n\t\t\t\t\t\tfragment.appendChild(childNode = child)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// TODO: apply properties to last child, but with binding to the parent (for events)\r\n\t\t\t\t\t\tthrow new Error('Unknown child type ' + child)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// a primitive value\r\n\t\t\t\t\tchildNode = doc.createTextNode(child)\r\n\t\t\t\t\tfragment.appendChild(childNode)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (fragment != parent) {\r\n\t\t\tif (prepend) {\r\n\t\t\t\tparent.insertBefore(fragment, parent.firstChild)\r\n\t\t\t} else {\r\n\t\t\t\tparent.appendChild(fragment)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn childNode\r\n\t}\r\n\tfunction variableAsContent(parent, content) {\r\n\t\tif (content == null) {\r\n\t\t\treturn doc.createTextNode('')\r\n\t\t}\r\n\t\tvar textNode\r\n\t\tif (content.notifies) {\r\n\t\t\ttextNode = doc.createTextNode('')\r\n\t\t\tnew TextRenderer({\r\n\t\t\t\telement: parent,\r\n\t\t\t\ttextNode: textNode,\r\n\t\t\t\tvariable: content\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\ttextNode = doc.createTextNode(content)\r\n\t\t}\r\n\t\treturn textNode\r\n\t}\r\n\r\n\tfunction bidirectionalHandler(element, value, key) {\r\n\t\tif (value && value.notifies) {\r\n\t\t\tnew InputPropertyRenderer({\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: value,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t\tif (inputs[element.tagName] || element.tagName === 'SELECT') {\r\n\t\t\t\tbindChanges(element, value, key)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (element.tagName === 'SELECT' && key === 'value') {\r\n\t\t\t\t// use the deferred <select> value assignment\r\n\t\t\t\tInputPropertyRenderer.prototype.renderSelectValueUpdate(value, element)\r\n\t\t\t} else {\r\n\t\t\t\tif (element.type === 'number') {\r\n\t\t\t\t\tif (isNaN(value)) {\r\n\t\t\t\t\t\tvalue = ''\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telement[key] = value\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction noop() {}\r\n\tvar propertyHandlers = {\r\n\t\tchildren: noop,\r\n\t\ttagName: noop,\r\n\t\tclasses: function(element, classes) {\r\n\t\t\tif (!(classes.length > -1)) {\r\n\t\t\t\t// index the classes, if necessary\r\n\t\t\t\tvar i = 0\r\n\t\t\t\tfor (var key in classes) {\r\n\t\t\t\t\tif (!classes[i]) {\r\n\t\t\t\t\t\tclasses[i] = key\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti++\r\n\t\t\t\t}\r\n\t\t\t\tclasses.length = i\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, l = classes.length; i < l; i++) {\r\n\t\t\t\t// find each class name\r\n\t\t\t\tvar className = classes[i]\r\n\t\t\t\tvar flag = classes[className]\r\n\t\t\t\tif (flag && flag.notifies) {\r\n\t\t\t\t\t// if it is a variable, we react to it\r\n\t\t\t\t\tnew ClassNameRenderer({\r\n\t\t\t\t\t\telement: element,\r\n\t\t\t\t\t\tclassName: className,\r\n\t\t\t\t\t\tvariable: flag\r\n\t\t\t\t\t})\r\n\t\t\t\t} else if (flag || flag === undefined) {\r\n\t\t\t\t\telement.className += ' ' + className\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tclass: applyAttribute,\r\n\t\tfor: applyAttribute, // TODO: move to label?\r\n\t\trole: applyAttribute,\r\n\t\trender: function(element, value, key, properties) {\r\n\t\t\t// TODO: This doesn't need to be a property updater (is in place for *render())\r\n\t\t\t// we should also verify it is a generator\r\n\t\t\t// and maybe, at some point, find an optimization to eliminate the bind()\r\n\t\t\tnew PropertyRenderer({\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: new Variable.GeneratorVariable(value.bind(element, properties)),\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t},\r\n\t\tdataset: applySubProperties(function(newValue, element, key) {\r\n\t\t\telement.dataset[key || this.name] = newValue\r\n\t\t}),\r\n\t\tattributes: applySubProperties(function(newValue, element, key) {\r\n\t\t\telement.setAttribute(key || this.name, newValue)\r\n\t\t}),\r\n\t\tstyle: function(element, value, key) {\r\n\t\t\tif (typeof value === 'string') {\r\n\t\t\t\telement.setAttribute('style', value)\r\n\t\t\t} else if (value && value.notifies) {\r\n\t\t\t\tnew AttributeRenderer({\r\n\t\t\t\t\tname: 'style',\r\n\t\t\t\t\tvariable: value,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tstyleObjectHandler(element, value, key)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tknownElementProperties.forEach(function(property) {\r\n\t\tpropertyHandlers[property] = true\r\n\t})\r\n\tif (typeof HTMLElement !== 'undefined') {\r\n\t\tHTMLElement.prototype._propertyHandlers = propertyHandlers // inherit this, at least for now\r\n\t}\r\n\tvar elementPropertyHandlers = {\r\n\t\tinput: lang.copy(['accept', 'alt', 'autocomplete', 'autofocus', 'capture', 'defaultChecked', 'dirName', 'disabled', 'form', 'files', 'formAction', 'formEnctype', 'formMethod', 'formNoValidate', 'formTarget', 'indeterminate', 'inputMode', 'list', 'max', 'maxLength', 'min', 'minLength', 'multiple', 'name', 'pattern', 'placeholder', 'readOnly', 'required', 'size', 'src', 'step', 'type', 'defaultValue', 'willValidate', 'validity', 'validationMessage', 'useMap', 'autocapitalize', 'webkitdirectory', 'incremental', 'stepUp', 'stepDown'], {\r\n\t\t\tvalue: bidirectionalHandler,\r\n\t\t\tvalueAsNumber: bidirectionalHandler,\r\n\t\t\tvalueAsDate: bidirectionalHandler,\r\n\t\t\tchecked: bidirectionalHandler,\r\n\t\t\ttype: function(element, value) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\telement.type = value\r\n\t\t\t\t} catch(e) {\r\n\t\t\t\t\t// IE 11 will throw an error here\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}),\r\n\t\tselect: lang.copy(['name', 'size', 'type', 'selectedIndex', 'validationMessage'], {\r\n\t\t\tvalue: bidirectionalHandler\r\n\t\t}),\r\n\t\ttextarea: lang.copy(['cols', 'dirName', 'maxLength', 'minLength', 'name', 'placeholder', 'rows', 'wrap', 'type', 'defaultValue', 'textLength', 'validationMessage', 'autocapitalize'], {\r\n\t\t\tvalue: bidirectionalHandler\r\n\t\t}),\r\n\t\ta: ['target', 'download', 'ping', 'rel', 'hreflang', 'type', 'referrerPolicy', 'href', 'media'],\r\n\t\tarea: ['target', 'download', 'coords', 'rel', 'hreflang', 'type', 'referrerPolicy', 'href', 'media', 'alt', 'shape'],\r\n\t\tbutton: ['formAction', 'formEnctype', 'formMethod', 'formTarget', 'name', 'type', 'value', 'validationMessage'],\r\n\t\tdialog: ['open'],\r\n\t\tembed: ['src', 'type', 'name'],\r\n\t\tform: ['acceptCharset', 'action', 'autocomplete', 'enctype', 'encoding', 'method', 'name', 'target', 'novalidate'],\r\n\t\tframe: ['name', 'scrolling', 'src', 'frameBorder'],\r\n\t\tframeset: ['cols', 'rows'],\r\n    iframe: ['src', 'srcdoc', 'name', 'referrerPolicy', 'align', 'scrolling', 'frameBorder', 'longDesc'],\r\n    option: ['label', 'value', 'text', 'index'],\r\n    optgroup: ['label'],\r\n    output: ['name', 'type', 'defaultValue', 'value', 'validationMessage'],\r\n    label: ['htmlFor'],\r\n    td: ['colSpan', 'rowSpan'],\r\n    th: ['colSpan', 'rowSpan'],\r\n    script: ['src', 'type', 'charset', 'text', 'event', 'htmlFor', 'integrity'],\r\n    style: ['media', 'type'],\r\n    track: ['kind', 'src', 'srclang', 'label'],\r\n    link: ['href', 'rel', 'media', 'hreflang', 'type', 'charset', 'rev', 'target', 'integrity', 'as'],\r\n    meta: ['name', 'httpEquiv', 'content', 'scheme'],\r\n    meter: ['value', 'min', 'max', 'low', 'high', 'optimum'],\r\n    progress: ['value', 'max', 'position'],\r\n    del: ['cite', 'dateTime'],\r\n    ins: ['cite', 'dateTime'],\r\n    source: ['src', 'type', 'srcset', 'sizes', 'media'],\r\n    video: ['videoWidth', 'videoHeight', 'poster', 'webkitDecodedFrameCount', 'webkitDroppedFrameCount'],\r\n    keygen: ['challenge', 'keytype', 'name', 'type', 'validationMessage'],\r\n    object: ['data', 'type', 'name', 'useMap', 'validationMessage', 'archive', 'code', 'hspace', 'standby', 'vspace', 'codeBase', 'codeType'],\r\n    param: ['name', 'value', 'type', 'valueType']\r\n\t}\r\n\r\n\tfunction applyAttribute(element, value, key) {\r\n\t\tif (value && value.notifies) {\r\n\t\t\tnew AttributeRenderer({\r\n\t\t\t\tname: key,\r\n\t\t\t\tvariable: value,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\telement.setAttribute(key, value)\r\n\t\t}\r\n\t}\r\n\r\n\tvar styleObjectHandler = applySubProperties(function(newValue, element, key) {\r\n\t\telement.style[key || this.name] = newValue\r\n\t})\r\n\r\n\tfunction applySubProperties(renderer) {\r\n\t\tvar SubPropertyRenderer = lang.compose(PropertyRenderer, function SubPropertyRenderer(options) {\r\n\t\t\tPropertyRenderer.apply(this, arguments)\r\n\t\t}, {\r\n\t\t\trenderUpdate: renderer\r\n\t\t})\r\n\t\treturn function(element, value, key) {\r\n\t\t\tfor (var subKey in value) {\r\n\t\t\t\tvar subValue = value[subKey]\r\n\t\t\t\tif (subValue && subValue.notifies) {\r\n\t\t\t\t\tnew SubPropertyRenderer({\r\n\t\t\t\t\t\tname: subKey,\r\n\t\t\t\t\t\tvariable: subValue,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\trenderer(subValue, element, subKey)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction assignProperties(element, properties) {\r\n\t\tfor (var key in properties) {\r\n\t\t\tvar value = properties[key]\r\n\t\t\tvar styleDefinition\r\n\t\t\tvar propertyHandler = element._propertyHandlers[key]\r\n\t\t\tif (propertyHandler) {\r\n\t\t\t\tif (propertyHandler === true) {\r\n\t\t\t\t\t// a standard, known element property\r\n\t\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t\tnew PropertyRenderer({\r\n\t\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\t\telement: element\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\telement[key] = value\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpropertyHandler(element, value, key, properties)\r\n\t\t\t\t}\r\n\t\t\t} else if ((styleDefinition = styleDefinitions[key])) {\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\tnew StyleRenderer({\r\n\t\t\t\t\t\tname: key,\r\n\t\t\t\t\t\tvariable: value,\r\n\t\t\t\t\t\telement: element\r\n\t\t\t\t\t})\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyleDefinition(element, value, key)\r\n\t\t\t\t}\r\n\t\t\t} else if (element[key] == null) {\r\n\t\t\t\t// we are working an unknown/unstandard property (or an event listener)\r\n\t\t\t\t// undefined or null means we can safely set\r\n\t\t\t\t// TODO: we may want to do the event listener check first so we can handle oncustomevent (that needs an addEventListener call to work)\r\n\t\t\t\telement[key] = value\r\n\t\t\t} else if (typeof value === 'function' && key.slice(0, 2) === 'on') {\r\n\t\t\t\t// event listener with one already defined on the prototype\r\n\t\t\t\telement.addEventListener(key.slice(2), value)\r\n\t\t\t} else {\r\n\t\t\t\t// otherwise bypass/override the native getter/setter\r\n\t\t\t\tObject.defineProperty(element, key, {\r\n\t\t\t\t\tvalue: value,\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\tconfigurable: true,\r\n\t\t\t\t\twritable: true\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction buildContent(element, content, key, properties) {\r\n\t\tvar each = element.each || properties.each\r\n\t\tif (each && content) {\r\n\t\t\t// render as list\r\n\t\t\tif (each.create) {\r\n\t\t\t\teach.defineHasOwn = function () {\r\n\t\t\t\t\tvar ItemClass = content.getCollectionOf && content.getCollectionOf() || Item\r\n\t\t\t\t\thasOwn(each, ItemClass, function (element) {\r\n\t\t\t\t\t\tvar itemVariable = ItemClass.from(element._item)\r\n\t\t\t\t\t\treturn itemVariable\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (content.notifies) {\r\n\t\t\t\tnew ListRenderer({\r\n\t\t\t\t\teach: each,\r\n\t\t\t\t\tvariable: content,\r\n\t\t\t\t\telement: element\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tvar fragment = doc.createDocumentFragment()\r\n\t\t\t\tif (each.defineHasOwn) {\r\n\t\t\t\t\teach.defineHasOwn()\r\n\t\t\t\t}\r\n\t\t\t\tcontent.forEach(function(item) {\r\n\t\t\t\t\tif (each.create) {\r\n\t\t\t\t\t\tchildElement = each.create({parent: element, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tchildElement = each(item, element)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfragment.appendChild(childElement)\r\n\t\t\t\t})\r\n\t\t\t\telement.appendChild(fragment)\r\n\t\t\t}\r\n\t\t} else if (inputs[element.tagName]) {\r\n\t\t\t// render into input\r\n\t\t\tbuildInputContent(element, content)\r\n\t\t} else if (content instanceof Array) {\r\n\t\t\t// treat array as children (potentially of the content node)\r\n\t\t\telement = element.contentNode || element\r\n\t\t\tlayoutChildren(element, content, element)\r\n\t\t} else {\r\n\t\t\t// render as string\r\n\t\t\telement.appendChild(variableAsContent(element, content))\r\n\t\t}\r\n\t}\r\n\r\n\tfunction bindChanges(element, variable, key, conversion) {\r\n\t\tlang.nextTurn(function() { // wait for next turn in case inputChanges isn't set yet\r\n\t\t\tvar inputEvents = element.inputEvents || ['change', 'alkali-change']\r\n\t\t\tfor (var i = 0, l = inputEvents.length; i < l; i++) {\r\n\t\t\t\telement.addEventListener(inputEvents[i], function (event) {\r\n\t\t\t\t\tvar value = element[key]\r\n\t\t\t\t\tvar result = variable.put(conversion ? conversion(value, element) : value, new Context(element))\r\n\t\t\t\t\tif (result === Variable.deny) {\r\n\t\t\t\t\t\tthrow new Error('Variable change denied')\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tdoc.addEventListener('click', function(event) {\r\n\t\tvar target = event.target\r\n\t\tif (target.type === 'radio') {\r\n\t\t\tvar radios = doc.querySelectorAll('input[type=radio]')\r\n\t\t\tfor (var i = 0, l = radios.length; i < l; i++) {\r\n\t\t\t\tvar radio = radios[i]\r\n\t\t\t\tif (radio.name === target.name && radio !== target) {\r\n\t\t\t\t\tradio.dispatchEvent(new Event('alkali-change', {}))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tfunction conversion(value, element) {\r\n\t\tif (element.type == 'number') {\r\n\t\t\treturn parseFloat(value)\r\n\t\t}\r\n\t\treturn value\r\n\t}\r\n\r\n\tfunction buildInputContent(element, content) {\r\n\t\tvar inputType = element.type\r\n\t\tvar inputProperty = inputType in {date: 1, datetime: 1, time: 1} ?\r\n\t\t\t\t'valueAsDate' : (inputType === 'checkbox' || inputType === 'radio') ?\r\n\t\t\t\t\t'checked' : 'value'\r\n\r\n\t\tif (content && content.notifies) {\r\n\t\t\t// a variable, respond to changes\r\n\t\t\tnew InputPropertyRenderer({\r\n\t\t\t\tvariable: content,\r\n\t\t\t\tname: inputProperty,\r\n\t\t\t\telement: element\r\n\t\t\t})\r\n\t\t\t// and bind the other way as well, updating the variable in response to input changes\r\n\t\t\tbindChanges(element, content, inputProperty, conversion)\r\n\t\t} else {\r\n\t\t\t// primitive\r\n\t\t\telement[inputProperty] = content\r\n\t\t}\r\n\t}\r\n\tvar classHandlers = {\r\n\t\thasOwn: function(Element, value) {\r\n\t\t\thasOwn(Element, value)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction applyToClass(value, Element) {\r\n\t\tvar applyOnCreate = Element._applyOnCreate\r\n\t\tif (value && typeof value === 'object') {\r\n\t\t\tif (value instanceof Array || value.notifies) {\r\n\t\t\t\tapplyOnCreate.content = value\r\n\t\t\t} else {\r\n\t\t\t\tfor (var key in value) {\r\n\t\t\t\t// TODO: eventually we want to be able to set these as rules statically per element\r\n\t\t\t\t/*if (styleDefinitions[key]) {\r\n\t\t\t\t\tvar styles = Element.styles || (Element.styles = [])\r\n\t\t\t\t\tstyles.push(key)\r\n\t\t\t\t\tstyles[key] = descriptor.value\r\n\t\t\t\t} else {*/\r\n\t\t\t\t\tif (classHandlers[key]) {\r\n\t\t\t\t\t\thasOwn(Element, value[key])\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\tapplyOnCreate[key] = value[key]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (typeof value === 'function' && !value.for) {\r\n\t\t\tthrow new TypeError('Function as argument not supported')\r\n\t\t} else {\r\n\t\t\tapplyOnCreate.content = value\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getApplySet(Class) {\r\n\t\tif (Class.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\treturn Class._applyOnCreate\r\n\t\t}\r\n\t\t// this means we didn't extend and evaluate the prototype yet\r\n\t\tif (Class.getForClass) {\r\n\t\t\t// we are extending an alkali constructor\r\n\t\t\t// if this class is inheriting from an alkali constructor, work our way up the chain\r\n\t\t\tapplyOnCreate = Class._applyOnCreate = {}\r\n\t\t\tvar parentApplySet = getApplySet(getPrototypeOf(Class))\r\n\t\t\tfor (var key in parentApplySet) {\r\n\t\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t\t}\r\n\t\t\t// we need to check the prototype for event handlers\r\n\t\t\tvar prototype = Class.prototype\r\n\t\t\tvar propertyHandlers\r\n\t\t\tvar keys = Object.getOwnPropertyNames(prototype)\r\n\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\tvar key = keys[i]\r\n\t\t\t\tif (key.slice(0, 2) === 'on' || (key === 'render' && isGenerator(prototype[key]))) {\r\n\t\t\t\t\tapplyOnCreate[key] = prototype[key]\r\n\t\t\t\t} else if (key.slice(0, 6) === 'render') {\r\n\t\t\t\t\tvar propertyName = key[6].toLowerCase() + key.slice(7)\r\n\t\t\t\t\tif (!propertyHandlers) {\r\n\t\t\t\t\t\tpropertyHandlers = prototype._propertyHandlers = Object.create(prototype._propertyHandlers)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpropertyHandlers[propertyName] = true // TODO: is it better to implement this with property handlers?\r\n\t\t\t\t\tObject.defineProperty(prototype, propertyName, renderDescriptor(key))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn applyOnCreate\r\n\t\t}\r\n\t\treturn null\r\n\t}\r\n\r\n\tfunction renderDescriptor(renderMethod) {\r\n\t\tvar map = new WeakMap()\r\n\t\treturn {\r\n\t\t\tget: function() {\r\n\t\t\t\treturn map.has(this) ? map.get(this) : null\r\n\t\t\t},\r\n\t\t\tset: function(value) {\r\n\t\t\t\tmap.set(this, value)\r\n\t\t\t\tthis[renderMethod](value)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction makeElementConstructor() {\r\n\t\tfunction Element(selector, properties) {\r\n\t\t\tif (this instanceof Element){\r\n\t\t\t\t// create DOM element\r\n\t\t\t\t// Need to detect if we have registered the element and `this` is actually already the correct instance\r\n\t\t\t\treturn create.apply(Element.prototype === getPrototypeOf(this) ? Element :// this means it is from this constructor\r\n\t\t\t\t\tthis.constructor, // this means it was constructed from a subclass\r\n\t\t\t\t\targuments)\r\n\t\t\t} else {\r\n\t\t\t\t// extend to create new class\r\n\t\t\t\treturn withProperties.apply(Element, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\tElement.create = create\r\n\t\tElement.with = withProperties\r\n\t\tElement.for = forTarget\r\n\t\tElement.property = propertyForElement\r\n\t\tElement.getForClass = getForClass\r\n\t\treturn Element\r\n\t}\r\n\r\n\tfunction withProperties(selector, properties) {\r\n\t\tvar Element = makeElementConstructor()\r\n\t\tElement.superConstructor = this\r\n\t\tElement.tagName = this.tagName\r\n\t\tif (this.children) {\r\n\t\t\t// just copy this property\r\n\t\t\tElement.children = this.children\r\n\t\t}\r\n\t\tElement.prototype = this.prototype\r\n\r\n\t\tvar applyOnCreate = Element._applyOnCreate = {}\r\n\t\tvar parentApplySet = getApplySet(this)\r\n\t\t// copy parent properties\r\n\t\tfor (var key in parentApplySet) {\r\n\t\t\tapplyOnCreate[key] = parentApplySet[key]\r\n\t\t}\r\n\r\n\t\tvar i = 0 // for arguments\r\n\t\tif (typeof selector === 'string') {\r\n\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\tif (selectorMatch) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tapplyOnCreate.className = name\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t} while (selectorMatch)\r\n\t\t\t} else {\r\n\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t}\r\n\t\t\ti++ // skip the first argument\r\n\t\t}\r\n\r\n\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\tapplyToClass(arguments[i], Element)\r\n\t\t}\r\n\t\treturn Element\r\n\t}\r\n\tvar currentParent\r\n\tfunction create(selector, properties) {\r\n\t\t// TODO: make this a symbol\r\n\t\tvar applyOnCreate = getApplySet(this)\r\n\t\tif (currentParent) {\r\n\t\t\tvar parent = currentParent\r\n\t\t\tcurrentParent = null\r\n\t\t}\r\n/*\t\tif (this._initialized != this) {\r\n\t\t\tthis._initialized = this\r\n\t\t\tthis.initialize && this.initialize()\r\n\t\t\tvar styles = this.styles\r\n\t\t\tif (styles) {\r\n\t\t\t\tvar rule = createCssRule(getUniqueSelector(this))\r\n\t\t\t\tfor (var i = 0, l = styles.length; i < l; i++) {\r\n\t\t\t\t\tvar key = styles[i]\r\n\t\t\t\t\tvar value = styles[key]\r\n\t\t\t\t\t// TODO: if it is a contextualized variable, do this on the element\r\n\t\t\t\t\tvar styleDefinition = styleDefinitions[key]\r\n\t\t\t\t\tif (styleDefinition) {\r\n\t\t\t\t\t\tstyleDefinition(rule, value, key)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!this.hasOwnProperty('_applyOnCreate')) {\r\n\t\t\t\tapplyOnCreate = getApplySet(this)\r\n\t\t\t}\r\n\t\t}*/\r\n\t\tvar element = doc.createElement(this.tagName)\r\n\t\tif (selector && selector.parent) {\r\n\t\t\tparent = selector.parent\r\n\t\t}\r\n\t\tif (parent) {\r\n\t\t\tpresumptiveParentMap.set(element, parent)\r\n\t\t}\r\n\t\tif (!(element instanceof this)) {\r\n\t\t\t// ideally we want to avoid this call, as it is expensive, but for classes that\r\n\t\t\t// don't register a tag name, we have to make sure the prototype chain is correct\r\n\t\t\tsetPrototypeOf(element, this.prototype)\r\n\t\t}\r\n\t\tif (element.constructor != this) {\r\n\t\t\telement.constructor = this // need to do this for hasOwn contextualization to work\r\n\t\t}\r\n\t\tif (arguments.length > 0) {\r\n\t\t\t// copy applyOnCreate when we have arguments\r\n\t\t\tvar ElementApplyOnCreate = applyOnCreate\r\n\t\t\tapplyOnCreate = {}\r\n\t\t\tfor (var key in ElementApplyOnCreate) {\r\n\t\t\t\tapplyOnCreate[key] = ElementApplyOnCreate[key]\r\n\t\t\t}\r\n\t\t\tvar i = 0\r\n\t\t\tif (typeof selector == 'string') {\r\n\t\t\t\ti++\r\n\t\t\t\tvar selectorMatch = selector.match(SELECTOR_REGEX)\r\n\t\t\t\tif (selectorMatch) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tvar operator = selectorMatch[1]\r\n\t\t\t\t\t\tvar name = selectorMatch[2]\r\n\t\t\t\t\t\tif (operator == '.') {\r\n\t\t\t\t\t\t\tif (applyOnCreate.className) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.className += ' ' + name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (element.className) {\r\n\t\t\t\t\t\t\t\t\t\telement.className += ' ' + name\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\telement.className = name\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (applyOnCreate.id) {\r\n\t\t\t\t\t\t\t\tapplyOnCreate.id = name\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// just skip right to the element\r\n\t\t\t\t\t\t\t\telement.id = name\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar remaining = selectorMatch[3]\r\n\t\t\t\t\t\tselectorMatch = remaining && remaining.match(SELECTOR_REGEX)\r\n\t\t\t\t\t} while (selectorMatch)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = selector\r\n\t\t\t\t}\r\n\t\t\t} else if (selector && selector._item) {\r\n\t\t\t\t// this is kind of hack, to get the Item available before the properties, eventually we may want to\r\n\t\t\t\t// order static properties before variable binding applications, but for now.\r\n\t\t\t\telement._item = selector._item\r\n\t\t\t}\r\n\t\t\tfor (var l = arguments.length; i < l; i++) {\r\n\t\t\t\tvar argument = arguments[i]\r\n\t\t\t\tif (argument && typeof argument === 'object') {\r\n\t\t\t\t\tif (argument instanceof Array || argument.notifies) {\r\n\t\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (var key in argument) {\r\n\t\t\t\t\t\t\t// TODO: do deep merging of styles and classes, but not variables\r\n\t\t\t\t\t\t\tapplyOnCreate[key] = argument[key]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (typeof argument === 'function' && argument.for) {\r\n\t\t\t\t\tapplyOnCreate.content = argument.for(element)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tapplyOnCreate.content = argument\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (element.created) {\r\n\t\t\tapplyOnCreate = element.created(applyOnCreate) || applyOnCreate\r\n\t\t} else if (applyOnCreate.created) {\r\n\t\t\tapplyOnCreate = applyOnCreate.created.call(element, applyOnCreate) || applyOnCreate\r\n\t\t}\r\n\t\t// TODO: inline this for better performance, possibly\r\n\t\tassignProperties(element, applyOnCreate)\r\n\t\tif (this.children) {\r\n\t\t\tlayoutChildren(element, this.children, element)\r\n\t\t}\r\n\t\t// always do this last, so it can be properly inserted inside the children\r\n\t\tif (applyOnCreate.content) {\r\n\t\t\tbuildContent(element, applyOnCreate.content, 'content', applyOnCreate)\r\n\t\t}\r\n\t\telement.ready && element.ready(applyOnCreate)\r\n\t\treturn element\r\n\t}\r\n\r\n\tvar slice = [].slice\r\n\tfunction append(parent){\r\n\t\treturn this.nodeType ?\r\n\t\t\tlayoutChildren(this, arguments, this) : // called as a method\r\n\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent) // called as a function\r\n\t}\r\n\r\n\tfunction prepend(parent){\r\n\t\treturn this.nodeType ?\r\n\t\t\tlayoutChildren(this, arguments, this, true) : // called as a method\r\n\t\t\tlayoutChildren(parent, slice.call(arguments, 1), parent, true) // called as a function\r\n\t}\r\n\r\n\tfunction registerTag(tagName) {\r\n\t\tthis.tagName = tagName\r\n\t\tif (doc.registerElement && this.prototype.constructor === this) {\r\n\t\t\tdoc.registerElement(tagName, this)\r\n\t\t}\r\n\t}\r\n\r\n\tvar Element = withProperties.call(typeof HTMLElement !== 'undefined' ? HTMLElement : function() {})\r\n\r\n\tElement.registerTag = registerTag\r\n\tElement.assign = assignProperties\r\n\r\n\tElement.within = function(element){\r\n\t\t// find closest child\r\n\t}\r\n\r\n\tgenerate([\r\n\t\t'Video',\r\n\t\t'Source',\r\n\t\t'Media',\r\n\t\t'Audio',\r\n\t\t'UL',\r\n\t\t'Track',\r\n\t\t'Title',\r\n\t\t'TextArea',\r\n\t\t'Template',\r\n\t\t'TBody',\r\n\t\t'THead',\r\n\t\t'TFoot',\r\n\t\t'TR',\r\n\t\t'Table',\r\n\t\t'Col',\r\n\t\t'ColGroup',\r\n\t\t'TH',\r\n\t\t'TD',\r\n\t\t'Caption',\r\n\t\t'Style',\r\n\t\t'Span',\r\n\t\t'Shadow',\r\n\t\t'Select',\r\n\t\t'Script',\r\n\t\t'Quote',\r\n\t\t'Progress',\r\n\t\t'Pre',\r\n\t\t'Picture',\r\n\t\t'Param',\r\n\t\t'P',\r\n\t\t'Output',\r\n\t\t'Option',\r\n\t\t'Optgroup',\r\n\t\t'Object',\r\n\t\t'OL',\r\n\t\t'Ins',\r\n\t\t'Del',\r\n\t\t'Meter',\r\n\t\t'Meta',\r\n\t\t'Menu',\r\n\t\t'Map',\r\n\t\t'Link',\r\n\t\t'Legend',\r\n\t\t'Label',\r\n\t\t'LI',\r\n\t\t'KeyGen',\r\n\t\t'Input',\r\n\t\t'Image',\r\n\t\t'IFrame',\r\n\t\t'H1',\r\n\t\t'H2',\r\n\t\t'H3',\r\n\t\t'H4',\r\n\t\t'H5',\r\n\t\t'H6',\r\n\t\t'Hr',\r\n\t\t'FrameSet',\r\n\t\t'Frame',\r\n\t\t'Form',\r\n\t\t'Font',\r\n\t\t'Embed',\r\n\t\t'Article',\r\n\t\t'Aside',\r\n\t\t'Footer',\r\n\t\t'Figure',\r\n\t\t'FigCaption',\r\n\t\t'Header',\r\n\t\t'Main',\r\n\t\t'Mark',\r\n\t\t'MenuItem',\r\n\t\t'Nav',\r\n\t\t'Section',\r\n\t\t'Summary',\r\n\t\t'WBr',\r\n\t\t'Div',\r\n\t\t'Dialog',\r\n\t\t'Details',\r\n\t\t'DataList',\r\n\t\t'DL',\r\n\t\t'Canvas',\r\n\t\t'Button',\r\n\t\t'Base',\r\n\t\t'Br',\r\n\t\t'Area',\r\n\t\t'A'\r\n\t])\r\n\tgenerateInputs([\r\n\t\t'Checkbox',\r\n\t\t'Password',\r\n\t\t'Submit',\r\n\t\t'Radio',\r\n\t\t'Color',\r\n\t\t'Date',\r\n\t\t'DateTime',\r\n\t\t'Email',\r\n\t\t'Month',\r\n\t\t'Number',\r\n\t\t'Range',\r\n\t\t'Search',\r\n\t\t'Tel',\r\n\t\t'Time',\r\n\t\t'Url',\r\n\t\t'Week'])\r\n\r\n\tvar tags = {}\r\n\tfunction getConstructor(tagName) {\r\n\t\ttagName = tagName.toLowerCase()\r\n\t\treturn tags[tagName] ||\r\n\t\t\t(tags[tagName] =\r\n\t\t\t\tsetupElement(withProperties.call(doc.createElement(tagName).constructor), tagName))\r\n\t}\r\n\r\n\tfunction setupElement(Element, tagName) {\r\n\t\tvar props = elementPropertyHandlers[tagName]\r\n\t\tif (props && !props.assigned) {\r\n\t\t\tvar handlers = Element.prototype._propertyHandlers = Object.create(propertyHandlers)\r\n\t\t\tfor (var i = 0, l = props.length; i < l; i++) {\r\n\t\t\t\thandlers[props[i]] = true\r\n\t\t\t}\r\n\t\t\tif (props.value) {\r\n\t\t\t\tfor (var i in props) {\r\n\t\t\t\t\tif (!(i > -1)) { // assign any string properties if necessary\r\n\t\t\t\t\t\thandlers[i] = props[i]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tprops.assigned = true\r\n\t\t}\r\n\t\tElement.tagName = tagName\r\n\t\treturn Element\r\n\t}\r\n\tfunction generate(elements) {\r\n\t\telements.forEach(function(elementName) {\r\n\t\t\tvar ElementClass\r\n\t\t\tObject.defineProperty(Element, elementName, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn ElementClass || (ElementClass = getConstructor(elementName))\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\tfunction generateInputs(elements) {\r\n\t\telements.forEach(function(inputType) {\r\n\t\t\tvar ElementClass\r\n\t\t\tObject.defineProperty(Element, inputType, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\t// TODO: make all inputs extend from input generated from generate\r\n\t\t\t\t\treturn ElementClass || (ElementClass = setupElement(withProperties.call(HTMLInputElement, {\r\n\t\t\t\t\t\ttype: inputType.toLowerCase()\r\n\t\t\t\t\t}), 'input'))\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\t// alias all the inputs with an Input suffix\r\n\t\t\tObject.defineProperty(Element, inputType + 'Input', {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn this[inputType]\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})\r\n\t}\r\n\r\n\tvar aliases = {\r\n\t\tAnchor: 'A',\r\n\t\tParagraph: 'P',\r\n\t\tTextarea: 'TextArea',\r\n\t\tDList: 'DL',\r\n\t\tUList: 'UL',\r\n\t\tOList: 'OL',\r\n\t\tListItem: 'LI',\r\n\t\tText: 'Input',\r\n\t\tTextInput: 'Input',\r\n\t\tTableRow: 'TR',\r\n\t\tTableCell: 'TD',\r\n\t\tTableHeaderCell: 'TH',\r\n\t\tTableHeader: 'THead',\r\n\t\tTableBody: 'TBody'\r\n\t}\r\n\tfor (var alias in aliases) {\r\n\t\t(function(alias, to) {\r\n\t\t\tObject.defineProperty(Element, alias, {\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn this[to]\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t})(alias, aliases[alias])\r\n\t}\r\n\r\n\tElement.append = append\r\n\tElement.prepend = prepend\r\n\tElement.refresh = Renderer.refresh\r\n\tElement.options = {\r\n\t\tmoveLiveElementsEnabled: true,\r\n\t}\r\n\tElement.content = function(element){\r\n\t\t// container marker\r\n\t\treturn {\r\n\t\t\tisContentNode: true,\r\n\t\t\tcreate: element.create.bind(element)\r\n\t\t}\r\n\t}\r\n\r\n\tElement.ElementClass = function() {}\r\n\tif (typeof Symbol !== 'undefined') {\r\n\t\t// make instanceof work for Element\r\n\t\tObject.defineProperty(Element.ElementClass, Symbol.hasInstance, { value: function(target) {\r\n\t\t\treturn target && (target.create && target.with)\r\n\t\t}})\r\n\t}\r\n\r\n\t// TODO: unify this in lang\r\n\tElement.extend = function(Class, properties) {\r\n\t\tfunction ExtendedElement() {\r\n\t\t\treturn Class.apply(this, arguments)\r\n\t\t}\r\n\t\tsetPrototypeOf(ExtendedElement, Class)\r\n\t\tvar prototype = ExtendedElement.prototype = Object.create(Class.prototype)\r\n\t\tprototype.constructor = ExtendedElement\r\n\t\tObject.getOwnPropertyNames(properties).forEach(function(key) {\r\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\tif (classHandlers[key]) {\r\n\t\t\t\tclassHandlers[key](ExtendedElement, descriptor.value)\r\n\t\t\t} else {\r\n\t\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\t}\r\n\t\t})\r\n\t\treturn ExtendedElement\r\n\t}\r\n\r\n\tfunction forTarget(target) {\r\n\t\treturn target.constructor.getForClass(target, this)\r\n\t}\r\n\r\n\tfunction hasOwn(From, Target, createInstance) {\r\n\t\tif (typeof Target === 'object') {\r\n\t\t\t// we were given an actual instance, use that\r\n\t\t\tvar elementMap = From.ownedClasses || (From.ownedClasses = new WeakMap())\r\n\t\t\tvar instanceMap = {get: function () {\r\n\t\t\t\treturn Target\r\n\t\t\t}}\r\n\t\t\telementMap.set(Target.constructor, instanceMap)\r\n\t\t\treturn hasOwn(From, Target.Class, Target.createInstance)\r\n\t\t}\r\n\t\tif (Target instanceof Array) {\r\n\t\t\treturn Target.forEach(function(Target) {\r\n\t\t\t\thasOwn(From, Target)\r\n\t\t\t})\r\n\t\t}\r\n\t\tvar instanceMap = new WeakMap()\r\n\t\tinstanceMap.createInstance = createInstance\r\n\t\tvar elementMap = From.ownedClasses || (From.ownedClasses = new WeakMap())\r\n\t\t// TODO: Go up through prototype chain of Target and set each one\r\n\t\telementMap.set(Target, instanceMap)\r\n\t\treturn From\r\n\t}\r\n\r\n\tfunction getForClass(element, Target) {\r\n\t\tvar createInstance\r\n\t\twhile (element && !(createInstance = element.constructor.ownedClasses && element.constructor.ownedClasses.get(Target))) {\r\n\t\t\telement = element.parentNode || presumptiveParentMap.get(element)\r\n\t\t}\r\n\t\tif (createInstance) {\r\n\t\t\tvar ownedInstances = element.ownedInstances || (element.ownedInstances = new WeakMap())\r\n\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\tif (instance === undefined) {\r\n\t\t\t\townedInstances.set(Target, instance = createInstance(element))\r\n\t\t\t\tinstance.subject = element\r\n\t\t\t}\r\n\t\t\treturn instance\r\n\t\t}\r\n\t}\r\n\r\n\tfunction propertyForElement(key) {\r\n\t\t// we just need to establish one Variable class for each element, so we cache it\r\n\t\tThisElementVariable = this._Variable\r\n\t\tif (!ThisElementVariable) {\r\n\t\t\t// need our own branded variable class for this element class\r\n\t\t\tThisElementVariable = this._Variable = Variable()\r\n\r\n\t\t\thasOwn(this, ThisElementVariable, function(element) {\r\n\t\t\t\t// TODO: we might want to do this in init instead\r\n\t\t\t\tvar variableProperties = {}\r\n\t\t\t\tfor (var i = 0; i < element.alkaliRenderers.length; i++){\r\n\t\t\t\t\tvar renderer = element.alkaliRenderers[i]\r\n\t\t\t\t\tif (renderer.name) {\r\n\t\t\t\t\t\tvariableProperties[renderer.name] = {value: renderer.variable}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar elementOverlay = Object.create(element, variableProperties)\r\n\t\t\t\tvar instance = new ThisElementVariable(elementOverlay)\r\n\t\t\t\t// we are not observing, because you can't delegate getters and setters in safari\r\n\t\t\t\t// instance.observeObject()\r\n\t\t\t\treturn instance\r\n\t\t\t})\r\n\t\t}\r\n\t\t// now actually get the property class\r\n\t\treturn ThisElementVariable.property(key)\r\n\t}\r\n\r\n\tvar Item = Element.Item = Variable.Item\r\n\r\n\tfunction enterRenderer(Renderer, options/*, target*/) {\r\n\t\t// this will be used for optimized class-level variables\r\n\t\t/*if (target.started) { // TODO: Might want to pass in started as a parameter\r\n\t\t\t// this means that the renderer has already been created, so we just need to add this instance\r\n\t\t\tRenderer.prototype.renderUpdate.call(options, element)\r\n\t\t} else {*/\r\n\t\tnew Renderer(options)\r\n\t\t//}\r\n\t}\r\n\r\n\tfunction cleanup(target) {\r\n\t\tvar renderers = target.alkaliRenderers\r\n\t\tif (renderers) {\r\n\t\t\tfor (var i = 0, l = renderers.length; i < l; i++) {\r\n\t\t\t\trenderers[i].stop()\r\n\t\t\t}\r\n\t\t\ttarget.needsRestart = true\r\n\t\t}\r\n\t}\r\n\tfunction restart(target) {\r\n\t\tvar renderers = target.alkaliRenderers\r\n\t\tif (renderers) {\r\n\t\t\tfor (var i = 0, l = renderers.length; i < l; i++) {\r\n//\t\t\t\tupdaters[i].start()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// setup the mutation observer so we can be notified of attachments and removals\r\n\tfunction elementAttached(element) {\r\n\t\tvar Class = element.constructor\r\n\t\tif (Class.create) {\r\n/*\t\t\tif (Class.attachedInstances) {\r\n\t\t\t\tClass.attachedInstances.push(element)\r\n\t\t\t\tif (Class.attachedInstances.length === 1 && Class.needsRestart) {\r\n\t\t\t\t\trestart(Class)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tClass.attachedInstances = [element]\r\n\t\t\t}*/\r\n\t\t\tif (element.attached) {\r\n\t\t\t\telement.attached()\r\n\t\t\t}\r\n\t\t\tif (element.needsRestart) {\r\n\t\t\t\trestart(element)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction elementDetached(element) {\r\n\t\t/*var attachedInstances = element.constructor.attachedInstances\r\n\t\tif (attachedInstances) {\r\n\t\t\tvar index = attachedInstances.indexOf(element)\r\n\t\t\tif (index > -1) {\r\n\t\t\t\tattachedInstances.splice(index, 1)\r\n\t\t\t\tif (attachedInstances.length === 0) {\r\n\t\t\t\t\tcleanup(Class)\r\n\t\t\t\t}\r\n\t\t\t}*/\r\n\t\t\tif (element.detached) {\r\n\t\t\t\telement.detached()\r\n\t\t\t}\r\n\t\t\tcleanup(element)\r\n\t\t//}\r\n\t}\r\n\tif (typeof MutationObserver === 'function') {\r\n\t\tvar lifeStates = [{\r\n\t\t\tname: 'detached',\r\n\t\t\tnodes: 'removedNodes',\r\n\t\t\taction: elementDetached\r\n\t\t}, {\r\n\t\t\tname: 'attached',\r\n\t\t\tnodes: 'addedNodes',\r\n\t\t\taction: elementAttached\r\n\t\t}]\r\n\t\tfunction firstVisit(node, state) {\r\n\t\t\tif (state.name === 'attached') {\r\n\t\t\t\tif (node.__alkaliAttached__) {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnode.__alkaliAttached__ = true\r\n\t\t\t\t\tstate.action(node)\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}\r\n\t\t\t} else if (node.__alkaliAttached__) {\r\n\t\t\t\tif (doc.body.contains(node)) {\r\n\t\t\t\t\t// detached event, but it is actually still attached (will get attached in a later mutation record)\r\n\t\t\t\t\t// so don't get through the detached/attached lifecycle\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t\tnode.__alkaliAttached__ = false\r\n\t\t\t\tstate.action(node)\r\n\t\t\t}\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tvar observer = new MutationObserver(function(mutations) {\r\n\t\t\tfor (var i = 0, il = mutations.length; i < il; i++) {\r\n\t\t\t\tvar mutation = mutations[i]\r\n\t\t\t\t// invoke action on element if we haven't already\r\n\t\t\t\tactionIteration:\r\n\t\t\t\tfor (var j = 0, jl = lifeStates.length; j < jl; j++) { // two steps, removed nodes and added nodes\r\n\t\t\t\t\tvar state = lifeStates[j]\r\n\t\t\t\t\tvar nodes = mutation[state.nodes]\r\n\t\t\t\t\t// iterate over node list\r\n\t\t\t\t\tnodeIteration:\r\n\t\t\t\t\tfor (var k = 0, kl = nodes.length; k < kl; k++) {\r\n\t\t\t\t\t\tvar baseNode = nodes[k]\r\n\t\t\t\t\t\tif (firstVisit(baseNode, state)) {\r\n\t\t\t\t\t\t\t// start traversal with child, if it exists\r\n\t\t\t\t\t\t\tvar currentNode = baseNode.firstChild\r\n\t\t\t\t\t\t\tif (currentNode) {\r\n\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\tvar nextNode\r\n\t\t\t\t\t\t\t\t\tif (currentNode.nodeType === 1 && firstVisit(currentNode, state)) {\r\n\t\t\t\t\t\t\t\t\t\t// depth-first search\r\n\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.firstChild\r\n\t\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tnextNode = currentNode.nextSibling\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!nextNode) {\r\n\t\t\t\t\t\t\t\t\t\t// come back out to parents\r\n\t\t\t\t\t\t\t\t\t\t// TODO: try keeping a stack to make this faster\r\n\t\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\t\tcurrentNode = currentNode.parentNode\r\n\t\t\t\t\t\t\t\t\t\t\tif (currentNode === baseNode) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue nodeIteration\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} while (!(nextNode = currentNode.nextSibling))\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tcurrentNode = nextNode\r\n\t\t\t\t\t\t\t\t} while (true)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if (options.moveLiveElementsEnabled) {\r\n\t\t\t\t\t\t// TODO: any options that we can really do here?\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t\tobserver.observe(doc.body || doc, {\r\n\t\t\tchildList: true,\r\n\t\t\tsubtree: true\r\n\t\t})\r\n\t}\r\n\r\n\tlang.copy(Variable.Context.prototype, {\r\n\t\tspecify: function(Variable) {\r\n\t\t\tvar element = this.subject\r\n\t\t\tvar distinctive = true\r\n\t\t\t;(this.generics || (this.generics = [])).push(Variable)\r\n\t\t\tdo {\r\n\t\t\t\tif (this.distinctSubject === element) {\r\n\t\t\t\t\tdistinctive = false\r\n\t\t\t\t}\r\n\t\t\t\tvar subjectMap = element.constructor.ownedClasses\r\n\t\t\t\tif (subjectMap) {\r\n\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\tif (instanceMap) {\r\n\t\t\t\t\t\tif (distinctive) {\r\n\t\t\t\t\t\t\tthis.distinctSubject = element\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tspecifiedInstance = instanceMap.get(element)\r\n\t\t\t\t\t\tif (!specifiedInstance) {\r\n\t\t\t\t\t\t\tinstanceMap.set(element, specifiedInstance = instanceMap.createInstance ?\r\n\t\t\t\t\t\t\t\tinstanceMap.createInstance(element) : new Variable())\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn specifiedInstance\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t// else if no specific context is found, return default instance\r\n\t\t\treturn Variable.defaultInstance\r\n\t\t},\r\n\r\n\t\tgetContextualized: function(variable) {\r\n\t\t\t// returns a variable that has already been contextualized\r\n\t\t\tvar element = this.subject\r\n\t\t\tif (!element) {\r\n\t\t\t\t// no element, just use the default variable\r\n\t\t\t\treturn variable\r\n\t\t\t}\r\n\t\t\tif (variable._contextMap) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar instance = variable._contextMap.get(element)\r\n\t\t\t\t\tif (instance && instance.context.matches(element)) {\r\n\t\t\t\t\t\treturn instance\r\n\t\t\t\t\t}\r\n\t\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t\t}\r\n\t\t\tif (variable.context && variable.context.matches(this.subject)) {\r\n\t\t\t\t// check if the default variable is allowed\r\n\t\t\t\treturn variable\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tmerge: function(childContext) {\r\n\t\t\tif (!this.distinctSubject || this.distinctSubject.contains(childContext.distinctSubject)) {\r\n\t\t\t\tthis.distinctSubject = childContext.distinctSubject\r\n\t\t\t}\r\n\t\t\t[].push.apply(this.generics || (this.generics = []), childContext.generics)\r\n\t\t},\r\n\t\tgetDistinctElement: function(Variable, element) {\r\n\t\t\tdo {\r\n\t\t\t\tvar subjectMap = element.constructor.ownedClasses\r\n\t\t\t\tif (subjectMap) {\r\n\t\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\t\tif (instanceMap && instanceMap.has(element)) {\r\n\t\t\t\t\t\treturn element\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} while ((element = element.parentNode || presumptiveParentMap.get(element)))\r\n\t\t},\r\n\t\tmatches: function(element) {\r\n\t\t\tvar generics = this.generics\r\n\t\t\tif (generics) {\r\n\t\t\t\tfor (var i = 0, l = generics.length; i < l; i++) {\r\n\t\t\t\t\tif (this.getDistinctElement(generics[i], element) !== this.distinctSubject) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true\r\n\t\t}\r\n\t})\r\n\r\n\r\n\r\n\treturn Element\r\n})\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Element.js\n ** module id = 1\n ** module chunks = 0\n **/","define(['./util/lang'], function (lang) {\r\n\tvar deny = {}\r\n\tvar noChange = {}\r\n\tvar WeakMap = lang.WeakMap\r\n\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\tvar isGenerator = lang.isGenerator\r\n\t// update types\r\n\tvar RequestChange = 3\r\n\tvar RequestSet = 4\r\n\r\n\tvar ToChild = Object.freeze({\r\n\t\ttype: 'refresh'\r\n\t})\r\n\tvar nextId = 1\r\n\tvar propertyListenersMap = new WeakMap(null, 'propertyListenersMap')\r\n\r\n\tvar CacheEntry = lang.compose(WeakMap, function() {\r\n\t},{\r\n\t\t_propertyChange: function(propertyName) {\r\n\t\t\tthis.variable._propertyChange(propertyName, contextFromCache(this))\r\n\t\t}\r\n\t})\r\n\tvar listenerId = 1\r\n\r\n\tfunction when(value, callback) {\r\n\t\tif (value && value.then) {\r\n\t\t\treturn value.then(callback)\r\n\t\t}\r\n\t\treturn callback(value)\r\n\t}\r\n\r\n\tfunction Context(subject){\r\n\t\tthis.subject = subject\r\n\t\tthis.inputs = []\r\n\t}\r\n\tContext.prototype = {\r\n\t\tconstructor: Context,\r\n\t\tnewContext: function(variable) {\r\n\t\t\treturn new Context(this.subject)\r\n\t\t},\r\n\t\tcontextualize: function(variable, parentContext) {\r\n\t\t\t// resolve the contextualization of a variable, and updates this context to be aware of what distinctive aspect of the context has\r\n\t\t\t// been used for resolution\r\n\t\t\tvar contextualized\r\n\t\t\tif (this.distinctSubject) {\r\n\t\t\t\tvar contextMap = variable._contextMap || (variable._contextMap = new WeakMap())\r\n\t\t\t\tcontextualized = contextMap.get(this.distinctSubject)\r\n\t\t\t\tif (!contextualized) {\r\n\t\t\t\t\tcontextMap.set(this.distinctSubject, contextualized = Object.create(variable))\r\n\t\t\t\t\tcontextualized.listeners = false\r\n\t\t\t\t\tcontextualized.context = this\r\n\t\t\t\t\tvar inputs = this.inputs\r\n\t\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\t\tcontextualized[inputs[i]] = inputs[++i]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.contextualized = contextualized\r\n\t\t\t\t// do the merge\r\n\t\t\t\tif (parentContext) {\r\n\t\t\t\t\tparentContext.merge(this)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcontextualized = variable\r\n\t\t\t}\r\n\t\t\t//if (this.contextualized && this.contextualized !== contextualized) {\r\n\t\t\t\t// TOOD: if it has previously been contextualized to a different context (can happen in a promise/async situation), stop previous notifiers and start new ones\r\n\t\t\t//}\r\n\t\t\tparentContext.addInput(contextualized)\r\n\t\t\treturn contextualized\r\n\t\t},\r\n\t\tmerge: function(childContext) {\r\n\t\t\tif (!this.distinctSubject) {\r\n\t\t\t\tthis.distinctSubject = childContext.distinctSubject\r\n\t\t\t}\r\n\t\t},\r\n\t\tspecify: function(Variable) {\r\n\t\t\t// specify a particular instance of a generic variable\r\n\t\t\tvar subject = this.subject\r\n\t\t\tvar subjectMap = subject.constructor.ownedClasses\r\n\t\t\tvar specifiedInstance\r\n\t\t\tif (subjectMap) {\r\n\t\t\t\tif (!this.distinctSubject) {\r\n\t        this.distinctSubject = subject\r\n\t\t\t\t}\r\n\t\t\t\tvar instanceMap = subjectMap.get(Variable)\r\n\t\t\t\tif (instanceMap) {\r\n\t\t\t\t\tspecifiedInstance = instanceMap.get(subject)\r\n\t\t\t\t\tif (!specifiedInstance) {\r\n\t\t\t\t\t\tinstanceMap.set(subject, specifiedInstance = instanceMap.createInstance ? instanceMap.createInstance(subject) : new Variable())\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn specifiedInstance\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// else if no specific context is found, return default instance\r\n\t\t\treturn Variable.defaultInstance\r\n\t\t},\r\n\t\tgetContextualized: function(variable) {\r\n\r\n\t\t\t// returns a variable that has already been contextualized\r\n\t\t\tvar instance = variable._contextMap && this.subject && variable._contextMap.get(this.subject)\r\n\t\t\tif (instance && instance.context && instance.context.matches(this)) {\r\n\t\t\t\treturn instance\r\n\t\t\t}\r\n\t\t},\r\n\t\taddInput: function(inputVariable) {\r\n\t\t\tthis.inputs.push(this.nextProperty, inputVariable)\r\n\t\t},\r\n\t\tmatches: function(context) {\r\n\t\t\t// does another context match the resolution of this one?\r\n\t\t\treturn context.subject === this.subject\r\n\t\t}\r\n\t}\r\n\r\n\tfunction NotifyingContext(listener, subject){\r\n\t\tthis.subject = subject\r\n\t\tthis.listener = listener\r\n\t}\r\n\tNotifyingContext.prototype = Object.create(Context.prototype)\r\n\tNotifyingContext.prototype.constructor = NotifyingContext\r\n\tNotifyingContext.prototype.addInput = function(contextualized) {\r\n\t\tcontextualized.notifies(this.listener)\r\n\t}\r\n\r\n\tfunction whenAll(inputs, callback){\r\n\t\tvar promiseInvolved\r\n\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\tif (inputs[i] && inputs[i].then) {\r\n\t\t\t\tpromiseInvolved = true\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (promiseInvolved) {\r\n\t\t\treturn lang.whenAll(inputs, callback)\r\n\t\t}\r\n\t\treturn callback(inputs)\r\n\t}\r\n\r\n\tfunction registerListener(value, listener) {\r\n\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\tvar id = listener.listenerId || (listener.listenerId = ('-' + listenerId++))\r\n\t\tif (listeners) {\r\n\t\t\tif (listeners[id] === undefined) {\r\n\t\t\t\tlisteners[id] = listeners.push(listener) - 1\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tpropertyListenersMap.set(value, listeners = [listener])\r\n\t\t\tlisteners[id] = 0\r\n\t\t\tif (Variable.autoObserveObjects) {\r\n\t\t\t\tobserve(value)\r\n\t\t\t}\r\n\t\t}\r\n\t\tlistener.listeningToObject = value\r\n\t}\r\n\tfunction deregisterListener(listener) {\r\n\t\tif (listener.listeningToObject) {\r\n\t\t\tvar value = listener.listeningToObject\r\n\t\t\tlistener.listeningToObject = null\r\n\t\t\tvar listeners = propertyListenersMap.get(value)\r\n\t\t\tif (listeners) {\r\n\t\t\t\tvar index = listeners[listener.listenerId]\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tlisteners.splice(index, 1)\r\n\t\t\t\t\tdelete listeners[listener.listenerId]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction RefreshEvent() {\r\n\t\tthis.visited = new Set()\r\n\t}\r\n\tRefreshEvent.prototype.type = 'refresh'\r\n\r\n\tfunction PropertyChangeEvent(key, childEvent, parent) {\r\n\t\tthis.key = key\r\n\t\tthis.childEvent = childEvent\r\n\t\tthis.parent = parent\r\n\t\tthis.visited = childEvent.visited\r\n\t}\r\n\tPropertyChangeEvent.prototype.type = 'update'\r\n\r\n\tfunction AddEvent(args) {\r\n\t\tthis.visited = new Set()\r\n\t\tfor (var key in args) {\r\n\t\t\tthis[key] = args[key]\r\n\t\t}\r\n\t}\r\n\tAddEvent.prototype.type = 'add'\r\n\tfunction DeleteEvent(args) {\r\n\t\tthis.visited = new Set()\r\n\t\tfor (var key in args) {\r\n\t\t\tthis[key] = args[key]\r\n\t\t}\r\n\t}\r\n\tDeleteEvent.prototype.type = 'delete'\r\n\r\n\tfunction forPropertyNotifyingValues(properties, callback) {\r\n\t\tfor (var key in properties) {\r\n\t\t\tvar property = properties[key]\r\n\t\t\tif (property.returnedVariable) {\r\n\t\t\t\tcallback(property.returnedVariable)\r\n\t\t\t}\r\n\t\t\tif (property.hasChildNotifiers) {\r\n\t\t\t\tvar subProperties = property._properties\r\n\t\t\t\tif (subProperties) {\r\n\t\t\t\t\tforPropertyNotifyingValues(subProperties, callback)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction Variable(value) {\r\n\t\tif (this instanceof Variable) {\r\n\t\t\t// new call, may eventually use new.target\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tif (this.default !== undefined) {\r\n\t\t\t\t\tthis.value = this.default\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.value = value\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn Variable.extend(value)\r\n\t\t}\r\n\t}\r\n\tvar VariablePrototype = Variable.prototype = {\r\n\t\t// for debugging use\r\n\t\tget _currentValue() {\r\n\t\t\treturn this.valueOf()\r\n\t\t},\r\n\t\tset _currentValue(value) {\r\n\t\t\tthis.put(value)\r\n\t\t},\r\n\t\tconstructor: Variable,\r\n\t\tvalueOf: function(context) {\r\n\t\t\tvar valueContext\r\n\t\t\tif (this.parent) {\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tvalueContext = context.newContext()\r\n\t\t\t\t\tvalueContext.nextProperty = 'parent'\r\n\t\t\t\t}\r\n\t\t\t\tvar key = this.key\r\n\t\t\t\tvar property = this\r\n\t\t\t\tvar object = this.parent.valueOf(valueContext)\r\n\t\t\t\tvar gotValueAndListen = function(object) {\r\n\t\t\t\t\tvar value = property.gotValue(object == null ? undefined : typeof object.get === 'function' ? object.get(key) : object[key], context, valueContext)\r\n\t\t\t\t\tif (property.listeners) {\r\n\t\t\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t\t\tif (listeners && listeners.observer && listeners.observer.addKey) {\r\n\t\t\t\t\t\t\tlisteners.observer.addKey(key)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\tif (object && object.then) {\r\n\t\t\t\t\t// call it initially so the dependencies can be registered\r\n\t\t\t\t\tthis.gotValue(null, context, valueContext)\r\n\t\t\t\t\treturn when(object, gotValueAndListen)\r\n\t\t\t\t}\r\n\t\t\t\treturn gotValueAndListen(object)\r\n\t\t\t}\r\n\t\t\treturn this.gotValue(this.getValue ?\r\n\t\t\t\tthis.getValue(context && (valueContext = context.newContext())) :\r\n\t\t\t\tthis.value, context, valueContext)\r\n\t\t},\r\n\t\tgotValue: function(value, parentContext, context) {\r\n\t\t\tvar previousNotifyingValue = this.returnedVariable\r\n\t\t\tvar variable = this\r\n\t\t\tif (previousNotifyingValue) {\r\n\t\t\t\tif (value === previousNotifyingValue) {\r\n\t\t\t\t\t// nothing changed, immediately return valueOf (or ownObject if we have it)\r\n\t\t\t\t\tif (variable.ownObject) {\r\n\t\t\t\t\t\treturn variable.ownObject\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (parentContext) {\r\n\t\t\t\t\t\tif (!context) {\r\n\t\t\t\t\t\t\tcontext = parentContext.newContext()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcontext.contextualize(this, parentContext)\r\n\t\t\t\t\t\tcontext.nextProperty = 'returnedVariable'\r\n\t\t\t\t\t\treturn value.valueOf(context)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn value.valueOf()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// if there was a another value that we were dependent on before, stop listening to it\r\n\t\t\t\t// TODO: we may want to consider doing cleanup after the next rendering turn\r\n\t\t\t\tif (variable.listeners) {\r\n\t\t\t\t\tpreviousNotifyingValue.stopNotifies(variable)\r\n\t\t\t\t}\r\n\t\t\t\tvariable.returnedVariable = null\r\n\t\t\t}\r\n\t\t\tif (value && value.notifies) {\r\n\t\t\t\tvariable.returnedVariable = value\r\n\t\t\t\tif (variable.listeners) {\r\n\t\t\t\t\tvalue.notifies(variable)\r\n\t\t\t\t}\r\n\t\t\t\t/*var parent = variable\r\n\t\t\t\tdo {\r\n\t\t\t\t\tif (parent.listeners) {\r\n\t\t\t\t\t\t// the value is another variable, start receiving notifications, if we, or any parent is live\r\n\t\t\t\t\t\tvariable.returnedVariable.notifies(variable)\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\t\t\t\t\tparent.hasNotifyingChild = true\r\n\t\t\t\t} while((parent = parent.parent))*/\r\n\t\t\t\tcontext = context || parentContext && (context = parentContext.newContext())\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.nextProperty = 'returnedVariable'\r\n\t\t\t\t}\r\n\t\t\t\tvalue = value.valueOf(context)\r\n\t\t\t\tif (variable.ownObject) {\r\n\t\t\t\t\tif (getPrototypeOf(variable.ownObject) !== value) {\r\n\t\t\t\t\t\tsetPrototypeOf(variable.ownObject, value)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvalue = variable.ownObject\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tvalue = variable.default\r\n\t\t\t}\r\n\t\t\tif (context) {\r\n\t\t\t\tcontext.contextualize(this, parentContext)\r\n\t\t\t}\r\n\t\t\tif (parentContext) {\r\n\r\n\t\t\t\t/*if (!contextualized.listeners) {\r\n\t\t\t\t\t// mark it as initialized, since we have already recursively dependended on inputs\r\n\t\t\t\t\tcontextualized.listeners = []\r\n\t\t\t\t}*/\r\n\r\n\t\t\t\tif (!context) {\r\n\t\t\t\t\tparentContext.addInput(this)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (value && value.then) {\r\n\t\t\t\treturn when(value, function(value) {\r\n\t\t\t\t\treturn Variable.prototype.gotValue.call(variable, value, context)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\treturn value\r\n\t\t},\r\n\t\tisMap: function() {\r\n\t\t\treturn this.value instanceof Map\r\n\t\t},\r\n\t\tproperty: function(key, PropertyClass) {\r\n\t\t\tvar isMap = this.isMap()\r\n\t\t\tvar properties = this._properties || (this._properties = isMap ? new Map() : {})\r\n\t\t\tvar propertyVariable = isMap ? properties.get(key) : properties[key]\r\n\t\t\tif (!propertyVariable) {\r\n\t\t\t\t// create the property variable\r\n\t\t\t\tpropertyVariable = new (PropertyClass || Variable)()\r\n\t\t\t\tpropertyVariable.key = key\r\n\t\t\t\tpropertyVariable.parent = this\r\n\t\t\t\tif (isMap) {\r\n\t\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tproperties[key] = propertyVariable\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn propertyVariable\r\n\t\t},\r\n\t\tfor: function(subject) {\r\n\t\t\tif (subject && subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t// makes HTML events work\r\n\t\t\t\tsubject = subject.target\r\n\t\t\t}\r\n\t\t\tif (this.parent) {\r\n\t\t\t\treturn this.parent.for(subject).property(this.key)\r\n\t\t\t}\r\n\t\t\treturn new ContextualizedVariable(this, subject || defaultContext)\r\n\t\t},\r\n\t\t_changeValue: function(context, type, newValue) {\r\n\t\t\tvar key = this.key\r\n\t\t\tvar parent = this.parent\r\n\t\t\tvar variable = this\r\n\t\t\tparent._willModify(context)\r\n\t\t\treturn when(parent.valueOf(context), function(object) {\r\n\t\t\t\tif (object == null) {\r\n\t\t\t\t\t// nothing there yet, create an object to hold the new property\r\n\t\t\t\t\tvar response = parent.put(object = typeof key == 'number' ? [] : {}, context)\r\n\t\t\t\t} else if (typeof object != 'object') {\r\n\t\t\t\t\t// if the parent is not an object, we can't set anything (that will be retained)\r\n\t\t\t\t\treturn deny\r\n\t\t\t\t}\r\n\t\t\t\tvar oldValue = typeof object.get === 'function' ? object.get(key) : object[key]\r\n\t\t\t\tif (oldValue === newValue) {\r\n\t\t\t\t\t// no actual change to make\r\n\t\t\t\t\treturn noChange\r\n\t\t\t\t}\r\n\t\t\t\tif (variable.__debug) {\r\n\t\t\t\t\t// debug is on\r\n\t\t\t\t\tconsole.log('Variable changed from', oldValue, newValue, 'at')\r\n\t\t\t\t\tconsole.log((new Error().stack || '').replace(/Error/, ''))\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof object.set === 'function') {\r\n\t\t\t\t\tobject.set(key, newValue)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (type == RequestChange && oldValue && oldValue.put) {\r\n\t\t\t\t\t\t// if a put and the property value is a variable, assign it to that.\r\n\t\t\t\t\t\toldValue.put(newValue)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tobject[key] = newValue\r\n\t\t\t\t\t\t// or set the setter/getter\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvariable.updated(null, variable, context)\r\n\r\n\t\t\t\t// now notify any object listeners\r\n\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\t// we need to do it before the other listeners, so we can update it before\r\n\t\t\t\t// we trigger a full clobbering of the object\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tlisteners = listeners.slice(0)\r\n\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\tif (listener !== parent) {\r\n\t\t\t\t\t\t\t// now go ahead and actually trigger the other listeners (but make sure we don't do the parent again)\r\n\t\t\t\t\t\t\tlistener._propertyChange(key, object, context, type)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\t_propertyChange: function(propertyName, object, context, type) {\r\n\t\t\tif (this.onPropertyChange) {\r\n\t\t\t\tthis.onPropertyChange(propertyName, object, context)\r\n\t\t\t}\r\n\t\t\tthis.updated(new PropertyChangeEvent(propertyName, new RefreshEvent(), this), null, context)\r\n\t\t},\r\n\t\teachKey: function(callback) {\r\n\t\t\tfor (var i in this._properties) {\r\n\t\t\t\tcallback(i)\r\n\t\t\t}\r\n\t\t},\r\n\t\tapply: function(instance, args) {\r\n\t\t\treturn new Call(this, args)\r\n\t\t},\r\n\t\tcall: function(instance) {\r\n\t\t\treturn this.apply(instance, Array.prototype.slice.call(arguments, 1))\r\n\t\t},\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tif (this.returnedVariable) {\r\n\t\t\t\tcallback(this.returnedVariable)\r\n\t\t\t}\r\n\t\t\tif (this.hasNotifyingChild) {\r\n\t\t\t\tvar properties = this._properties\r\n\t\t\t\tif (properties) {\r\n\t\t\t\t\tforPropertyNotifyingValues(properties, callback)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.parent) {\r\n\t\t\t\tcallback(this.parent)\r\n\t\t\t}\r\n\t\t},\r\n\t\tinit: function() {\r\n\t\t\tvar variable = this\r\n\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\tdependency.notifies(variable)\r\n\t\t\t})\r\n\r\n\t\t\tif (this.listeningToObject === null) {\r\n\t\t\t\t// we were previously listening to an object, but it needs to be restored\r\n\t\t\t\t// calling valueOf will cause the listening object to be restored\r\n\t\t\t\tthis.valueOf()\r\n\t\t\t}\r\n\t\t},\r\n\t\tcleanup: function() {\r\n\t\t\tthis.listeners = false\r\n\t\t\tvar handles = this.handles\r\n\t\t\tif (handles) {\r\n\t\t\t\tfor (var i = 0; i < handles.length; i++) {\r\n\t\t\t\t\thandles[i].remove()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.handles = null\r\n\t\t\tvar returnedVariable = this.returnedVariable\r\n\t\t\tif (returnedVariable) {\r\n\t\t\t\t// TODO: move this into the caching class\r\n\t\t\t\tthis.computedVariable = null\r\n\t\t\t}\r\n\t\t\tvar variable = this\r\n\t\t\tthis.forDependencies(function(dependency) {\r\n\t\t\t\tdependency.stopNotifies(variable)\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\tupdateVersion: function(version) {\r\n\t\t\tthis.version = nextId++\r\n\t\t},\r\n\r\n\t\tgetVersion: function(context) {\r\n\t\t\treturn Math.max(this.version || 0, this.returnedVariable && this.returnedVariable.getVersion ? this.returnedVariable.getVersion(context) : 0)\r\n\t\t},\r\n\r\n\t\tgetSubject: function(selectVariable) {\r\n\t\t\treturn this.subject\r\n\t\t},\r\n\r\n\t\tgetUpdates: function(since) {\r\n\t\t\tvar updates = []\r\n\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\tif (nextUpdateMap && since) {\r\n\t\t\t\twhile ((since = nextUpdateMap.get(since))) {\r\n\t\t\t\t\tif (since.type === 'refresh') {\r\n\t\t\t\t\t\t// if it was refresh, we can clear any prior entries\r\n\t\t\t\t\t\tupdates = []\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdates.push(since)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn updates\r\n\t\t},\r\n\r\n\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\tif (!updateEvent) {\r\n\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t}\r\n\t\t\tif (updateEvent.visited.has(this)){\r\n\t\t\t\t// if this event has already visited this variable, skip it\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tupdateEvent.visited.add(this)\r\n\t\t\tvar contextualInstance = context ? context.getContextualized(this) : this\r\n\t\t\tif (contextualInstance) {\r\n\t\t\t\tcontextualInstance.updated(updateEvent, this, context)\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\t// at some point we could do an update list so that we could incrementally update\r\n\t\t\t// lists in non-live situations\r\n\t\t\tif (this.lastUpdate) {\r\n\t\t\t\tvar nextUpdateMap = this.nextUpdateMap\r\n\t\t\t\tif (!nextUpdateMap) {\r\n\t\t\t\t\tnextUpdateMap = this.nextUpdateMap = new WeakMap()\r\n\t\t\t\t}\r\n\t\t\t\tnextUpdateMap.set(this.lastUpdate, updateEvent)\r\n\t\t\t}\r\n\r\n\t\t\tthis.lastUpdate = updateEvent */\r\n\t\t\tthis.updateVersion()\r\n\r\n\t\t\tvar listeners = this.listeners\r\n\t\t\tif (listeners) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\t// make a copy, in case they change\r\n\t\t\t\tlisteners.forEach(function(dependent) {\r\n\t\t\t\t\tif ((updateEvent instanceof PropertyChangeEvent) &&\r\n\t\t\t\t\t\t\tdependent.parent) {\r\n\t\t\t\t\t\tif (dependent.key === updateEvent.key) {\r\n\t\t\t\t\t\t\tdependent.updated(updateEvent.childEvent, variable, context)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdependent.updated(updateEvent, variable, context)\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (updateEvent instanceof PropertyChangeEvent) {\r\n\t\t\t\tif (this.returnedVariable && this.fixed) {\r\n\t\t\t\t\tthis.returnedVariable.updated(updateEvent, this, context)\r\n\t\t\t\t}\r\n\t\t\t\tif (this.constructor.collection) {\r\n\t\t\t\t\tthis.constructor.collection.updated(updateEvent, this, context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.parent) {\r\n\t\t\t\t\tthis.parent.updated(new PropertyChangeEvent(this.key, updateEvent, this.parent), this, context)\r\n\t\t\t}\r\n\t\t\treturn updateEvent\r\n\t\t},\r\n\r\n\t\tinvalidate: function() {\r\n\t\t\t// for back-compatibility for now\r\n\t\t\tthis.updated()\r\n\t\t},\r\n\r\n\t\tnotifies: function(target) {\r\n\t\t\tvar listeners = this.listeners\r\n\t\t\tif (!listeners || !this.hasOwnProperty('listeners')) {\r\n\t\t\t\tthis.listeners = listeners = new Set()\r\n\t\t\t\tthis.init()\r\n\t\t\t}\r\n\t\t\tlisteners.add(target)\r\n\t\t},\r\n\t\tsubscribe: function(listener) {\r\n\t\t\t// ES7 Observable (and baconjs) compatible API\r\n\t\t\tvar updated\r\n\t\t\tvar updateQueued\r\n\t\t\tvar variable = this\r\n\t\t\t// it is important to make sure you register for notifications before getting the value\r\n\t\t\tif (typeof listener === 'function') {\r\n\t\t\t\t// BaconJS compatible API\r\n\t\t\t\tvar variable = this\r\n\t\t\t\tvar event = {\r\n\t\t\t\t\tvalue: function() {\r\n\t\t\t\t\t\treturn variable.valueOf()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tupdated = function() {\r\n\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\tlistener(event)\r\n\t\t\t\t}\r\n\t\t\t}\telse if (listener.next) {\r\n\t\t\t\t// Assuming ES7 Observable API. It is actually a streaming API, this pretty much violates all principles of reactivity, but we will support it\r\n\t\t\t\tupdated = function() {\r\n\t\t\t\t\tupdateQueued = false\r\n\t\t\t\t\tlistener.next(variable.valueOf())\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error('Subscribing to an invalid listener, the listener must be a function, or have an update or next method')\r\n\t\t\t}\r\n\t\t\tvar updateReceiver = {\r\n\t\t\t\tupdated: function() {\r\n\t\t\t\t\tif (updateQueued) {\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\tupdateQueued = true\r\n\t\t\t\t\tlang.nextTurn(updated)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tupdated()\r\n\t\t\tthis.notifies(updateReceiver)\r\n\t\t\treturn {\r\n\t\t\t\tunsubscribe: function() {\r\n\t\t\t\t\tvariable.stopNotifies(updateReceiver)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tstopNotifies: function(dependent) {\r\n\t\t\tvar listeners = this.listeners\r\n\t\t\tif (listeners) {\r\n\t\t\t\tlisteners.delete(dependent)\r\n\t\t\t\tif (listeners.size === 0) {\r\n\t\t\t\t\t// clear the listeners so it will be reinitialized if it has\r\n\t\t\t\t\t// listeners again\r\n\t\t\t\t\tthis.cleanup()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tput: function(value, context) {\r\n\t\t\tvar variable = this\r\n\t\t\tif (this.parent) {\r\n\t\t\t\treturn this._changeValue(context, RequestChange, value)\r\n\t\t\t}\r\n\t\t\tif (this.ownObject) {\r\n\t\t\t\tthis.ownObject = false\r\n\t\t\t}\r\n\t\t\treturn when(this.getValue ? this.getValue(context) : this.value, function(oldValue) {\r\n\t\t\t\tif (variable.__debug) {\r\n\t\t\t\t\t// debug is on\r\n\t\t\t\t\tconsole.log('Variable changed from', oldValue, newValue, 'at')\r\n\t\t\t\t\tconsole.log((new Error().stack || '').replace(/Error/, ''))\r\n\t\t\t\t}\r\n\t\t\t\tif (oldValue === value) {\r\n\t\t\t\t\treturn noChange\r\n\t\t\t\t}\r\n\t\t\t\tif (variable.fixed &&\r\n\t\t\t\t\t\t// if it is set to fixed, we see we can put in the current variable\r\n\t\t\t\t\t\toldValue && oldValue.put) {\r\n\t\t\t\t\treturn oldValue.put(value)\r\n\t\t\t\t}\r\n\t\t\t\treturn when(variable.setValue(value, context), function(value) {\r\n\t\t\t\t\tvariable.updated(new RefreshEvent(), variable, context)\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t},\r\n\t\tget: function(key) {\r\n\t\t\tif (this._properties && this._properties[key]) {\r\n\t\t\t\treturn this.property(key).valueOf()\r\n\t\t\t}\r\n\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\tvar value = object && (typeof object.get === 'function' ? object.get(key) : object[key])\r\n\t\t\t\tif (value && value.notifies) {\r\n\t\t\t\t\t// nested variable situation, get underlying value\r\n\t\t\t\t\treturn value.valueOf()\r\n\t\t\t\t}\r\n\t\t\t\treturn value\r\n\t\t\t})\r\n\t\t},\r\n\t\tset: function(key, value) {\r\n\t\t\t// TODO: create an optimized route when the property doesn't exist yet\r\n\t\t\tthis.property(key)._changeValue(null, RequestSet, value)\r\n\t\t},\r\n\t\tundefine: function(key, context) {\r\n\t\t\tthis.set(key, undefined, context)\r\n\t\t},\r\n\t\tproxy: function(proxiedVariable) {\r\n\t\t\tvar thisVariable = this\r\n\t\t\tthis.fixed = true\r\n\t\t\treturn when(this.setValue(proxiedVariable), function(value) {\r\n\t\t\t\tthisVariable.updated(new RefreshEvent(), thisVariable)\r\n\t\t\t\treturn thisVariable\r\n\t\t\t})\r\n\t\t},\r\n\t\tnext: function(value) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tthis.put(value)\r\n\t\t},\r\n\t\terror: function(error) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tvar listeners = this.listeners\r\n\t\t\tif (listeners) {\r\n\t\t\t\t// make a copy, in case they change\r\n\t\t\t\tlisteners.forEach(function(dependent) {\r\n\t\t\t\t\t// skip notifying property listeners if we are headed up the parent chain\r\n\t\t\t\t\tdependent.error(error)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t},\r\n\t\tcomplete: function(value) {\r\n\t\t\t// for ES7 observable compatibility\r\n\t\t\tthis.put(value)\r\n\t\t},\r\n\t\tsetValue: function(value) {\r\n\t\t\tthis.value = value\r\n\t\t},\r\n\t\tonValue: function(listener) {\r\n\t\t\treturn this.subscribe(function(event) {\r\n\t\t\t\tlang.when(event.value(), function(value) {\r\n\t\t\t\t\tlistener(value)\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t},\r\n\t\ttoJSON: function() {\r\n\t\t\treturn this.valueOf()\r\n\t\t},\r\n\t\ttoString: function() {\r\n\t\t\treturn this.valueOf()\r\n\t\t},\r\n\t\tforEach: function(callbackOrItemClass, callbackOrContext, context) {\r\n\t\t\t// iterate through current value of variable\r\n\t\t\tif (callbackOrItemClass.notifies) {\r\n\t\t\t\tvar collectionVariable = this\r\n\t\t\t\treturn this.forEach(function(item) {\r\n\t\t\t\t\tvar itemVariable = callbackOrItemClass.from(item)\r\n\t\t\t\t\tcallbackOrContext.call(this, itemVariable)\r\n\t\t\t\t}, context)\r\n\t\t\t}\r\n\t\t\treturn when(this.valueOf(callbackOrContext), function(value) {\r\n\t\t\t\tif (value && value.forEach) {\r\n\t\t\t\t\tvalue.forEach(callbackOrItemClass)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfor (var i in value) {\r\n\t\t\t\t\t\tcallbackOrItemClass.call(value, value[i], i)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\tto: function (transformFunction, reverse) {\r\n\t\t\tif (typeof transformFunction !== 'function') {\r\n\t\t\t\tif (typeof transformFunction === 'object') {\r\n\t\t\t\t\tthis.to(transformFunction.get, transformFunction.set)\r\n\t\t\t\t}\r\n\t\t\t\tthrow new Error('No function provided to transform')\r\n\t\t\t}\r\n\t\t\tif (reverse) {\r\n\t\t\t\ttransformFunction.reverse = function(value, args, context) {\r\n\t\t\t\t\t// for direct to, we can just use the first argument\r\n\t\t\t\t\treverse.call(this, args[0], context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn new Call(transformFunction, [this])\r\n\t\t},\r\n\t\tget schema() {\r\n\t\t\t// default schema is the constructor\r\n\t\t\tif (this.parent) {\r\n\t\t\t\tvar parentSchemaProperties = this.parent.schema.properties\r\n\t\t\t\treturn parentSchemaProperties && parentSchemaProperties[this.key]\r\n\t\t\t}\r\n\t\t\treturn this.returnedVariable ? this.returnedVariable.schema : this.constructor\r\n\t\t},\r\n\t\tset schema(schema) {\r\n\t\t\t// but allow it to be overriden\r\n\t\t\tObject.defineProperty(this, 'schema', {\r\n\t\t\t\tvalue: schema\r\n\t\t\t})\r\n\t\t},\r\n\t\tvalidate: function(target, schema) {\r\n\t\t\tif (this.returnedVariable) {\r\n\t\t\t\treturn this.returnedVariable.validate(target, schema)\r\n\t\t\t}\r\n\t\t\tif (this.parent) {\r\n\t\t\t\treturn this.parent.validate(target.valueOf(), schema)\r\n\t\t\t}\r\n\t\t\tif (schema && schema.type && (schema.type !== typeof target)) {\r\n\t\t\t\treturn ['Target type of ' + typeof target + ' does not match schema type of ' + schema.type]\r\n\t\t\t}\r\n\t\t\tvar valid = []\r\n\t\t\tvalid.isValid = true\r\n\t\t\treturn valid\r\n\t\t},\r\n\r\n\t\tget validation() {\r\n\t\t\tvar validation = new Validating(this)\r\n\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\tvalue: validation\r\n\t\t\t})\r\n\t\t\treturn validation\r\n\t\t},\r\n\t\tset validation(validation) {\r\n\t\t\t// but allow it to be overriden\r\n\t\t\tObject.defineProperty(this, 'validation', {\r\n\t\t\t\tvalue: validation\r\n\t\t\t})\r\n\t\t},\r\n\t\tset structured(structure) {\r\n\t\t\t// find any variable properties and attaches them as a property\r\n\t\t\tvar keys = Object.keys(this)\r\n\t\t\tvar properties = keys.length > 1 && this._properties || (this._properties = {})\r\n\t\t\tfor(var i = 0, l = keys.length; i < l; i++) {\r\n\t\t\t\tvar key = keys[i]\r\n\t\t\t\tvar value = this[key]\r\n\t\t\t\tif (value instanceof Variable) {\r\n\t\t\t\t\tvar existing = properties[key]\r\n\t\t\t\t\tif (existing) {\r\n\t\t\t\t\t\tif (existing !== value) {\r\n\t\t\t\t\t\t\t// an existing property exists, put in it\r\n\t\t\t\t\t\t\texisting.put(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (value.parent) {\r\n\t\t\t\t\t\t\tif (value.parent === this) {\r\n\t\t\t\t\t\t\t\tcontinue // just being assigned to another property\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// property already exists with different parent, make a proxy\r\n\t\t\t\t\t\t\t\tvar newValue = new Variable()\r\n\t\t\t\t\t\t\t\tnewValue.proxy(value)\r\n\t\t\t\t\t\t\t\tvalue = newValue\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalue.key = key\r\n\t\t\t\t\t\tvalue.parent = this\r\n\t\t\t\t\t\tproperties[key] = value\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetId: function() {\r\n\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t},\r\n\t\tobserveObject: function() {\r\n\t\t\tvar variable = this\r\n\t\t\treturn when(this.valueOf(), function(object) {\r\n\t\t\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\t\t\tif (!listeners) {\r\n\t\t\t\t\tpropertyListenersMap.set(object, listeners = [])\r\n\t\t\t\t}\r\n\t\t\t\tif (listeners.observerCount) {\r\n\t\t\t\t\tlisteners.observerCount++\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlisteners.observerCount = 1\r\n\t\t\t\t\tvar observer = listeners.observer = lang.observe(object, function(events) {\r\n\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\tfor (var j = 0, el = events.length; j < el; j++) {\r\n\t\t\t\t\t\t\t\tvar event = events[j]\r\n\t\t\t\t\t\t\t\tlistener._propertyChange(event.name, object)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (observer.addKey) {\r\n\t\t\t\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\t\t\t\tvar listener = listeners[i]\r\n\t\t\t\t\t\t\tlistener.eachKey(function(key) {\r\n\t\t\t\t\t\t\t\tobserver.addKey(key)\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tregisterListener(object, variable)\r\n\t\t\t\treturn {\r\n\t\t\t\t\tremove: function() {\r\n\t\t\t\t\t\tderegisterListener(object, variable)\r\n\t\t\t\t\t\tif (!(--listeners.observerCount)) {\r\n\t\t\t\t\t\t\tlisteners.observer.remove()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tdone: function() {\r\n\t\t\t\t\t\t// deliver changes\r\n\t\t\t\t\t\tlang.deliverChanges(observer)\r\n\t\t\t\t\t\tthis.remove()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\t\tgetCollectionOf: function() {\r\n\t\t\treturn this.constructor.collectionOf\r\n\t\t},\r\n\t\t_willModify: function(context) {\r\n\t\t\t// an intent to modify, so we need to make sure we have our own copy\r\n\t\t\t// of an object when necessary\r\n\t\t\tif (this.fixed) {\r\n\t\t\t\tif (this.value && this.value._willModify) {\r\n\t\t\t\t\treturn this.value._willModify(context)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!this.ownObject && this.value && this.value.notifies) {\r\n\t\t\t\tvar variable = this\r\n\t\t\t\treturn when(this.valueOf(context), function(value) {\r\n\t\t\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\t\t\tif (value instanceof Array) {\r\n\t\t\t\t\t\t\tvariable.ownObject = value.slice(0)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvariable.ownObject = Object.create(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t} else if (this.parent) {\r\n\t\t\t\tthis.parent._willModify()\r\n\t\t\t}\r\n\t\t},\r\n\t\t_sN: function(name) {\r\n\t\t\t// for compilers to set a name\r\n\t\t\tthis.name = name\r\n\t\t\treturn this\r\n\t\t},\r\n\t\tget _debug() {\r\n\t\t\tif (this.__debug === undefined) {\r\n\t\t\t\tthis.__debug = true\r\n\t\t\t}\r\n\t\t\treturn this.__debug\r\n\t\t},\r\n\t\tset _debug(_debug) {\r\n\t\t\tthis.__debug = _debug\r\n\t\t},\r\n\t\t// TODO: Move these to VArray\r\n\t\tsplice: function(startingIndex, removalCount) {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.splice.apply(array, args)\r\n\t\t\t\tremovedAt(this, results, startingIndex, removalCount, array.length)\r\n\t\t\t\tinsertedAt(this, [].slice.call(args, 2), startingIndex, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tpush: function() {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.push.apply(array, args)\r\n\t\t\t\tinsertedAt(this, args, array.length - args.length, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tunshift: function() {\r\n\t\t\tvar args = arguments\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.unshift.apply(array, args)\r\n\t\t\t\tinsertedAt(this, args, 0, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tpop: function() {\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.pop()\r\n\t\t\t\tremovedAt(this, [results], array.length, 1)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t},\r\n\t\tshift: function() {\r\n\t\t\treturn arrayToModify(this, function(array) {\r\n\t\t\t\tvar results = array.shift()\r\n\t\t\t\tremovedAt(this, [results], 0, 1, array.length)\r\n\t\t\t\treturn results\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\tfunction arrayToModify(variable, callback) {\r\n\t\tvariable._willModify()\r\n\t\t// TODO: switch this to allow promises\r\n\t\twhen(variable.cachedValue || variable.valueOf(), function(array) {\r\n\t\t\tif (!array) {\r\n\t\t\t\tvariable.put(array = [])\r\n\t\t\t}\r\n\t\t\tvariable.updateVersion()\r\n\t\t\tvar results = callback.call(variable, array)\r\n\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t\treturn results\r\n\t\t})\r\n\t}\r\n\r\n\tfunction insertedAt(variable, added, startingIndex, arrayLength) {\r\n\t\tvar addedCount = added.length\r\n\t\t// adjust the key positions of any index properties after splice\r\n\t\tif (addedCount > 0) {\r\n\t\t\tif (variable._properties) {\r\n\t\t\t\tvar arrayPosition\r\n\t\t\t\tfor (var i = arrayLength - addedCount; i > startingIndex;) {\r\n\t\t\t\t\tvar arrayPosition = variable._properties[--i]\r\n\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\tarrayPosition.key += addedCount\r\n\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// send out updates\r\n\t\t\tfor (var i = 0, l = added.length; i < l; i++) {\r\n\t\t\t\tvariable.updated(new AddEvent({\r\n\t\t\t\t\tvalue: added[i],\r\n\t\t\t\t\tindex: i + startingIndex,\r\n\t\t\t\t\tmodifier: variable\r\n\t\t\t\t}), variable)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction removedAt(variable, removed, startingIndex, removalCount, arrayLength) {\r\n\t\t// adjust the properties\r\n\t\tvar i = startingIndex + removalCount\r\n\t\tvar arrayPosition\r\n\t\tif (removalCount > 0) {\r\n\t\t\tif (variable._properties) {\r\n\t\t\t\tfor (var i = startingIndex + removalCount; i < arrayLength + removalCount; i++) {\r\n\t\t\t\t\tvar arrayPosition = variable._properties[i]\r\n\t\t\t\t\tif (arrayPosition) {\r\n\t\t\t\t\t\tvariable._properties[i] = undefined\r\n\t\t\t\t\t\tarrayPosition.key -= removalCount\r\n\t\t\t\t\t\tvariable._properties[arrayPosition.key] = arrayPosition\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// send out updates\r\n\t\t\tfor (var i = 0; i < removalCount; i++) {\r\n\t\t\t\tvariable.updated(new DeleteEvent({\r\n\t\t\t\t\tpreviousIndex: startingIndex,\r\n\t\t\t\t\toldValue: removed[i],\r\n\t\t\t\t\tmodifier: variable\r\n\t\t\t\t}), variable)\r\n\t\t\t}\r\n\t\t\tvariable.cachedVersion = variable.version // update the cached version so it doesn't need to be recomputed\r\n\t\t}\r\n\t}\r\n\r\n\tif (typeof Symbol !== 'undefined') {\r\n\t\tVariable.prototype[Symbol.iterator] = function() {\r\n\t\t\treturn this.valueOf()[Symbol.iterator]()\r\n\t\t}\r\n\t}\r\n\r\n\tVariable.VMap = lang.compose(Variable, function(value){\r\n\t\tthis.value = typeof value === 'undefined' ? this.default : value\r\n\t}, {\r\n\t\t// TODO: Move all the get and set functionality for maps out of Variable\r\n\t\tproperty: function(key) {\r\n\t\t\tvar properties = this._properties || (this._properties = new Map())\r\n\t\t\tvar propertyVariable = properties.get(key)\r\n\t\t\tif (!propertyVariable) {\r\n\t\t\t\t// create the property variable\r\n\t\t\t\tpropertyVariable = new Variable()\r\n\t\t\t\tpropertyVariable.key = key\r\n\t\t\t\tpropertyVariable.parent = this\r\n\t\t\t\tproperties.set(key, propertyVariable)\r\n\t\t\t}\r\n\t\t\treturn propertyVariable\r\n\t\t}\r\n\t})\r\n\r\n\tvar cacheNotFound = {}\r\n\tvar Caching = Variable.Caching = lang.compose(Variable, function(getValue, setValue) {\r\n\t\tif (getValue) {\r\n\t\t\tthis.getValue = getValue\r\n\t\t}\r\n\t\tif (setValue) {\r\n\t\t\tthis.setValue = setValue\r\n\t\t}\r\n\t}, {\r\n\t\tvalueOf: function(context) {\r\n\t\t\t// first check to see if we have the variable already computed\r\n\t\t\tvar contextualizedVariable = this\r\n\t\t\tif (context) {\r\n\t\t\t\tcontextualizedVariable = context.getContextualized(this)\r\n\t\t\t\tif (!contextualizedVariable && this.context && this.context.matches(context)) {\r\n\t\t\t\t\tcontextualizedVariable = this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (contextualizedVariable && contextualizedVariable.cachedVersion === contextualizedVariable.getVersion()) {\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.addInput(contextualizedVariable)\r\n\t\t\t\t}\r\n\t\t\t\treturn contextualizedVariable.cachedValue\r\n\t\t\t}\r\n\r\n\t\t\tvar variable = this\r\n\t\t\tfunction withComputedValue(computedValue) {\r\n\t\t\t\tif (computedValue && computedValue.notifies && variable.listeners) {\r\n\t\t\t\t\tvariable.computedVariable = computedValue\r\n\t\t\t\t}\r\n\t\t\t\tcomputedValue = variable.gotValue(computedValue, context, transformContext)\r\n\t\t\t\tvar contextualizedVariable = transformContext && transformContext.contextualized || variable\r\n\t\t\t\tcontextualizedVariable.cachedVersion = newVersion\r\n\t\t\t\tcontextualizedVariable.cachedValue = computedValue\r\n\t\t\t\tcontextualizedVariable.context = transformContext\r\n\t\t\t\treturn computedValue\r\n\t\t\t}\r\n\r\n\t\t\tvar transformContext\r\n\t\t\tif (context) {\r\n\t\t\t\ttransformContext = context.newContext()\r\n\t\t\t}\r\n\t\t\tvar newVersion = this.getVersion()\r\n\t\t\tvar computedValue = this.getValue(transformContext)\r\n\t\t\tif (computedValue && computedValue.then) {\r\n\t\t\t\t// call it initially so the dependencies can be registered\r\n\t\t\t\tthis.gotValue(null, context, transformContext)\r\n\t\t\t\treturn computedValue.then(withComputedValue)\r\n\t\t\t} else {\r\n\t\t\t\treturn withComputedValue(computedValue)\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\r\n\tfunction GetCache() {\r\n\t}\r\n\r\n\r\n\tvar Item = Variable.Item = lang.compose(Variable, function Item(value, content) {\r\n\t\tthis.value = value\r\n\t\tthis.collection = content\r\n\t}, {})\r\n\r\n\tvar Composite = Variable.Composite = lang.compose(Caching, function Composite(args) {\r\n\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\tthis['argument' + i] = args[i]\r\n\t\t}\r\n\t}, {\r\n\t\tforDependencies: function(callback) {\r\n\t\t\t// depend on the args\r\n\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\tvar argument, argumentName\r\n\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\tif (argument && argument.notifies) {\r\n\t\t\t\t\tcallback(argument)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tupdated: function(updateEvent, by, context) {\r\n\t\t\tif (by !== this.returnedVariable && updateEvent && updateEvent.type !== 'refresh') {\r\n\t\t\t\t// search for the output in the inputs\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\t\tif (argument === by) {\r\n\t\t\t\t\t\t// if one of the args was updated, we need to do a full refresh (we can't compute differential events without knowledge of how the mapping function works)\r\n\t\t\t\t\t\tupdateEvent = new RefreshEvent()\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn Caching.prototype.updated.call(this, updateEvent, by, context)\r\n\t\t},\r\n\r\n\t\tgetUpdates: function(since) {\r\n\t\t\t// this always issues updates, nothing incremental can flow through it\r\n\t\t\tif (!since || since.version < getVersion()) {\r\n\t\t\t\treturn [new RefreshEvent()]\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetVersion: function(context) {\r\n\t\t\tvar version = Variable.prototype.getVersion.call(this, context)\r\n\t\t\tvar argument, argumentName\r\n\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\tif (argument && argument.getVersion) {\r\n\t\t\t\t\tversion = Math.max(version, argument.getVersion(context))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn version\r\n\t\t},\r\n\r\n\t\tgetValue: function(context) {\r\n\t\t\tvar results = []\r\n\t\t\tvar argument, argumentName\r\n\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t}\r\n\t\t\t\tresults[i] = argument && argument.valueOf(context)\r\n\t\t\t}\r\n\t\t\treturn whenAll(results, function(resolved) {\r\n\t\t\t\treturn resolved\r\n\t\t\t})\r\n\t\t},\r\n\t\tgetArguments: function() {\r\n\t\t\tvar args = []\r\n\t\t\tvar argument, argumentName\r\n\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\targs.push(argument)\r\n\t\t\t}\r\n\t\t\treturn args\r\n\t\t}\r\n\t})\r\n\r\n\t// a call variable is the result of a call\r\n\tvar Call = lang.compose(Composite, function Transform(transform, args) {\r\n\t\tthis.transform = transform\r\n\t\tfor (var i = 0, l = args.length; i < l; i++) {\r\n\t\t\tthis['argument' + i] = args[i]\r\n\t\t}\r\n\t}, {\r\n\t\tfixed: true,\r\n\t\tforDependencies: function(callback) {\r\n\t\t\t// depend on the args\r\n\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\tif (this.transform.notifies) {\r\n\t\t\t\tcallback(this.transform)\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetValue: function(context) {\r\n\t\t\tif (context) {\r\n\t\t\t\tcontext.nextProperty = 'transform'\r\n\t\t\t}\r\n\t\t\tvar functionValue = this.transform.valueOf(context)\r\n\t\t\tif (functionValue.then) {\r\n\t\t\t\tvar call = this\r\n\t\t\t\treturn functionValue.then(function(functionValue) {\r\n\t\t\t\t\treturn call.invoke(functionValue, context)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\treturn this.invoke(functionValue, context)\r\n\t\t},\r\n\r\n\t\tgetVersion: function(context) {\r\n\t\t\t// TODO: shortcut if we are live and since equals this.lastUpdate\r\n\t\t\tvar argsVersion = Composite.prototype.getVersion.call(this, context)\r\n\t\t\tif (this.transform.getVersion) {\r\n\t\t\t\treturn Math.max(argsVersion, this.transform.getVersion(context))\r\n\t\t\t}\r\n\t\t\treturn argsVersion\r\n\t\t},\r\n\r\n\t\texecute: function(context) {\r\n\t\t\tvar call = this\r\n\t\t\treturn when(this.transform.valueOf(context), function(functionValue) {\r\n\t\t\t\treturn call.invoke(functionValue, context, true)\r\n\t\t\t})\r\n\t\t},\r\n\r\n\t\tput: function(value, context) {\r\n\t\t\tvar call = this\r\n\t\t\treturn when(this.valueOf(context), function(originalValue) {\r\n\t\t\t\tif (originalValue === value) {\r\n\t\t\t\t\treturn noChange\r\n\t\t\t\t}\r\n\t\t\t\treturn when(call.transform.valueOf(context), function(functionValue) {\r\n\t\t\t\t\treturn call.invoke(function() {\r\n\t\t\t\t\t\tif (functionValue.reverse) {\r\n\t\t\t\t\t\t\tfunctionValue.reverse.call(call, value, call.getArguments(), context)\r\n\t\t\t\t\t\t\treturn Variable.prototype.put.call(call, value, context)\r\n\t\t\t\t\t\t} else if (originalValue && originalValue.put) {\r\n\t\t\t\t\t\t\treturn originalValue.put(value)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn deny\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, context)\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t},\r\n\t\tinvoke: function(functionValue, context, observeArguments) {\r\n\t\t\tvar instance = this.transform.parent\r\n\t\t\tif (functionValue.handlesVariables || functionValue.property) {\r\n\t\t\t\treturn functionValue.apply(instance, this.getArguments(), context)\r\n\t\t\t}else{\r\n\t\t\t\tvar results = []\r\n\t\t\t\tvar argument, argumentName\r\n\t\t\t\tfor (var i = 0; (argument = this[argumentName = 'argument' + i]) || argumentName in this; i++) {\r\n\t\t\t\t\tif (context) {\r\n\t\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresults[i] = argument && argument.valueOf(context)\r\n\t\t\t\t}\r\n\t\t\t\tinstance = instance && instance.valueOf(context)\r\n\t\t\t\tif (functionValue.handlesPromises) {\r\n\t\t\t\t\treturn functionValue.apply(instance, results, context)\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// include the instance in whenAll\r\n\t\t\t\t\tresults.push(instance)\r\n\t\t\t\t\t// wait for the values to be received\r\n\t\t\t\t\treturn whenAll(results, function(inputs) {\r\n\t\t\t\t\t\tif (observeArguments) {\r\n\t\t\t\t\t\t\tvar handles = []\r\n\t\t\t\t\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\t\tif (input && typeof input === 'object') {\r\n\t\t\t\t\t\t\t\t\thandles.push(observe(input))\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\tvar result = functionValue.apply(instance, inputs, context)\r\n\t\t\t\t\t\t\t}finally{\r\n\t\t\t\t\t\t\t\twhen(result, function() {\r\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < l; i++) {\r\n\t\t\t\t\t\t\t\t\t\thandles[i].done()\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar instance = inputs.pop()\r\n\t\t\t\t\t\treturn functionValue.apply(instance, inputs, context)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tsetReverse: function(reverse) {\r\n\t\t\tthis.transform.valueOf().reverse = reverse\r\n\t\t\treturn this\r\n\t\t},\r\n\t\tgetCollectionOf: function() {\r\n\t\t\treturn this.returnedVariable && this.returnedVariable.getCollectionOf()\r\n\t\t}\r\n\t})\r\n\tVariable.Call = Call\r\n\r\n\tvar ContextualizedVariable = lang.compose(Variable, function ContextualizedVariable(generic, subject) {\r\n\t\tthis.generic = generic\r\n\t\tthis.subject = subject\r\n\t}, {\r\n\t\tvalueOf: function() {\r\n\t\t\t// TODO: Lookup Context type for all of these using registry or something\r\n\t\t\tvar subject = this.subject\r\n\t\t\treturn this.generic.valueOf(subject.getContextualized ? subject : new Context(subject))\r\n\t\t},\r\n\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tthis.inputs && this.inputs.forEach(callback)\r\n\t\t},\r\n\r\n\t\tgetVersion: function() {\r\n\t\t\tvar version = Variable.prototype.getVersion.call(this)\r\n\t\t\tvar inputs = this.inputs || 0\r\n\t\t\tfor (var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\tvar input = inputs[i]\r\n\t\t\t\tif (input.getVersion) {\r\n\t\t\t\t\tversion = Math.max(version, input.getVersion())\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn version\r\n\t\t},\r\n\r\n\t\tput: function(value) {\r\n\t\t\tvar subject = this.subject\r\n\t\t\treturn this.generic.put(value, subject.getContextualized ? subject : new Context(subject))\r\n\t\t}\r\n\t})\r\n\r\n\tvar IterativeMethod = lang.compose(Composite, function(source, method, args) {\r\n\t\tthis.source = source\r\n\t\t// source.interestWithin = true\r\n\t\tthis.method = method\r\n\t\tthis.arguments = args\r\n\t}, {\r\n\t\tgetValue: function(context) {\r\n\t\t\tvar method = this.method\r\n\t\t\tvar args = this.arguments\r\n\t\t\tvar variable = this\r\n\t\t\tif (context) {\r\n\t\t\t\tcontext.nextProperty = 'source'\r\n\t\t\t}\r\n\t\t\treturn when(this.source.valueOf(context), function(array) {\r\n\t\t\t\tif (array && array.forEach) {\r\n\t\t\t\t\tif (context && context.notify) {\r\n\t\t\t\t\t\tvar contextualizedVariable\r\n\t\t\t\t\t\tif (context.distinctSubject) {\r\n\t\t\t\t\t\t\tvar contextMap = variable._contextMap || (variable._contextMap = new WeakMap())\r\n\t\t\t\t\t\t\tif (contextMap.has(context.distinctSubject)) {\r\n\t\t\t\t\t\t\t\tcontextualizedVariable = contextMap.get(context.distinctSubject)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcontextMap.set(context.distinctSubject, contextualizedVariable = Object.create(variable))\r\n\t\t\t\t\t\t\t\tcontextualizedVariable.listeners = false\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tcontextualizedVariable = variable\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvariable.notifies(contextualizedVariable)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (method === 'map'){\r\n\t\t\t\t\t\t// fast path, and special behavior for map\r\n\t\t\t\t\t\treturn args[0](array)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// if not an array convert to an array\r\n\t\t\t\t\tarray = [array]\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof method === 'string') {\r\n\t\t\t\t\t// apply method\r\n\t\t\t\t\treturn array[method].apply(array, args)\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn method(array, args)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t},\r\n\t\t// TODO: Create specialized updated handlers for faster recomputation of other array derivatives\r\n\t\tforDependencies: function(callback) {\r\n\t\t\t// depend on the args\r\n\t\t\tComposite.prototype.forDependencies.call(this, callback)\r\n\t\t\tcallback(this.source)\r\n\t\t},\r\n\t\tgetVersion: function(context) {\r\n\t\t\treturn Math.max(Composite.prototype.getVersion.call(this, context), this.source.getVersion(context))\r\n\t\t},\r\n\t\tgetCollectionOf: function(){\r\n\t\t\treturn this.source.getCollectionOf()\r\n\t\t}\r\n\t})\r\n\r\n\tfunction defineArrayMethod(method, constructor, properties) {\r\n\t\tvar IterativeResults = lang.compose(IterativeMethod, constructor, properties)\r\n\t\tIterativeResults.prototype.method || (IterativeResults.prototype.method = method)\r\n\t\tObject.defineProperty(IterativeResults.prototype, 'isIterable', {value: true});\r\n\t\tVariable.prototype[method] = function() {\r\n\t\t\tvar results = new IterativeResults()\r\n\t\t\tresults.source = this\r\n\t\t\tresults.arguments = arguments\r\n\t\t\treturn results\r\n\t\t}\r\n\t}\r\n\r\n\tdefineArrayMethod('filter', function Filtered() {}, {\r\n\t\tupdated: function(event, by, context) {\r\n\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t}\r\n\t\t\tvar contextualizedVariable = context ? context.getContextualized(this) : this\r\n\t\t\tif (event.type === 'delete') {\r\n\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(event.oldValue)\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t}\r\n\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\tif ([event.value].filter(this.arguments[0]).length > 0) {\r\n\t\t\t\t\tcontextualizedVariable.push(event.value)\r\n\t\t\t\t}\r\n\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\tvar index = contextualizedVariable.cachedValue.indexOf(object)\r\n\t\t\t\tvar matches = [object].filter(this.arguments[0]).length > 0\r\n\t\t\t\tif (index > -1) {\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\treturn new PropertyChangeEvent(index, event, contextualizedVariable.cachedValue,\r\n\t\t\t\t\t\t\t// might need to do something with this\r\n\t\t\t\t\t\t\tobject)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcontextualizedVariable.splice(index, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\telse {\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\tcontextualizedVariable.push(object)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// else nothing mactches\r\n\t\t\t\t}\r\n\t\t\t\treturn\r\n\t\t\t} else {\r\n\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\tdefineArrayMethod('map', function Mapped() {}, {\r\n\t\tupdated: function(event, by, context) {\r\n\t\t\tif (!event || event.modifier === this || (event.modifier && event.modifier.constructor === this)) {\r\n\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t}\r\n\t\t\tvar contextualizedVariable = context ? context.getContextualized(this) : this\r\n\t\t\tif (event.type === 'delete') {\r\n\t\t\t\tcontextualizedVariable.splice(event.previousIndex, 1)\r\n\t\t\t} else if (event.type === 'add') {\r\n\t\t\t\tcontextualizedVariable.push(this.arguments[0].call(this.arguments[1], event.value))\r\n\t\t\t} else if (event.type === 'update') {\r\n\t\t\t\tvar object = event.parent.valueOf(context)\r\n\t\t\t\tvar array = contextualizedVariable.cachedValue\r\n\t\t\t\tif (array && array.map) {\r\n\t\t\t\t\tvar index = array.indexOf(object)\r\n\t\t\t\t\tvar matches = [object].filter(this.arguments[0]).length > 0\r\n\t\t\t\t\tcontextualizedVariable.splice(index, 1, this.arguments[0].call(this.arguments[1], event.value))\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn Composite.prototype.updated.call(this, event, by, context)\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\tdefineArrayMethod('reduce', function Reduced() {})\r\n\tdefineArrayMethod('reduceRight', function Reduced() {})\r\n\tdefineArrayMethod('some', function Aggregated() {})\r\n\tdefineArrayMethod('every', function Aggregated() {})\r\n\tdefineArrayMethod('slice', function Aggregated() {})\r\n\tdefineArrayMethod('keyBy', function UniqueIndex(source, args) {}, {\r\n\t\tisMap: function () {\r\n\t\t\treturn true\r\n\t\t},\r\n\t\tmethod: function(array, args) {\r\n\t\t\tvar index = new Map()\r\n\t\t\tvar keyGenerator = args[0]\r\n\t\t\tvar valueGenerator = args[1]\r\n\t\t\tvar hasKeyFunction = typeof keyGenerator === 'function'\r\n\t\t\tvar hasValueFunction = typeof valueGenerator === 'function'\r\n\t\t\tvar hasKey = !!keyGenerator\r\n\t\t\tfor (var i = 0, l = array.length; i < l; i++) {\r\n\t\t\t\tvar element = array[i]\r\n\t\t\t\tindex.set(\r\n\t\t\t\t\thasKeyFunction ? keyGenerator(element) :\r\n\t\t\t\t\t\thasKey ? element[keyGenerator] : element,\r\n\t\t\t\t\thasValueFunction ? valueGenerator(element) : element)\r\n\t\t\t}\r\n\t\t\treturn index\r\n\t\t}\r\n\t})\r\n\r\n\tdefineArrayMethod('groupBy', function UniqueIndex(source, args) {}, {\r\n\t\tisMap: function () {\r\n\t\t\treturn true\r\n\t\t},\r\n\t\tmethod: function(array, args) {\r\n\t\t\tvar index = new Map()\r\n\t\t\tvar keyGenerator = args[0]\r\n\t\t\tvar valueGenerator = args[1]\r\n\t\t\tvar hasKeyFunction = typeof keyGenerator === 'function'\r\n\t\t\tvar hasValueFunction = typeof valueGenerator === 'function'\r\n\t\t\tvar hasKey = !!keyGenerator\r\n\t\t\tfor (var i = 0, l = array.length; i < l; i++) {\r\n\t\t\t\tvar element = array[i]\r\n\t\t\t\tvar key = hasKeyFunction ? keyGenerator(element) :\r\n\t\t\t\t\t\thasKey ? element[keyGenerator] : element\r\n\t\t\t\tvar group = index.get(key)\r\n\t\t\t\tif (!group) {\r\n\t\t\t\t\tindex.set(key, group = [])\r\n\t\t\t\t}\r\n\t\t\t\tgroup.push(hasValueFunction ? valueGenerator(element) : element)\r\n\t\t\t}\r\n\t\t\treturn index\r\n\t\t}\r\n\t})\r\n\r\n\r\n\tvar getValue\r\n\tvar GeneratorVariable = Variable.GeneratorVariable = lang.compose(Variable.Composite, function ReactiveGenerator(generator){\r\n\t\tthis.generator = generator\r\n\t}, {\r\n\t\tgetValue: getValue = function(context, resuming) {\r\n\t\t\tvar lastValue\r\n\t\t\tvar i\r\n\t\t\tvar generatorIterator\r\n\t\t\tvar isThrowing\r\n\t\t\tif (resuming) {\r\n\t\t\t\t// resuming from a promise\r\n\t\t\t\tgeneratorIterator = resuming.iterator\r\n\t\t\t\ti = resuming.i\r\n\t\t\t\tlastValue = resuming.value\r\n\t\t\t\tisThrowing = resuming.isThrowing\r\n\t\t\t} else {\r\n\t\t\t\t// a fresh start\r\n\t\t\t\ti = 0\r\n\t\t\t\tgeneratorIterator = this.generator()\r\n\t\t\t}\r\n\r\n\t\t\tdo {\r\n\t\t\t\tvar stepReturn = generatorIterator[isThrowing ? 'throw' : 'next'](lastValue)\r\n\t\t\t\tif (stepReturn.done) {\r\n\t\t\t\t\treturn stepReturn.value\r\n\t\t\t\t}\r\n\t\t\t\tvar nextVariable = stepReturn.value\r\n\t\t\t\t// compare with the arguments from the last\r\n\t\t\t\t// execution to see if they are the same\r\n\t\t\t\tvar argumentName = 'argument' + i\r\n\t\t\t\tif (this[argumentName] !== nextVariable) {\r\n\t\t\t\t\tif (this[argumentName]) {\r\n\t\t\t\t\t\tthis[argumentName].stopNotifies(this)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// subscribe if it is a variable\r\n\t\t\t\t\tif (nextVariable && nextVariable.notifies) {\r\n\t\t\t\t\t\tif (this.listeners) {\r\n\t\t\t\t\t\t\tnextVariable.notifies(this)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis[argumentName] = nextVariable\r\n\t\t\t\t\t} else if (typeof nextVariable === 'function' && isGenerator(nextVariable)) {\r\n\t\t\t\t\t\tvar delegatedGenerator\r\n\t\t\t\t\t\tgetValue.call(this, context, delegatedGenerator = {\r\n\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\titerator: nextVariable()\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\ti = delegatedGenerator.i\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis[argumentName] = null\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ti++\r\n\t\t\t\tif (resuming) {\r\n\t\t\t\t\tresuming.i = i\r\n\t\t\t\t}\r\n\t\t\t\tif (context) {\r\n\t\t\t\t\tcontext.nextProperty = argumentName\r\n\t\t\t\t}\r\n\t\t\t\tlastValue = nextVariable && nextVariable.valueOf(context)\r\n\t\t\t\tif (lastValue && lastValue.then) {\r\n\t\t\t\t\t// if it is a promise, we will wait on it\r\n\t\t\t\t\tvar variable = this\r\n\t\t\t\t\t// and return the promise so that the getValue caller can wait on this\r\n\t\t\t\t\treturn lastValue.then(function(value) {\r\n\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}, function(error) {\r\n\t\t\t\t\t\treturn getValue.call(variable, context, {\r\n\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\titerator: generatorIterator,\r\n\t\t\t\t\t\t\tvalue: error,\r\n\t\t\t\t\t\t\tisThrowing: true\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t} while(true)\r\n\t\t}\r\n\t})\r\n\r\n\tvar Validating = lang.compose(Caching, function(target) {\r\n\t\tthis.target = target\r\n\t}, {\r\n\t\tforDependencies: function(callback) {\r\n\t\t\tCaching.prototype.forDependencies.call(this, callback)\r\n\t\t\tcallback(this.target)\r\n\t\t},\r\n\t\tgetVersion: function(context) {\r\n\t\t\treturn Math.max(Variable.prototype.getVersion.call(this, context), this.target.getVersion(context))\r\n\t\t},\r\n\t\tgetValue: function(context) {\r\n\t\t\tvar target = this.target\r\n\t\t\t// need to actually access the target value, so it can be evaluated in case it\r\n\t\t\t// there is a returned variable that we should delegate to.\r\n\t\t\ttarget.valueOf(context)\r\n\t\t\treturn target.validate(target, target.schema)\r\n\t\t}\r\n\t})\r\n\r\n\tfunction validate(target) {\r\n\t\tvar schemaForObject = schema(target)\r\n\t\treturn new Validating(target, schemaForObject)\r\n\t}\r\n\tVariable.VArray = Variable\r\n\tVariable.VPromised = Variable\r\n\tVariable.deny = deny\r\n\tVariable.noChange = noChange\r\n\tfunction addFlag(name) {\r\n\t\tVariable[name] = function(functionValue) {\r\n\t\t\tfunctionValue[name] = true\r\n\t\t}\r\n\t}\r\n\taddFlag(Variable, 'handlesContext')\r\n\taddFlag(Variable, 'handlesPromises')\r\n\r\n\tfunction objectUpdated(object) {\r\n\t\t// simply notifies any subscribers to an object, that it has changed\r\n\t\tvar listeners = propertyListenersMap.get(object)\r\n\t\tif (listeners) {\r\n\t\t\tfor (var i = 0, l = listeners.length; i < l; i++) {\r\n\t\t\t\tlisteners[i]._propertyChange(null, object)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction all(array) {\r\n\t\t// This is intended to mirror Promise.all. It actually takes\r\n\t\t// an iterable, but for now we are just looking for array-like\r\n\t\tif (array.length > -1) {\r\n\t\t\treturn new Composite(array)\r\n\t\t}\r\n\t\tif (arguments.length > 1) {\r\n\t\t\t// support multiple arguments as an array\r\n\t\t\treturn new Composite(arguments)\r\n\t\t}\r\n\t\tif (typeof array === 'object') {\r\n\t\t\t// allow an object as a hash to be mapped\r\n\t\t\tvar keyMapping = []\r\n\t\t\tvar valueArray = []\r\n\t\t\tfor (var key in array) {\r\n\t\t\t\tkeyMapping.push(key)\r\n\t\t\t\tvalueArray.push(array[key])\r\n\t\t\t}\r\n\t\t\treturn new Variable(function(results) {\r\n\t\t\t\tvar resultObject = {}\r\n\t\t\t\tfor (var i = 0; i < results.length; i++) {\r\n\t\t\t\t\tresultObject[keyMapping[i]] = results[i]\r\n\t\t\t\t}\r\n\t\t\t\treturn resultObject\r\n\t\t\t}).apply(null, valueArray)\r\n\t\t}\r\n\t\tthrow new TypeError('Variable.all requires an array')\r\n\t}\r\n\r\n\tfunction hasOwn(Target, createForInstance) {\r\n\r\n\t\tvar ownedClasses = this.ownedClasses || (this.ownedClasses = new WeakMap())\r\n\t\t// TODO: assign to super classes\r\n\t\tvar Class = this\r\n\t\townedClasses.set(Target, createForInstance || function() { return new Target() })\r\n\t\treturn this\r\n\t}\r\n\tfunction getForClass(subject, Target) {\r\n\t\tvar createInstance = subject.constructor.ownedClasses && subject.constructor.ownedClasses.get(Target)\r\n\t\tif (createInstance) {\r\n\t\t\tvar ownedInstances = subject.ownedInstances || (subject.ownedInstances = new WeakMap())\r\n\t\t\tvar instance = ownedInstances.get(Target)\r\n\t\t\tif (!instance) {\r\n\t\t\t\townedInstances.set(Target, instance = createInstance(subject))\r\n\t\t\t\tinstance.subject = subject\r\n\t\t\t}\r\n\t\t\treturn instance\r\n\t\t}\r\n\t}\r\n\tfunction generalizeClass() {\r\n\t\tvar prototype = this.prototype\r\n\t\tvar prototypeNames = Object.getOwnPropertyNames(prototype)\r\n\t\tfor(var i = 0, l = prototypeNames.length; i < l; i++) {\r\n\t\t\tvar name = prototypeNames[i]\r\n\t\t\tObject.defineProperty(this, name, getGeneralizedDescriptor(Object.getOwnPropertyDescriptor(prototype, name), name, this))\r\n\t\t}\r\n\t}\r\n\tfunction getGeneralizedDescriptor(descriptor, name, Class) {\r\n\t\tif (typeof descriptor.value === 'function') {\r\n\t\t\treturn {\r\n\t\t\t\tvalue: generalizeMethod(Class, name)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn descriptor\r\n\t\t}\r\n\t}\r\n\tfunction generalizeMethod(Class, name) {\r\n\t\t// I think we can just rely on `this`, but we could use the argument:\r\n\t\t// function(possibleEvent) {\r\n\t\t// \tvar target = possibleEvent && possibleEvent.target\r\n\t\tvar method = Class[name] = function() {\r\n\t\t\tvar instance = Class.for(this)\r\n\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t}\r\n\t\tmethod.for = function(context) {\r\n\t\t\tvar instance = Class.for(context)\r\n\t\t\treturn function() {\r\n\t\t\t\treturn instance[name].apply(instance, arguments)\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn method\r\n\t}\r\n\r\n\tvar defaultContext = {\r\n\t\tname: 'Default context',\r\n\t\tdescription: 'This object is the default context for classes, corresponding to a singleton instance of that class',\r\n\t\tconstructor: {\r\n\t\t\tgetForClass: function(subject, Class) {\r\n\t\t\t\treturn Class.defaultInstance\r\n\t\t\t}\r\n\t\t},\r\n\t\tcontains: function() {\r\n\t\t\treturn true // contains everything\r\n\t\t}\r\n\t}\r\n\tfunction instanceForContext(Class, context) {\r\n\t\tif (!context) {\r\n\t\t\treturn Class.defaultInstance\r\n\t\t}\r\n\t\treturn context.specify(Class)\r\n//\t\tvar instance = context.subject.constructor.getForClass && context.subject.constructor.getForClass(context.subject, Class) || Class.defaultInstance\r\n//\t\tcontext.distinctSubject = mergeSubject(context.distinctSubject, instance.subject)\r\n//\t\treturn instance\r\n\t}\r\n\t// a variable inheritance change goes through its own prototype, so classes/constructor\r\n\t// can be used as variables as well\r\n\tfor (var key in VariablePrototype) {\r\n\t\tObject.defineProperty(Variable, key, Object.getOwnPropertyDescriptor(VariablePrototype, key))\r\n\t}\r\n\tVariable.valueOf = function(context) {\r\n\t\t// contextualized getValue\r\n\t\treturn instanceForContext(this, context).valueOf(context)\r\n\t}\r\n\tVariable.put = function(value, context) {\r\n\t\t// contextualized setValue\r\n\t\treturn instanceForContext(this, context).put(value, context)\r\n\t}\r\n\tVariable.for = function(subject) {\r\n\t\tif (subject != null) {\r\n\t\t\tif (subject.target && !subject.constructor.getForClass) {\r\n\t\t\t\t// makes HTML events work\r\n\t\t\t\tsubject = subject.target\r\n\t\t\t}\r\n\t\t\tvar instance\r\n\t\t\tinstance = new Context(subject).specify(this)\r\n\t\t\tif (instance && !instance.subject) {\r\n\t\t\t\tinstance.subject = subject\r\n\t\t\t}\r\n\t\t\t// TODO: Do we have a global context that we set on defaultInstance?\r\n\t\t\treturn instance || this.defaultInstance\r\n\t\t} else {\r\n\t\t\treturn this.defaultInstance\r\n\t\t}\r\n\t}\r\n\tVariable.from = function(value) {\r\n\t\tif (value && typeof value === 'object') {\r\n\t\t\t// a plain object, we use our own map to retrieve the instance (or create one)\r\n\t\t\tvar instanceMap = this.instanceMap || (this.instanceMap = new WeakMap())\r\n\t\t\tvar instance = instanceMap.get(value)\r\n\t\t\tif (!instance) {\r\n\t\t\t\tinstanceMap.set(value, instance = new this(value))\r\n\t\t\t}\r\n\t\t\treturn instance\r\n\t\t} else {\r\n\t\t\t// a primitive, just unconditionally create a new variable for it\r\n\t\t\treturn new this(value)\r\n\t\t}\r\n\t}\r\n\tVariable.notifies = function(target) {\r\n\t\tthis.defaultInstance.notifies(target)\r\n\t}\r\n\tVariable.stopNotifies = function(target) {\r\n\t\tthis.defaultInstance.stopNotifies(target)\r\n\t}\r\n\tVariable.getCollectionOf = function () {\r\n\t\treturn this.collectionOf\r\n\t}\r\n\tVariable.updated = function(updateEvent, by, context) {\r\n\t\treturn instanceForContext(this, context).updated(updateEvent, by, context)\r\n\t}\r\n\tObject.defineProperty(Variable, 'collectionOf', {\r\n\t\tget: function() {\r\n\t\t\treturn this._collectionOf\r\n\t\t},\r\n\t\tset: function(ItemClass) {\r\n\t\t\tif (this._collectionOf != ItemClass) {\r\n\t\t\t\tthis._collectionOf = ItemClass\r\n\t\t\t\tItemClass.collection = this\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\tObject.defineProperty(Variable, 'collection', {\r\n\t\tget: function() {\r\n\t\t\treturn this._collection\r\n\t\t},\r\n\t\tset: function(Collection) {\r\n\t\t\tif (this._collection != Collection) {\r\n\t\t\t\tthis._collection = Collection\r\n\t\t\t\tCollection.collectionOf = this\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n\tVariable.Context = Context\r\n\tVariable.NotifyingContext = NotifyingContext\r\n\tVariable.generalize = generalizeClass\r\n\tVariable.call = Function.prototype.call // restore these\r\n\tVariable.apply = Function.prototype.apply\r\n\tVariable.extend = function(properties) {\r\n\t\t// TODO: handle arguments\r\n\t\tvar Base = this\r\n\t\tfunction ExtendedVariable() {\r\n\t\t\tif (this instanceof ExtendedVariable) {\r\n\t\t\t\tBase.apply(this, arguments)\r\n\t\t\t} else {\r\n\t\t\t\treturn ExtendedVariable.extend(properties)\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar prototype = ExtendedVariable.prototype = Object.create(this.prototype)\r\n\t\tExtendedVariable.prototype.constructor = ExtendedVariable\r\n\t\tsetPrototypeOf(ExtendedVariable, this)\r\n\t\tfor (var key in properties) {\r\n\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(properties, key)\r\n\t\t\tObject.defineProperty(prototype, key, descriptor)\r\n\t\t\tObject.defineProperty(ExtendedVariable, key, getGeneralizedDescriptor(descriptor, key, ExtendedVariable))\r\n\t\t}\r\n\t\tif (properties && properties.hasOwn) {\r\n\t\t\thasOwn.call(ExtendedVariable, properties.hasOwn)\r\n\t\t}\r\n\t\treturn ExtendedVariable\r\n\t}\r\n\tObject.defineProperty(Variable, 'defaultInstance', {\r\n\t\tget: function() {\r\n\t\t\treturn this.hasOwnProperty('_defaultInstance') ?\r\n\t\t\t\tthis._defaultInstance : (\r\n\t\t\t\t\tthis._defaultInstance = new this(),\r\n\t\t\t\t\tthis._defaultInstance.subject = defaultContext,\r\n\t\t\t\t\tthis._defaultInstance)\r\n\t\t}\r\n\t})\r\n\tVariable.hasOwn = function(Target, createInstance) {\r\n\t\tvar instanceMap = new WeakMap()\r\n\t\tinstanceMap.createInstance = createInstance\r\n\t\tvar subjectMap = this.ownedClasses || (this.ownedClasses = new WeakMap())\r\n\t\tsubjectMap.set(Target, instanceMap)\r\n\t}\r\n\r\n\tVariable.all = all\r\n\tVariable.objectUpdated = objectUpdated\r\n\r\n\treturn Variable\r\n})\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Variable.js\n ** module id = 2\n ** module chunks = 0\n **/","define([], function () {\r\n\tvar getPrototypeOf = Object.getPrototypeOf || (function(base) { return base.__proto__ })\r\n\tvar setPrototypeOf = Object.setPrototypeOf || (function(base, proto) { base.__proto__ = proto})\r\n\tvar hasFeatures = {\r\n\t\trequestAnimationFrame: typeof requestAnimationFrame != 'undefined',\r\n\t\tdefineProperty: Object.defineProperty && (function() {\r\n\t\t\ttry{\r\n\t\t\t\tObject.defineProperty({}, 't', {})\r\n\t\t\t\treturn true\r\n\t\t\t}catch(e) {\r\n\t\t\t}\r\n\t\t})(),\r\n\t\tpromise: typeof Promise !== 'undefined',\r\n\t\tMutationObserver: typeof MutationObserver !== 'undefined',\r\n\t\t'WeakMap': typeof WeakMap === 'function'\r\n\t}\r\n\tfunction has(feature) {\r\n\t\treturn hasFeatures[feature]\r\n\t}\r\n\t// This is an polyfill for Object.observe with just enough functionality\r\n\t// for what Variables need\r\n\t// An observe function, with polyfile\r\n\tvar observe =\r\n\t\thas('defineProperty') ? \r\n\t\tfunction observe(target, listener) {\r\n\t\t\t/*for(var i in target) {\r\n\t\t\t\taddKey(i)\r\n\t\t\t}*/\r\n\t\t\tlistener.addKey = addKey\r\n\t\t\tlistener.remove = function() {\r\n\t\t\t\tlistener = null\r\n\t\t\t}\r\n\t\t\treturn listener\r\n\t\t\tfunction addKey(key) {\r\n\t\t\t\tvar keyFlag = 'key' + key\r\n\t\t\t\tif(this[keyFlag]) {\r\n\t\t\t\t\treturn\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis[keyFlag] = true\r\n\t\t\t\t}\r\n\t\t\t\tvar currentValue = target[key]\r\n\t\t\t\tvar targetAncestor = target\r\n\t\t\t\tvar descriptor\r\n\t\t\t\tdo {\r\n\t\t\t\t\tdescriptor = Object.getOwnPropertyDescriptor(targetAncestor, key)\r\n\t\t\t\t} while(!descriptor && (targetAncestor = getPrototypeOf(targetAncestor)))\r\n\r\n\t\t\t\tif(descriptor && descriptor.set) {\r\n\t\t\t\t\tvar previousSet = descriptor.set\r\n\t\t\t\t\tvar previousGet = descriptor.get\r\n\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\treturn (currentValue = previousGet.call(this))\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\tpreviousSet.call(this, value)\r\n\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tenumerable: descriptor.enumerable\r\n\t\t\t\t\t})\r\n\t\t\t\t}else{\r\n\t\t\t\t\tObject.defineProperty(target, key, {\r\n\t\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\t\treturn currentValue\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\t\tif(currentValue !== value) {\r\n\t\t\t\t\t\t\t\tcurrentValue = value\r\n\t\t\t\t\t\t\t\tif(listener) {\r\n\t\t\t\t\t\t\t\t\tlistener([{target: this, name: key}])\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tenumerable: !descriptor || descriptor.enumerable\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} :\r\n\t\t// and finally a polling-based solution, for the really old browsers\r\n\t\tfunction(target, listener) {\r\n\t\t\tif(!timerStarted) {\r\n\t\t\t\ttimerStarted = true\r\n\t\t\t\tsetInterval(function() {\r\n\t\t\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\t\t\tdiff(watchedCopies[i], watchedObjects[i], listeners[i])\r\n\t\t\t\t\t}\r\n\t\t\t\t}, 20)\r\n\t\t\t}\r\n\t\t\tvar copy = {}\r\n\t\t\tfor(var i in target) {\r\n\t\t\t\tif(target.hasOwnProperty(i)) {\r\n\t\t\t\t\tcopy[i] = target[i]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twatchedObjects.push(target)\r\n\t\t\twatchedCopies.push(copy)\r\n\t\t\tlisteners.push(listener)\r\n\t\t}\r\n\tvar queuedListeners\r\n\tfunction queue(listener, object, name) {\r\n\t\tif(queuedListeners) {\r\n\t\t\tif(queuedListeners.indexOf(listener) === -1) {\r\n\t\t\t\tqueuedListeners.push(listener)\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tqueuedListeners = [listener]\r\n\t\t\tlang.nextTurn(function() {\r\n\t\t\t\tqueuedListeners.forEach(function(listener) {\r\n\t\t\t\t\tvar events = []\r\n\t\t\t\t\tlistener.properties.forEach(function(property) {\r\n\t\t\t\t\t\tevents.push({target: listener.object, name: property})\r\n\t\t\t\t\t})\r\n\t\t\t\t\tlistener(events)\r\n\t\t\t\t\tlistener.object = null\r\n\t\t\t\t\tlistener.properties = null\r\n\t\t\t\t})\r\n\t\t\t\tqueuedListeners = null\r\n\t\t\t}, 0)\r\n\t\t}\r\n\t\tlistener.object = object\r\n\t\tvar properties = listener.properties || (listener.properties = [])\r\n\t\tif(properties.indexOf(name) === -1) {\r\n\t\t\tproperties.push(name)\r\n\t\t}\r\n\t}\r\n\tvar unobserve = has('observe') ? Object.unobserve :\r\n\t\tfunction(target, listener) {\r\n\t\t\tif(listener.remove) {\r\n\t\t\t\tlistener.remove()\r\n\t\t\t}\r\n\t\t\tfor(var i = 0, l = watchedObjects.length; i < l; i++) {\r\n\t\t\t\tif(watchedObjects[i] === target && listeners[i] === listener) {\r\n\t\t\t\t\twatchedObjects.splice(i, 1)\r\n\t\t\t\t\twatchedCopies.splice(i, 1)\r\n\t\t\t\t\tlisteners.splice(i, 1)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\tvar watchedObjects = []\r\n\tvar watchedCopies = []\r\n\tvar listeners = []\r\n\tvar timerStarted = false\r\n\tfunction diff(previous, current, callback) {\r\n\t\t// TODO: keep an array of properties for each watch for faster iteration\r\n\t\tvar queued\r\n\t\tfor(var i in previous) {\r\n\t\t\tif(previous.hasOwnProperty(i) && previous[i] !== current[i]) {\r\n\t\t\t\t// a property has changed\r\n\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(var i in current) {\r\n\t\t\tif(current.hasOwnProperty(i) && !previous.hasOwnProperty(i)) {\r\n\t\t\t\t// a property has been added\r\n\t\t\t\tprevious[i] = current[i]\r\n\t\t\t\t(queued || (queued = [])).push({name: i})\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(queued) {\r\n\t\t\tcallback(queued)\r\n\t\t}\r\n\t}\r\n\r\n\tvar id = 1\r\n\t// a function that returns a function, to stop JSON serialization of an\r\n\t// object\r\n\tfunction toJSONHidden() {\r\n\t\treturn toJSONHidden\r\n\t}\r\n\t// An object that will be hidden from JSON serialization\r\n\tvar Hidden = function () {\r\n\t}\r\n\tHidden.prototype.toJSON = toJSONHidden\r\n\r\n\tvar lang = {\r\n\t\trequestAnimationFrame: has('requestAnimationFrame') ? requestAnimationFrame :\r\n\t\t\t(function() {\r\n\t\t\t\tvar toRender = []\r\n\t\t\t\tvar queued = false\r\n\t\t\t\tfunction processAnimationFrame() {\r\n\t\t\t\t\tfor (var i = 0; i < toRender.length; i++) {\r\n\t\t\t\t\t\ttoRender[i]()\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttoRender = []\r\n\t\t\t\t\tqueued = false\r\n\t\t\t\t}\r\n\t\t\t\tfunction requestAnimationFrame(renderer) {\r\n\t\t\t\t \tif (!queued) {\r\n\t\t\t\t\t\tsetTimeout(processAnimationFrame)\r\n\t\t\t\t\t\tqueued = true\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttoRender.push(renderer)\r\n\t\t\t\t}\r\n\t\t\t\treturn requestAnimationFrame\r\n\t\t\t})(),\r\n\t\tPromise: has('promise') ? Promise : (function() {\r\n\t\t\tfunction Promise(execute) {\r\n\t\t\t\tvar isResolved, resolution, errorResolution\r\n\t\t\t\tvar queue = 0\r\n\t\t\t\tfunction resolve(value) {\r\n\t\t\t\t\t// resolve function\r\n\t\t\t\t\tif(value && value.then) {\r\n\t\t\t\t\t\t// received a promise, wait for it\r\n\t\t\t\t\t\tvalue.then(resolve, reject)\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tresolution = value\r\n\t\t\t\t\t\tfinished()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfunction reject(error) {\r\n\t\t\t\t\t// reject function\r\n\t\t\t\t\terrorResolution = error\r\n\t\t\t\t\tfinished()\r\n\t\t\t\t}\r\n\t\t\t\texecute(resolve, reject)\r\n\t\t\t\tfunction finished() {\r\n\t\t\t\t\tisResolved = true\r\n\t\t\t\t\tfor(var i = 0, l = queue.length; i < l; i++) {\r\n\t\t\t\t\t\tqueue[i]()\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// clean out the memory\r\n\t\t\t\t\tqueue = 0\r\n\t\t\t\t}\r\n\t\t\t\treturn {\r\n\t\t\t\t\tthen: function(callback, errback) {\r\n\t\t\t\t\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\t\t\t\t\tfunction handle() {\r\n\t\t\t\t\t\t\t\t// promise fulfilled, call the appropriate callback\r\n\t\t\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t\t\tif(errorResolution && !errback) {\r\n\t\t\t\t\t\t\t\t\t\t// errors without a handler flow through\r\n\t\t\t\t\t\t\t\t\t\treject(errorResolution)\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// resolve to the callback's result\r\n\t\t\t\t\t\t\t\t\t\tresolve(errorResolution ?\r\n\t\t\t\t\t\t\t\t\t\t\terrback(errorResolution) :\r\n\t\t\t\t\t\t\t\t\t\t\tcallback ?\r\n\t\t\t\t\t\t\t\t\t\t\t\tcallback(resolution) : resolution)\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}catch(newError) {\r\n\t\t\t\t\t\t\t\t\t// caught an error, reject the returned promise\r\n\t\t\t\t\t\t\t\t\treject(newError)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(isResolved) {\r\n\t\t\t\t\t\t\t\t// already resolved, immediately handle\r\n\t\t\t\t\t\t\t\thandle()\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t(queue || (queue = [])).push(handle)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn Promise\r\n\t\t}()),\r\n\r\n\t\tWeakMap: has('WeakMap') ? WeakMap :\r\n\t \tfunction (values, name) {\r\n\t \t\tvar mapProperty = '__' + (name || '') + id++\r\n\t \t\treturn has('defineProperty') ?\r\n\t \t\t{\r\n\t \t\t\tget: function (key) {\r\n\t \t\t\t\treturn key[mapProperty]\r\n\t \t\t\t},\r\n\t \t\t\tset: function (key, value) {\r\n\t \t\t\t\tObject.defineProperty(key, mapProperty, {\r\n\t \t\t\t\t\tvalue: value,\r\n\t \t\t\t\t\tenumerable: false\r\n\t \t\t\t\t})\r\n\t \t\t\t}\r\n\t \t\t} :\r\n\t \t\t{\r\n\t \t\t\tget: function (key) {\r\n\t \t\t\t\tvar intermediary = key[mapProperty]\r\n\t \t\t\t\treturn intermediary && intermediary.value\r\n\t \t\t\t},\r\n\t \t\t\tset: function (key, value) {\r\n\t \t\t\t\t// we use an intermediary that is hidden from JSON serialization, at least\r\n\t \t\t\t\tvar intermediary = key[mapProperty] || (key[mapProperty] = new Hidden())\r\n\t \t\t\t\tintermediary.value = value\r\n\t \t\t\t}\r\n\t \t\t}\r\n\t \t},\r\n\r\n\t\tobserve: observe,\r\n\t\tunobserve: unobserve,\r\n\t\twhen: function(value, callback, errorHandler) {\r\n\t\t\treturn value && value.then ?\r\n\t\t\t\t(value.then(callback, errorHandler) || value) : callback(value)\r\n\t\t},\r\n\t\twhenAll: function(inputs, callback) {\r\n\t\t\tvar promiseInvolved\r\n\t\t\tfor(var i = 0, l = inputs.length; i < l; i++) {\r\n\t\t\t\tif(inputs[i] && inputs[i].then) {\r\n\t\t\t\t\tpromiseInvolved = true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(promiseInvolved) {\r\n\t\t\t\t// we have asynch inputs, do lazy loading\r\n\t\t\t\treturn {\r\n\t\t\t\t\tthen: function(onResolve, onError) {\r\n\t\t\t\t\t\tvar remaining = 1\r\n\t\t\t\t\t\tvar result\r\n\t\t\t\t\t\tvar readyInputs = []\r\n\t\t\t\t\t\tvar lastPromiseResult\r\n\t\t\t\t\t\tfor(var i = 0; i < inputs.length; i++) {\r\n\t\t\t\t\t\t\tvar input = inputs[i]\r\n\t\t\t\t\t\t\tremaining++\r\n\t\t\t\t\t\t\tif(input && input.then) {\r\n\t\t\t\t\t\t\t\t(function(i, previousPromiseResult) {\r\n\t\t\t\t\t\t\t\t\tlastPromiseResult = input.then(function(value) {\r\n\t\t\t\t\t\t\t\t\t\treadyInputs[i] = value\r\n\t\t\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\t\t\t\treturn result\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\treturn previousPromiseResult\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}, onError)\r\n\t\t\t\t\t\t\t\t})(i, lastPromiseResult)\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\treadyInputs[i] = input\r\n\t\t\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tonEach()\r\n\t\t\t\t\t\tfunction onEach() {\r\n\t\t\t\t\t\t\tremaining--\r\n\t\t\t\t\t\t\tif(!remaining) {\r\n\t\t\t\t\t\t\t\tresult = onResolve(callback(readyInputs))\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn lastPromiseResult\r\n\t\t\t\t\t},\r\n\t\t\t\t\tinputs: inputs\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// just sync inputs\r\n\t\t\treturn callback(inputs)\r\n\r\n\t\t},\r\n\t\tcompose: function(Base, constructor, properties) {\r\n\t\t\tvar prototype = constructor.prototype = Object.create(Base.prototype)\r\n\t\t\tsetPrototypeOf(constructor, Base)\r\n\t\t\tfor(var i in properties) {\r\n\t\t\t\tprototype[i] = properties[i]\r\n\t\t\t}\r\n\t\t\tprototype.constructor = constructor\r\n\t\t\treturn constructor\r\n\t\t},\r\n\t\tnextTurn: has('MutationObserver') ?\r\n\t\t\tfunction (callback) {\r\n\t\t\t\t// promises don't resolve consistently on the next micro turn (Edge doesn't do it right),\r\n\t\t\t\t// so use mutation observer\r\n\t\t\t\t// TODO: make a faster mode that doesn't recreate each time\r\n\t\t\t\tvar div = document.createElement('div')\r\n\t\t\t\tvar observer = new MutationObserver(callback)\r\n\t\t\t\tobserver.observe(div, {\r\n\t\t\t\t\tattributes: true\r\n\t\t\t\t})\r\n\t\t\t\tdiv.setAttribute('a', id++)\r\n\t\t\t} :\r\n\t\t\tfunction (callback) {\r\n\t\t\t\t// TODO: we can do better for other, older browsers\r\n\t\t\t\tsetTimeout(callback, 0)\r\n\t\t\t},\r\n\t\tcopy: Object.assign || function(target, source) {\r\n\t\t\tfor(var i in source) {\r\n\t\t\t\ttarget[i] = source[i]\r\n\t\t\t}\r\n\t\t\treturn target\r\n\t\t}\r\n\t}\r\n\tfunction isGenerator(func) {\r\n\t\tif (typeof func === 'function') {\r\n\t\t\tvar constructor = func.constructor\r\n\t\t\t// this is used to handle both native generators and transpiled generators\r\n\t\t\treturn (constructor.displayName || constructor.name) === 'GeneratorFunction'\r\n\t\t}\r\n\t}\r\n\tlang.isGenerator = isGenerator\r\n\treturn lang\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./util/lang.js\n ** module id = 3\n ** module chunks = 0\n **/","define(['./util/lang', './Variable'], function (lang, Variable) {\r\n\tvar doc = typeof document !== 'undefined' && document\r\n\tvar invalidatedElements\r\n\tvar queued\r\n\tvar toRender = []\r\n\tvar nextId = 1\r\n\tvar requestAnimationFrame = lang.requestAnimationFrame\r\n\tvar Context = Variable.Context\r\n\r\n\tfunction Renderer(options) {\r\n\t\tvar variable = options.variable\r\n\r\n\t\tthis.variable = variable\r\n\t\tif (options.selector) {\r\n\t\t\tthis.selector = options.selector\r\n\t\t}\r\n\t\tif (options.elements) {\r\n\t\t\tthis.elements = options.elements\r\n\t\t\tthis.element = this.elements[0]\r\n\t\t\tfor(var i = 0, l = this.elements.length; i < l; i++) {\r\n\t\t\t\t(this.elements[i].alkaliRenderers || (this.elements[i].alkaliRenderers = [])).push(this)\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (options.element) {\r\n\t\t\tvar element = this.element = options.element;\r\n\t\t\t(element.alkaliRenderers || (element.alkaliRenderers = [])).push(this)\r\n\t\t} else {\r\n\t\t\tthrow new Error('No element provided to Renderer')\r\n\t\t}\r\n\t\tif (options.update) {\r\n\t\t\tthis.updateRendering = options.update\r\n\t\t}\r\n\t\tif (options.shouldRender) {\r\n\t\t\tthis.shouldRender = options.shouldRender\r\n\t\t}\r\n\t\tif (options.renderUpdate) {\r\n\t\t\tthis.renderUpdate = options.renderUpdate\r\n\t\t}\r\n\t\tif (options.alwaysUpdate) {\r\n\t\t\tthis.alwaysUpdate = options.alwaysUpdate\r\n\t\t}\r\n\t\tif (!variable.updated) {\r\n\t\t\t// baconjs-esqe API\r\n\t\t\tvar renderer = this\r\n\t\t\tvariable.subscribe(function (event) {\r\n\t\t\t\t// replace the variable with an object\r\n\t\t\t\t// that returns the value from the event\r\n\t\t\t\trenderer.variable = {\r\n\t\t\t\t\tvalueOf: function () {\r\n\t\t\t\t\t\treturn event.value()\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\trenderer.updated()\r\n\t\t\t})\r\n\t\t}\r\n\t\tif (options.updateOnStart === false){\r\n\t\t\t// even if we don't render on start, we still need to compute the value so we can depend on the computed variables\r\n\t\t\tthis.variable.valueOf(this)\r\n\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t// TODO: we may need to handle recontextualization if it returns a promise\r\n\t\t\tcontextualized.notifies(this)\r\n\t\t} else {\r\n\t\t\tthis.updateRendering(true)\r\n\t\t}\r\n\t}\r\n\tRenderer.prototype = {\r\n\t\tconstructor: Renderer,\r\n\t\tupdateRendering: function () {\r\n\t\t\tthrow new Error ('updateRendering must be implemented by sub class of Renderer')\r\n\t\t},\r\n\t\tupdated: function (updateEvent, by, context) {\r\n\t\t\tif (!this.invalidated) {\r\n\t\t\t\tif (!context || this.contextMatches(context)) {\r\n\t\t\t\t\t// do this only once, until we render again\r\n\t\t\t\t\tthis.invalidated = true\r\n\t\t\t\t\tvar renderer = this\r\n\t\t\t\t\trequestAnimationFrame(function(){\r\n\t\t\t\t\t\tinvalidatedElements = null\r\n\t\t\t\t\t\trenderer.updateRendering(renderer.alwaysUpdate)\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tnewContext: function() {\r\n\t\t\treturn new Variable.Context(this.element)\r\n\t\t},\r\n\t\taddInput: function(variable) {\r\n\t\t\tthis.contextualized = variable\r\n\t\t},\r\n\t\tgetContextualized: function() {\r\n\t\t\treturn this.contextualized\r\n\t\t},\r\n\t\tspecify: function(Variable) {\r\n\t\t\t// a new context to get thsi\r\n\t\t\treturn this.newContext().specify(Variable)\r\n\t\t},\r\n\t\tmerge: function(){\r\n\t\t\t// noop\r\n\t\t},\r\n\t\tcontextMatches: function(context) {\r\n\t\t\treturn true\r\n\t\t},\r\n\t\tinvalidateElement: function(element) {\r\n\t\t\tif(!invalidatedElements){\r\n\t\t\t\tinvalidatedElements = new WeakMap(null, 'invalidated')\r\n\t\t\t}\r\n\t\t\tvar invalidatedParts = invalidatedElements.get(element)\r\n\t\t\tinvalidatedElements.set(element, invalidatedParts = {})\r\n\t\t\tif (!invalidatedParts[id]) {\r\n\t\t\t\tinvalidatedParts[id] = true\r\n\t\t\t}\r\n\t\t\tif (!queued) {\r\n\t\t\t\tlang.queueTask(processQueue)\r\n\t\t\t\tqueued = true\r\n\t\t\t}\r\n\t\t\tvar renderer = this\r\n\t\t\ttoRender.push(function(){\r\n\t\t\t\trenderer.invalidated = false\r\n\t\t\t\trenderer.updateElement(element)\r\n\t\t\t})\r\n\t\t},\r\n\t\tgetId: function(){\r\n\t\t\treturn this.id || (this.id = nextId++)\r\n\t\t},\r\n\t\tstop: function() {\r\n\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\tcontextualized.stopNotifies(this)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction ElementRenderer(options) {\r\n\t\tRenderer.call(this, options)\r\n\t}\r\n\tElementRenderer.prototype = Object.create(Renderer.prototype)\r\n\tElementRenderer.prototype.shouldRender = function (element) {\r\n\t\treturn document.body.contains(element)\r\n\t}\r\n\tElementRenderer.prototype.getSubject = function () {\r\n\t\treturn this.element\r\n\t}\r\n\tElementRenderer.prototype.updateRendering = function (always, element) {\r\n\t\tif (!element && this.elements) {\r\n\t\t\tvar elements = this.elements\r\n\t\t\tif(!elements.length){\r\n\t\t\t\tif(this.selector){\r\n\t\t\t\t\telements = document.querySelectorAll(this.selector)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthrow new Error('No element or selector was provided to the Renderer')\r\n\t\t\t\t}\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tfor(var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\tthis.updateRendering(always, elements[i])\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar thisElement = element || this.element\r\n\r\n\t\t\tif(always || this.shouldRender(thisElement)){\r\n\t\t\t\t// it is connected\r\n\t\t\t\tthis.updateElement(thisElement)\r\n\t\t\t} else {\r\n\t\t\t\tvar id = this.getId()\r\n\t\t\t\tvar renderers = thisElement.renderersOnShow\r\n\t\t\t\tif(!renderers){\r\n\t\t\t\t\trenderers = thisElement.renderersOnShow = []\r\n\t\t\t\t\tthisElement.className += ' needs-rerendering'\r\n\t\t\t\t}\r\n\t\t\t\tif (!renderers[id]) {\r\n\t\t\t\t\trenderers[id] = this\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tElementRenderer.prototype.addElement = function (element) {\r\n\t\tif (this.selector) {\r\n\t\t\telement.renderersOnShow = [this]\r\n\t\t} else {\r\n\t\t\tthis.elements.push(element)\r\n\t\t}\r\n\t\t// and immediately do an update\r\n\t\tthis.updateElement(element)\r\n\t}\r\n\tElementRenderer.prototype.updateElement = function(element) {\r\n\t\tthis.invalidated = false\r\n\t\ttry {\r\n\t\t\tif (!this.omitValueOf) {\r\n\t\t\t\tvar value = this.variable.valueOf(this)\r\n\t\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\t\t// TODO: we may need to handle recontextualization if it returns a promise\r\n\t\t\t\tcontextualized.notifies(this)\r\n\t\t\t}\r\n\t\t} catch (error) {\r\n\t\t\telement.appendChild(document.createTextNode(error))\r\n\t\t}\r\n\t\tif(value !== undefined || this.started || this.omitValueOf){\r\n\t\t\tthis.started = true\r\n\t\t\tif(value && value.then){\r\n\t\t\t\tif(this.renderLoading){\r\n\t\t\t\t\tthis.renderLoading(value, element)\r\n\t\t\t\t}\r\n\t\t\t\tvar renderer = this\r\n\t\t\t\tvalue.then(function (value) {\r\n\t\t\t\t\trenderer.renderUpdate(value, element)\r\n\t\t\t\t})\r\n\t\t\t}else{\r\n\t\t\t\tthis.renderUpdate(value, element)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tElementRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tthrow new Error('renderUpdate(newValue) must be implemented')\r\n\t}\r\n\tRenderer.Renderer = Renderer\r\n\tRenderer.ElementRenderer = ElementRenderer\r\n\r\n\tfunction AttributeRenderer(options) {\r\n\t\tif(options.name){\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tAttributeRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tAttributeRenderer.prototype.type = 'AttributeRenderer'\r\n\tAttributeRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement.setAttribute(this.name, newValue)\r\n\t}\r\n\tRenderer.AttributeRenderer = AttributeRenderer\r\n\r\n\tfunction PropertyRenderer(options) {\r\n\t\tif (options.name) {\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tPropertyRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tPropertyRenderer.prototype.type = 'PropertyRenderer'\r\n\tPropertyRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement[this.name] = newValue\r\n\t}\r\n\tRenderer.PropertyRenderer = PropertyRenderer\r\n\r\n\tfunction InputPropertyRenderer(options) {\r\n\t\tif (options.element && options.element.tagName === 'SELECT' && options.name === 'value') {\r\n\t\t\t// use the deferred value assignment for <select>\r\n\t\t\tthis.renderUpdate = this.renderSelectValueUpdate\r\n\t\t}\r\n\t\tPropertyRenderer.apply(this, arguments)\r\n\t}\r\n\tInputPropertyRenderer.prototype = Object.create(PropertyRenderer.prototype)\r\n\tInputPropertyRenderer.prototype.type = 'InputPropertyRenderer'\r\n\tInputPropertyRenderer.prototype.renderUpdate = function(newValue, element) {\r\n\t\tif (newValue == null || (element.type === 'number' && isNaN(newValue))) {\r\n\t\t\tnewValue = ''\r\n\t\t}\r\n\t\telement[this.name] = newValue\r\n\t}\r\n\tInputPropertyRenderer.prototype.renderSelectValueUpdate = function (newValue, element) {\r\n\t\telement.value = newValue\r\n\t\tif (element.value != newValue && !element.value) {\r\n\t\t\t// if we didn't successfully set the value of a <select>, we may need to wait until the children are constructed\r\n\t\t\telement.eventualValue = newValue\r\n\t\t\tlang.nextTurn(function() {\r\n\t\t\t\tif (element.eventualValue) {\r\n\t\t\t\t\telement.value = element.eventualValue\r\n\t\t\t\t\telement.eventualValue = undefined\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\telement.eventualValue = undefined\r\n\t\t}\r\n\t}\r\n\tRenderer.InputPropertyRenderer = InputPropertyRenderer\r\n\r\n\tfunction StyleRenderer(options) {\r\n\t\tif(options.name){\r\n\t\t\tthis.name = options.name\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tStyleRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tStyleRenderer.prototype.type = 'StyleRenderer'\r\n\tStyleRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement.style[this.name] = newValue\r\n\t}\r\n\tRenderer.StyleRenderer = StyleRenderer\r\n\r\n\tfunction ContentRenderer(options) {\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tContentRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tContentRenderer.prototype.type = 'ContentRenderer'\r\n\tContentRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\telement.innerHTML = ''\r\n\t\tif (newValue === undefined){\r\n\t\t\tnewValue = ''\r\n\t\t}\r\n\t\telement.appendChild(document.createTextNode(newValue))\r\n\t}\r\n\tRenderer.ContentRenderer = ContentRenderer\r\n\r\n\tfunction TextRenderer(options) {\r\n\t\tthis.position = options.position\r\n\t\tthis.textNode = options.textNode\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tTextRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tTextRenderer.prototype.type = 'TextRenderer'\r\n\tTextRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\tif (this.builtList) {\r\n\t\t\tif (updateEvent.type === 'refresh') {\r\n\t\t\t\tthis.builtList = false\r\n\t\t\t\tthis.omitValueOf = false\r\n\t\t\t} else {\r\n\t\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t}\r\n\tTextRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tif (newValue == null){\r\n\t\t\tnewValue = ''\r\n\t\t}\r\n\t\tif (newValue.nodeType) {\r\n\t\t\tif (this.textNode && this.textNode.parentNode == element) {\r\n\t\t\t\t// text node is attached, we can replace it with the node\r\n\t\t\t\telement.replaceChild(newValue, this.textNode)\r\n\t\t\t} else {\r\n\t\t\t\telement.appendChild(newValue)\r\n\t\t\t}\r\n\t\t\tthis.textNode = newValue\r\n\t\t} else if (newValue instanceof Array) {\r\n\t\t\tthis.renderUpdate = ListRenderer.prototype.renderUpdate\r\n\t\t\tthis.omitValueOf = true\r\n\t\t\tthis.renderUpdate(newValue, element)\r\n\t\t} else {\r\n\t\t\t(this.textNode || element.childNodes[this.position]).nodeValue = newValue\r\n\t\t}\r\n\t}\r\n\tRenderer.TextRenderer = TextRenderer\r\n\r\n\tfunction ListRenderer(options) {\r\n\t\tif (options.each) {\r\n\t\t\tthis.each = options.each\r\n\t\t}\r\n\t\tElementRenderer.apply(this, arguments)\r\n\t}\r\n\tListRenderer.prototype = Object.create(ElementRenderer.prototype)\r\n\tListRenderer.prototype.updated = function (updateEvent, context) {\r\n\t\tif (this.builtList) {\r\n\t\t\tif (updateEvent.type === 'refresh') {\r\n\t\t\t\tthis.builtList = false\r\n\t\t\t\tthis.omitValueOf = false\r\n\t\t\t} else {\r\n\t\t\t\t(this.updates || (this.updates = [])).push(updateEvent)\r\n\t\t\t}\r\n\t\t}\r\n\t\tElementRenderer.prototype.updated.call(this, updateEvent, context)\r\n\t}\r\n\tListRenderer.prototype.type = 'ListRenderer'\r\n\tListRenderer.prototype.renderUpdate = function (newValue, element) {\r\n\t\tvar container\r\n\t\tvar each = this.each || function(item) { // TODO: make a single identity function\r\n\t\t\treturn item\r\n\t\t}\r\n\t\tvar thisElement = this.element\r\n\t\tvar renderer = this\r\n\t\tif (!this.builtList) {\r\n\t\t\tthis.builtList = true\r\n\t\t\tthis.omitValueOf = true\r\n\t\t\telement.innerHTML = ''\r\n\t\t\tcontainer = document.createDocumentFragment()\r\n\t\t\tvar childElements = this.childElements = []\r\n\t\t\tif (each.defineHasOwn) {\r\n\t\t\t\teach.defineHasOwn()\r\n\t\t\t}\r\n\t\t\tnewValue.forEach(function(item) {\r\n\t\t\t\teachItem(item)\r\n\t\t\t})\r\n\t\t\tvar contextualized = this.contextualized || this.variable\r\n\t\t\tcontextualized.notifies(this)\r\n\r\n\t\t\tthisElement.appendChild(container)\r\n\t\t} else {\r\n\t\t\tvar childElements = this.childElements\r\n\t\t\tvar updates = this.updates\r\n\t\t\tcontainer = thisElement\r\n\t\t\tupdates.forEach(function(update) {\r\n\t\t\t\tif (update.type === 'refresh') {\r\n\t\t\t\t\trenderer.builtList = false\r\n\t\t\t\t\tfor (var i = 0, l = childElements.length; i < l; i++) {\r\n\t\t\t\t\t\tthisElement.removeChild(childElements[i])\r\n\t\t\t\t\t}\r\n\t\t\t\t\trenderer.renderUpdate()\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (update.previousIndex > -1) {\r\n\t\t\t\t\t\tthisElement.removeChild(childElements[update.previousIndex])\r\n\t\t\t\t\t\tchildElements.splice(update.previousIndex, 1)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (update.index > -1) {\r\n\t\t\t\t\t\tvar nextChild = childElements[update.index] || null\r\n\t\t\t\t\t\teachItem(update.value, update.index, nextChild)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tthis.updates = [] // clear the updates\r\n\t\t}\r\n\t\tfunction eachItem(item, index, nextChild) {\r\n\t\t\tvar childElement\r\n\t\t\tif (each.create) {\r\n\t\t\t\tchildElement = each.create({parent: thisElement, _item: item}) // TODO: make a faster object here potentially\r\n\t\t\t} else {\r\n\t\t\t\tchildElement = each(item, thisElement)\r\n\t\t\t\tif (childElement.create) {\r\n\t\t\t\t\tchildElement = childElement.create({parent: thisElement, _item: item})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (nextChild) {\r\n\t\t\t\tcontainer.insertBefore(childElement, nextChild)\r\n\t\t\t\tchildElements.splice(index, 0, childElement)\r\n\t\t\t} else {\r\n\t\t\t\tcontainer.appendChild(childElement)\r\n\t\t\t\tchildElements.push(childElement)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tRenderer.ListRenderer = ListRenderer\r\n\r\n\tRenderer.onShowElement = function(shownElement){\r\n\t\trequestAnimationFrame(function(){\r\n\t\t\tinvalidatedElements = null\r\n\t\t\tvar elements = [].slice.call(shownElement.getElementsByClassName('needs-rerendering'))\r\n\t\t\tif (shownElement.className.indexOf('needs-rerendering') > 0){\r\n\t\t\t\tvar includingTop = [shownElement]\r\n\t\t\t\tincludingTop.push.apply(includingTop, elements)\r\n\t\t\t\telements = includingTop\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, l = elements.length; i < l; i++){\r\n\t\t\t\tvar element = elements[i]\r\n\t\t\t\tvar renderers = element.renderersOnShow\r\n\t\t\t\tif(renderers){\r\n\t\t\t\t\telement.renderersOnShow = null\r\n\t\t\t\t\t// remove needs-rerendering class\r\n\t\t\t\t\telement.className = element.className.replace(/\\s?needs\\-rerendering\\s?/g, '')\r\n\t\t\t\t\tfor (var id in renderers) {\r\n\t\t\t\t\t\tvar renderer = renderers[id]\r\n\t\t\t\t\t\trenderer.updateElement(element)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\tfunction onElementRemoval(element){\r\n\t\t// cleanup element renderers\r\n\t\tif(element.alkaliRenderers){\r\n\t\t\tvar renderers = element.alkaliRenderers\r\n\t\t\tfor(var i = 0; i < renderers.length; i++){\r\n\t\t\t\tvar renderer = renderers[i]\r\n\t\t\t\trenderer.variable.stopNotifies(renderer)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tRenderer.onElementRemoval = function(element, onlyChildren){\r\n\t\tif(!onlyChildren){\r\n\t\t\tonElementRemoval(element)\r\n\t\t}\r\n\t\tvar children = element.getElementsByTagName('*')\r\n\t\tfor(var i = 0, l = children.length; i < l; i++){\r\n\t\t\tvar child = children[i]\r\n\t\t\tif(child.alkaliRenderers){\r\n\t\t\t\tonElementRemoval(child)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn Renderer\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Renderer.js\n ** module id = 4\n ** module chunks = 0\n **/","define(['./util/lang', './Variable', './operators'], function (lang, Variable, operators) {\r\n\r\n  var isGenerator = lang.isGenerator\r\n  var ObjectTransform = lang.compose(Variable.Call, function ObjectTransform(transform, inputs) {\r\n    this.inputs = inputs\r\n    Variable.Call.apply(this, arguments)\r\n  }, {\r\n    _getAsObject: function() {\r\n      return this.transform.apply(this, preserveObjects(this.inputs))\r\n    }\r\n  })\r\n  function preserveObjects(inputs) {\r\n    for (var i = 0, l = inputs.length; i < l; i++) {\r\n      var input = inputs[i]\r\n      if (input && input._getAsObject) {\r\n        inputs[i] = input._getAsObject()\r\n      }\r\n    }\r\n    return inputs\r\n  }\r\n\tfunction react(generator, options) {\r\n    if (typeof generator !== 'function') {\r\n      throw new Error('react() must be called with a generator. You need to use the babel-plugin-transform-alkali plugin if you want to use reactive expressions')\r\n    }\r\n\t\tif (options && options.reverse) {\r\n\t\t\tgenerator.reverse = options.reverse\r\n\t\t}\r\n\t\treturn new Variable.GeneratorVariable(generator)\r\n\t}\r\n  Object.assign(react, operators)\r\n  react.from = function(value, options) {\r\n    if (value && value.property) {\r\n      return value\r\n    }\r\n    if (typeof value === 'function' && isGenerator(value)) {\r\n      return react(value, options)\r\n    }\r\n    return Variable.from(value)\r\n  }\r\n  react.prop = function(object, property) {\r\n    if (object) {\r\n      // TODO: Use a static set of public methods/properties that can be accessed\r\n      if (object.property) {\r\n        // it is a variable already, but check to see if we are using a method/property directly on the variable\r\n        var directPropertyValue = object[property]\r\n        return directPropertyValue !== undefined ? directPropertyValue : object.property(property)\r\n      }\r\n      return object[property]\r\n    }\r\n    // not even truthy, return undefined\r\n  }\r\n  react.cond = function(test, consequent, alternate) {\r\n    return operators.if(test, operators.choose(consequent, alternate))\r\n  }\r\n  react.fcall = function(target, args) {\r\n    if (target.property && typeof target === 'function') {\r\n      return target.apply(null, preserveObjects(args))\r\n    }\r\n    return new Variable.Call(target, args)\r\n  }\r\n  react.mcall = function(target, key, args) {\r\n    var method = target[key]\r\n    if (typeof method === 'function' && method.property || key === 'bind') {\r\n      // for now we check to see if looks like it could handle a variable, or is a bind call\r\n      return method.apply(target, preserveObjects(args))\r\n    }\r\n    return new Variable.Call(target[key].bind(target), args)\r\n  }\r\n  react.ncall = function(target, args) {\r\n    if (target.property && typeof target === 'function') {\r\n      return new (target.bind.apply(target, [null].concat(preserveObjects(args))))()\r\n    }\r\n    return new Variable.Call(function() {\r\n      return new (target.bind.apply(target, [null].concat(arguments)))()\r\n    }, args)\r\n  }\r\n\r\n  react.obj = function(transform, inputs) {\r\n    return new ObjectTransform(transform, inputs)\r\n  }\r\n\r\n\treturn react\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./react.js\n ** module id = 5\n ** module chunks = 0\n **/","define(['./Variable'], function (Variable) {\r\n\tvar deny = Variable.deny;\r\n\tvar operatingFunctions = {};\r\n\tvar operators = {};\r\n\tfunction getOperatingFunction(expression){\r\n\t\t// jshint evil: true\r\n\t\treturn operatingFunctions[expression] ||\r\n\t\t\t(operatingFunctions[expression] =\r\n\t\t\t\tnew Function('a', 'b', 'deny', 'return ' + expression));\r\n\t}\r\n\tfunction operator(operator, name, precedence, forward, reverseA, reverseB){\r\n\t\t// defines the standard operators\r\n\t\tvar reverse = function(output, inputs){\r\n\t\t\tvar a = inputs[0],\r\n\t\t\t\tb = inputs[1];\r\n\t\t\tif(a && a.put){\r\n\t\t\t\tvar result = reverseA(output, b && b.valueOf());\r\n\t\t\t\tif(result !== deny){\r\n\t\t\t\t\ta.put(result);\r\n\t\t\t\t}\r\n\t\t\t}else if(b && b.put){\r\n\t\t\t\tb.put(reverseB(output, a && a.valueOf()));\r\n\t\t\t}else{\r\n\t\t\t\treturn deny;\r\n\t\t\t}\r\n\t\t};\r\n\t\t// define a function that can lazily ensure the operating function\r\n\t\t// is available\r\n\t\tvar operatorHandler = {\r\n\t\t\tapply: function(instance, args){\r\n\t\t\t\tforward = getOperatingFunction(forward);\r\n\t\t\t\treverseA = reverseA && getOperatingFunction(reverseA);\r\n\t\t\t\treverseB = reverseB && getOperatingFunction(reverseB);\r\n\t\t\t\tforward.reverse = reverse;\r\n\t\t\t\toperators[operator] = operatorHandler = new Variable(forward);\r\n\r\n\t\t\t\taddFlags(operatorHandler);\r\n\t\t\t\targs = Array.prototype.slice.call(args);\r\n\t\t\t\targs.push(deny)\r\n\t\t\t\treturn operatorHandler.apply(instance, args);\r\n\t\t\t}\r\n\t\t};\r\n\t\tfunction addFlags(operatorHandler){\r\n\t\t\toperatorHandler.precedence = precedence;\r\n\t\t\toperatorHandler.infix = reverseB !== false;\r\n\t\t}\r\n\t\taddFlags(operatorHandler);\r\n\t\toperators[operator] = operatorHandler;\r\n\t\toperators[name] = function() {\r\n\t\t\treturn operatorHandler.apply(null, arguments)\r\n\t\t}\r\n\t}\r\n\t// using order precedence from:\r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\r\n\toperator('+', 'add', 6, 'a+b', 'a-b', 'a-b');\r\n\toperator('-', 'subtract', 6, 'a-b', 'a+b', 'b-a');\r\n\toperator('*', 'multiply', 5, 'a*b', 'a/b', 'a/b');\r\n\toperator('/', 'divide', 5, 'a/b', 'a*b', 'b/a');\r\n//\toperator('^', 7, 'a^b', 'a^(-b)', 'Math.log(a)/Math.log(b)');\r\n\toperator('?', 'if', 16, 'b[a?0:1]', 'a===b[0]||(a===b[1]?false:deny)', '[a,b]');\r\n\toperator(':', 'choose', 15, '[a,b]', 'a[0]?a[1]:deny', 'a[1]');\r\n\toperator('!', 'not', 4, '!a', '!a', false);\r\n\toperator('%', 'remainder', 5, 'a%b');\r\n\toperator('>', 'greater', 8, 'a>b');\r\n\toperator('>=', 'greaterOrEqual', 8, 'a>=b');\r\n\toperator('<', 'less', 8, 'a<b');\r\n\toperator('<=', 'lessOrEqual', 8, 'a<=b');\r\n\toperator('===', 'looseEqual', 9, 'a===b');\r\n\toperator('==', 'equal', 9, 'a==b');\r\n\toperator('&', 'and', 8, 'a&&b');\r\n\toperator('|', 'or', 8, 'a||b');\r\n\toperator('round', 'round', 8, 'Math.round(a*Math.pow(10,b||1))/Math.pow(10,b||1)', 'a', 'a');\r\n\treturn operators;\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./operators.js\n ** module id = 6\n ** module chunks = 0\n **/","define(['./util/lang', './Variable'], function (lang, Variable) {\r\n\r\n\tfunction deepCopy(source, target, derivativeMap) {\r\n\t\tif (source && typeof source == 'object') {\r\n\t\t\tif (source instanceof Array) {\r\n\t\t\t\ttarget = [] // always create a new array for array targets\r\n\t\t\t\tfor(var i = 0, l = source.length; i < l; i++) {\r\n\t\t\t\t\ttarget[i] = deepCopy(source[i], null, derivativeMap)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (!target || typeof target !== 'object') {\r\n\t\t\t\t\ttarget = derivativeMap && derivativeMap.get(source)\r\n\t\t\t\t\tif (!target) {\r\n\t\t\t\t\t\ttarget = {}\r\n\t\t\t\t\t\tderivativeMap && derivativeMap.set(source, target)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i in source) {\r\n\t\t\t\t\ttarget[i] = deepCopy(source[i], target[i], derivativeMap)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn target\r\n\t\t}\r\n\t\treturn source\r\n\t}\r\n\r\n\tvar Copy = lang.compose(Variable, function(copiedFrom) {\r\n\t\t// this is the variable that we derive from\r\n\t\tthis.copiedFrom = copiedFrom\r\n\t\tthis.derivativeMap = new lang.WeakMap(null, 'derivative')\r\n\t\tthis.isDirty = new Variable(false)\r\n\t}, {\r\n\t\tvalueOf: function(context) {\r\n\t\t\tif(this.state) {\r\n\t\t\t\tthis.state = null\r\n\t\t\t}\r\n\t\t\tvar value = this.copiedFrom.valueOf(context)\r\n\t\t\tif(value && typeof value == 'object') {\r\n\t\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\t\tif (derivative == null) {\r\n\t\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t\t\tthis.setValue(derivative, context)\r\n\t\t\t\t}\r\n\t\t\t\treturn derivative\r\n\t\t\t}\r\n\t\t\tvar thisValue = this.getValue ? this.getValue(context) : this.value\r\n\t\t\tif(thisValue === undefined) {\r\n\t\t\t\treturn value\r\n\t\t\t}\r\n\t\t\treturn thisValue\r\n\t\t},\r\n\t\tgetCopyOf: function(value) {\r\n\t\t\tvar derivative = this.derivativeMap.get(value)\r\n\t\t\tif (derivative == null) {\r\n\t\t\t\tthis.derivativeMap.set(value, derivative = deepCopy(value, undefined, this.derivativeMap))\r\n\t\t\t}\r\n\t\t\treturn derivative\r\n\t\t},\r\n\t\tsave: function() {\r\n\t\t\t// copy back to the original object\r\n\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\tvar newCopiedFrom = deepCopy(this.valueOf(), original)\r\n\t\t\tif (original !== newCopiedFrom) {\r\n\t\t\t\t// if we have replaced it with a new object/value, put it\r\n\t\t\t\tthis.copiedFrom.put && this.copiedFrom.put(newCopiedFrom)\r\n\t\t\t} else {\r\n\t\t\t\t// else we have modified an existing object, but we still need to notify\r\n\t\t\t\tif (this.copiedFrom.notifies && this.copiedFrom.updated) { // copiedFrom doesn't have to be a variable, it can be a plain object\r\n\t\t\t\t\tthis.copiedFrom.updated()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.isDirty.put(false)\r\n\t\t\tthis.onSave && this.onSave()\r\n\t\t},\r\n\t\trevert: function() {\r\n\t\t\tvar original = this.copiedFrom.valueOf()\r\n\t\t\tthis.put(deepCopy(original, this.derivativeMap.get(original), this.derivativeMap))\r\n\t\t\tthis.isDirty.put(false)\r\n\t\t},\r\n\t\tupdated: function() {\r\n\t\t\tthis.isDirty.put(true)\r\n\t\t\treturn Variable.prototype.updated.apply(this, arguments)\r\n\t\t}\r\n\t})\r\n\treturn Copy\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Copy.js\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":""}